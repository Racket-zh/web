<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <title>Racket Blog (page 13)</title>
    <meta name="description" content="Racket Blog (page 13)">
    <meta name="author"      content="The Unknown Author">
    <meta name="keywords"    content="Chez Scheme, all">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon"      href="/favicon.ico">
    <link rel="canonical" href="http://blog.racket-lang.org/index-13.html">


    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="stylesheet" type="text/css" href="/css/blog-fonts.css">
    <!-- Feeds -->
    <link rel="alternate" type="application/atom+xml" href="/feeds/all.atom.xml" title="Atom Feed">
    <link rel="alternate" type="application/rss+xml" href="/feeds/all.rss.xml" title="RSS Feed">
    <!-- JS -->
    </head>
  <body>
<row class="one-column" id="logo"><col-1><a href="http://racket-lang.org"><div id="logo-container"><img id="logo" src="/img/racket-logo.svg"/> Racket</div></a></col-1><col-2><p><a href="/index.html">blog</a></p></col-2></row>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>06 Jun 2008</p></col-1>

<col-2>
  <h1><a href='/2008/06/the-tour-in-video.html'>The Tour in Video</a></h1>
  <div class="truncate">
<p><em>posted by Shriram Krishnamurthi</em></p>

<p>Putting behind its stodgy textual past, the DrScheme tour is now <a href="http://www.youtube.com/watch?v=vgQO_kHl39g">in video</a>! It&rsquo;s rather preliminary, and can use lots of improvement, but now we&rsquo;re really taking it to the kids.</p></div>
  <a class="more" href='/2008/06/the-tour-in-video.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>03 Jun 2008</p></col-1>

<col-2>
  <h1><a href='/2008/06/plt-scheme-version-40-is-coming-soon.html'>PLT Scheme version 4.0 is Coming Soon</a></h1>
  <div class="truncate">
<p><em>posted by Matthew Flatt</em></p>

<p>PLT Scheme is now 13 years old. The initial version was little more than glue code between a few open-source libraries, which seemed to offer the quickest solution to our modest goals. Modest success leads to bigger goals, however, and then continued success leads to ever more ambitious goals. Before you know it, a mass of users, co-developers, libraries, and documentation rely on design decisions that were made for a much smaller project years before.</p>

<p>Naturally, many of those early design decisions turn out to be a poor fit for the project&rsquo;s eventual role. Starting from scratch isn&rsquo;t usually practical, so you gradually adjust the infrastructure to meet new needs. That was precisely the story for the version 300 series of releases for PLT Scheme. The biggest gap between our original and current goals was in run-time performance, so we replaced bytecode interpretation with a just-in-time native-code compiler, and we replaced a memory manager based on &ldquo;conservative&rdquo; estimates of pointer usage with one that uses precise information.</p>

<p>Performance improves a bit more with version 4.0, but mostly we&rsquo;ve moved on to a bigger mismatch between the original and current goals: the way that PLT Scheme presents itself to users. PLT Scheme was originally conceived as R5RS Scheme with some extensions to make it practical, and with useful tools (notably an IDE) and libraries (notably a GUI library) built on that core. Our documentation and web pages reflected that architecture - which now seems completely upside-down.</p>

<p>Version 4.0 is a fresh start in the way that we present PLT Scheme. It&rsquo;s a new language. PLT Scheme is a dialect of Scheme, certainly, but it&rsquo;s not merely a superset of R5RS, R6RS, or other standards, and those standards are not really the best place to start understanding PLT Scheme. At the same time, the unique extensibility features of the PLT Scheme language and tools allow them to support other languages easily, including R5RS (though a new <code>plt-r5rs</code> executable), R6RS, and more.</p>

<p>Improvements to the PLT Scheme language include better syntax for modules, better support for optional and keyword function arguments, more expressive syntax for structure types, streamlined hash-table operations, new syntax for list comprehensions and iterations, a more complete and consistent set of list and string operations, and reduced dependence on mutable pairs. To current users of PLT Scheme, these changes will seem like the big ones behind version 4.0, but they&rsquo;re small compared to the overall re-organization and the accompanying documentation effort.</p>

<p>We wrote hundreds of pages of new documentation, including much more tutorial and overview information. We ported hundreds of pages of existing documents to new a system that produces cleaner, better organized, more consistent output. We will replace the old tangle of web pages (that try to explain a confusing federation of tools) with a simple page about &ldquo;PLT Scheme.&rdquo; We have even streamlined the command-line flags for the main virtual machine.</p>

<p>The development of PLT Scheme version 4.0 took about one year of hard work. In retrospect, that doesn&rsquo;t sound too bad, considering the scale of the existing code base, the number of things that we improved, and the total size of the documentation (about 2000 pages in PDF form). Still, you can imagine how happy we are to arrive at a stable release, and we hope that the improvements in PLT Scheme version 4.0 work as well for everyone else as they do for us.</p>

<p>For a preview, see <a href="http://pre.plt-scheme.org/">http://pre.plt-scheme.org/</a>. The final version 4.0 release is just days away.</p></div>
  <a class="more" href='/2008/06/plt-scheme-version-40-is-coming-soon.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>23 Feb 2008</p></col-1>

<col-2>
  <h1><a href='/2008/02/dirty-looking-hygiene.html'>Dirty Looking Hygiene</a></h1>
  <div class="truncate">
<p><em>posted by Eli Barzilay</em></p>

<p>With the recent release of <a href="http://arclanguage.com/">Arc</a>, there has been some discussion over hygienic macros. Yes, hygienic macros are usually very convenient, but they can become messy in some &lsquo;corner&rsquo; cases. People who learn about macros in Scheme usually start with <code>syntax-rules</code>, and being the limited tool that it is, they often get the impression that for advanced uses (like a macro that captures an identifier) you need to use <code>syntax-case</code> which is this &ldquo;really obscure thing&rdquo;.</p>

<p>For example, say that we want to implement an <code>if</code> form that is similar to Arc&rsquo;s <code>if</code>. This is pretty easy using <code>syntax-rules</code>:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit">define-syntax</a></span> <span class="n">if*</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._syntax-rules))" style="color: inherit">syntax-rules</a></span> <span class="p">()</span>
      <span class="p">[(</span><span class="n">if*</span><span class="p">)</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/void.html#(def._((quote._~23~25kernel)._void))" style="color: inherit">void</a></span><span class="p">)]</span>
      <span class="p">[(</span><span class="n">if*</span> <span class="n">X</span><span class="p">)</span> <span class="n">X</span><span class="p">]</span>
      <span class="p">[(</span><span class="n">if*</span> <span class="n">C</span> <span class="n">X</span> <span class="n">more</span> <span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit">...</a></span><span class="p">)</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit">if</a></span> <span class="n">C</span> <span class="n">X</span> <span class="p">(</span><span class="n">if*</span> <span class="n">more</span> <span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit">...</a></span><span class="p">))]))</span>
</pre></div>

</div>

<p>But more important than being easy to write: it is also easy to read. In fact, the nice thing about <code>syntax-rules</code> is that you write more or less the specification of your transformation. Compare this to the specification of Arc&rsquo;s <code>if</code>, which appears in a comment before the definition of <code>ac-if</code> in "<code>ac.scm</code>":</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span>  <span class="c1">; (if) -&gt; nil</span>
  <span class="c1">; (if x) -&gt; x</span>
  <span class="c1">; (if t a ...) -&gt; a</span>
  <span class="c1">; (if nil a b) -&gt; b</span>
  <span class="c1">; (if nil a b c) -&gt; (if b c)</span>
</pre></div>

</div>

<p>(Except that the comment mixes up the syntactic specification and the semantic evaluation.)</p>

<p>As a side note, now that we have this definition, it is easy to construct a new language that is just like MzScheme, except for its <code>if</code> that behaves like the above:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/module.html#(form._((quote._~23~25kernel)._module))" style="color: inherit">module</a></span> <span class="n">arc-like</span> <span class="n">mzscheme</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit">define-syntax</a></span> <span class="n">if*</span> <span class="n">..._the</span> <span class="n">above</span> <span class="n">definition_...</span><span class="p">)</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._provide))" style="color: inherit">provide</a></span> <span class="p">(</span><span class="n">all-from-except</span> <span class="n">mzscheme</span> <span class="k"><a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit">if</a></span><span class="p">)</span>
             <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/creatingunits.html#(form._((lib._racket/unit..rkt)._rename))" style="color: inherit">rename</a></span> <span class="n">if*</span> <span class="k"><a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit">if</a></span><span class="p">)))</span>
</pre></div>

</div>

<p>You can now write code that uses <code>"arc-like.scm"</code> as its language, using the new <code>if</code>. There is no problem in accommodating two languages with two different <code>if</code>&rsquo;s: the new form is compiled to the old one, and there is no confusion in which version you use in any module.</p>

<p>Back to the macro issue: as I said above, you run into problems if you want to capture names, right? For example, if you want to implement Arc&rsquo;s <code>aif</code>. The usual <code>syntax-case</code> solution is to construct an identifier that has the lexical context of the input syntax. It&rsquo;s easy to abstract over all this &mdash; I posted a <a href="http://www.arclanguage.org/item?id=841">message</a> on the Arc forum showing how to define a <a href="http://tmp.barzilay.org/defmac.ss">defmac</a> macro that has the simplicity of <code>syntax-rules</code> with the added convenience of specifying keywords and captured names. This works for <em>some</em> cases, but there are still some <a href="http://download.plt-scheme.org/doc/372/html/mzscheme/mzscheme-Z-H-12.html#node_sec_12.2.1.1">subtle corner cases</a>.</p>

<p>But there&rsquo;s a better solution in PLT Scheme, one that follows Paul Graham&rsquo;s intuition when he <a href="http://www.arclanguage.org/item?id=2526">says</a>: &ldquo;captured symbols are kind of freaky.&rdquo; The basic idea is a change of perspective: instead of (unhygienically) binding individual occurrences of <code>it</code> whenever <code>aif</code> is used, you define <code>it</code> once as a thing in its own right &mdash; a special context-dependent piece of syntax. Outside of an <code>aif</code> form, <code>it</code> has no meaning: we simply make it throw a syntax error. Uses of <code>aif</code> provide a meaning for <code>it</code> by locally changing its meaning (its expansion) to something useful: the binding that holds the result of evaluating the condition expression. (&ldquo;Locally&rdquo; means within a piece of syntax, so the new meaning is valid in a lexical-scope.)</p>

<p>In PLT Scheme, the &ldquo;special context-dependent piece of syntax&rdquo; are <em>syntax parameters</em>, and you change them locally with <code>syntax-parameterize</code>.</p>

<p>To continue the above example, here&rsquo;s how we make our <code>if*</code> anaphoric:</p>

<ul>
 <li>
  <p>require the <code>(lib "stxparam.ss" "mzlib")</code> library,</p></li>
 <li>
  <p>define <code>it</code> as a syntax using <code>define-syntax-parameter</code>, and have it raise an error by default,</p></li>
 <li>
  <p>bind a temporary variable to the result of evaluating the condition,</p></li>
 <li>
  <p>wrap the positive branch with <code>syntax-parameterize</code>, using <code>make-rename-transformer</code>, which is a convenient way to make a macro that behaves like the new variable.</p></li></ul>

<p>The implementation looks like this:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span>  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._require))" style="color: inherit">require</a></span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._lib))" style="color: inherit">lib</a></span> <span class="s2">"stxparam.ss"</span> <span class="s2">"mzlib"</span><span class="p">))</span>
  <span class="p">(</span><span class="n"><a href="http://docs.racket-lang.org/reference/stxparam.html#(form._((lib._racket/stxparam..rkt)._define-syntax-parameter))" style="color: inherit">define-syntax-parameter</a></span> <span class="n">it</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="n">stx</span><span class="p">)</span>
      <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/exns.html#(def._((quote._~23~25kernel)._raise-syntax-error))" style="color: inherit">raise-syntax-error</a></span> <span class="no">#f</span> <span class="s2">"can <a href="http://docs.racket-lang.org/reference/creatingunits.html#(form._((lib._racket/unit..rkt)._only))" style="color: inherit">only</a> be used inside `if'"</span> <span class="n">stx</span><span class="p">)))</span>
  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit">define-syntax</a></span> <span class="n">if*</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._syntax-rules))" style="color: inherit">syntax-rules</a></span> <span class="p">()</span>
      <span class="p">[(</span><span class="n">if*</span><span class="p">)</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/void.html#(def._((quote._~23~25kernel)._void))" style="color: inherit">void</a></span><span class="p">)]</span>
      <span class="p">[(</span><span class="n">if*</span> <span class="n">X</span><span class="p">)</span> <span class="n">X</span><span class="p">]</span>
      <span class="p">[(</span><span class="n">if*</span> <span class="n">C</span> <span class="n">X</span> <span class="n">more</span> <span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit">...</a></span><span class="p">)</span>
       <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="p">([</span><span class="n">b</span> <span class="n">C</span><span class="p">])</span>
         <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit">if</a></span> <span class="n">b</span>
           <span class="p">(</span><span class="n"><a href="http://docs.racket-lang.org/reference/stxparam.html#(form._((lib._racket/stxparam..rkt)._syntax-parameterize))" style="color: inherit">syntax-parameterize</a></span> <span class="p">([</span><span class="n">it</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._make-rename-transformer))" style="color: inherit">make-rename-transformer</a></span> <span class="o">#'</span><span class="n">b</span><span class="p">)])</span> <span class="n">X</span><span class="p">)</span>
           <span class="p">(</span><span class="n">if*</span> <span class="n">more</span> <span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit">...</a></span><span class="p">)))]))</span>
</pre></div>

</div>

<p>The resulting macro does not break hygiene. For example, <code>(let ([it 3]) (if #t it))</code> evaluates to <code>3</code>, because it shadows the global <code>it</code> that <code>if</code> changes. This is a change from a real unhygienic macro &mdash; but that&rsquo;s the whole point: we (the macro author) do not interfere with scopes in the user code.</p>

<p>Note that <code>(if 1 (if 2 it))</code> still evaluates to <code>2</code>, because the outer <code>if</code> does not really bind <code>it</code> &mdash; it is not captured, just changed locally &mdash; so the inner <code>if</code> changes it again. Also, <code>(if #f it it)</code> raises the usual context error, since our macro changes <code>it</code> only in the positive branch.</p></div>
  <a class="more" href='/2008/02/dirty-looking-hygiene.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>14 Jan 2008</p></col-1>

<col-2>
  <h1><a href='/2008/01/a-privacy-flaw-thwarted.html'>A Privacy Flaw, Thwarted</a></h1>
  <div class="truncate">
<p><em>posted by Shriram Krishnamurthi</em></p>

<p>My student Brendan Hickey recently identified the following security hole.</p>

<p>A university (let&rsquo;s call it Orange University) wants to let its graduating students vote on their graduation speaker. They used to do it by paper; catching up with the times, they now do it on the Web.</p>

<p>They used to have a box into which you could type the name of your nominee. But that is surely problematic: people misspell names, you have to argue about how to count ambiguous votes, someone will vote for their pet bonobo, etc. Better (perhaps) to give them the names of all the students and let them choose. [Alert: if Orange U adopts a simple naming scheme for email addresses, a student can immediately screen-scrape a pretty plum list to sell a spammer. Brendan and I noticed this in a femtosecond; I don&rsquo;t know why this didn&rsquo;t occur to the university.]</p>

<p>Anyway, now you have a Web page where people are going to choose, and the software that processes the responses must distinguish between these choices. You have to associate a key with each student. You&rsquo;ve already got a key for each candidate: their student ID number. So you use that as your key. Now anyone viewing the page source can immediately see which student ID number goes with which student name. So much for confidentiality.</p>

<p>Whoops.</p>

<p>I&rsquo;d like to point out that Pete Hopkins&rsquo;s <code>send/suspend/dispatch</code>, and the improved version of it by Jay McCarthy, identify and solve just this code structuring problem in a way that the privacy leak can never occur. For the most up-to-date presentation of it, read section 3.2 and section 4 of <a href="http://www.cs.brown.edu/~sk/Publications/Papers/Published/khmgpf-impl-use-plt-web-server-journal/">our paper</a>.</p>

<p>Maybe Orange U should be using Scheme.</p></div>
  <a class="more" href='/2008/01/a-privacy-flaw-thwarted.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>29 Dec 2007</p></col-1>

<col-2>
  <h1><a href='/2007/12/the-design-of-extended-exercises.html'>The Design of Extended Exercises</a></h1>
  <div class="truncate">
<p><em>posted by Shriram Krishnamurthi</em></p>

<p>One of the highlights of the TeachScheme! method is to create Extended Exercises. Several of these pepper <em>How to Design Programs</em>, and even more have been created since to deal with a variety of interesting problem scenarios (e.g., illustrating graphics via t-shirt design, explaining networking by having machines play roles in a theatrical play, demonstrating communication with foreign sites by processing data from a microfinance institution, etc). Through an Extended Exercise a student learns about how computer science connects to domains, develops practice building programs incrementally, learns to build earlier assignments that later assignments can depend on, and so forth.</p>

<p>Here is a preliminary articulation of some principles that I think govern a good Extended Exercise, with an emphasis on their &ldquo;form factor&rdquo;.</p>

<ul>
 <li>
  <p>Pick a domain. Whether the domain looks inward (a computing activity such as networking) or outward (such as social networking) doesn&rsquo;t matter. If it does look inward, try to make it more applicable through the judicious use of data (the same exercise can look very dry or very applied depending on what data you choose). For instance, our networking exercises is presented in terms of Shakespeare&rsquo;s Hamlet.</p></li>
 <li>
  <p>If necessary, write a Teachpack. A domain almost certainly needs a Teachpack to reduce the programming burden on students. For instance, the microfinance exercise uses a Teachpack to hide the ugly details of screen-scraping (which in turn need to be constantly updated by a vigilant maintainer).</p></li>
 <li>
  <p>Try to provide a non-trivial dataset in the Teachpack. Good data can make an assignment more enjoyable&mdash;e.g., our networking example provides an excerpt from Act 2, Scene 2 of Hamlet (&ldquo;What a piece of work is man!&rdquo;)&mdash;and in cases where the exercise depends on connecting to an external site (e.g., the microfinance example), the data may be essential.</p></li>
 <li>
  <p>Structure the assignment to have five to eight questions: not much fewer (too few steps) nor much more (too much to grasp).</p></li>
 <li>
  <p>Try to decompose the problem using good principles of stepwise refinement, using your own wisdom in these matters. By showing students several such examples, we hope for them to build up an intuition for the process. Your decomposition may not be strictly linear; that&rsquo;s okay. But it should be progressive.</p></li>
 <li>
  <p>Perhaps the most important point: At every step, try to have a full, working application. That means the Teachpack may need to export several interfaces, each one taking more parameters and accepting more functionality than the previous one. Otherwise the student needs to have all the parts working before they can understand whether even one works in context, leading to a frustrating learning experience and encouraging wanton hacking as they try (and invariably fail) to quickly get to a working system.</p></li>
 <li>
  <p>Design interfaces carefully to make judicious use of first-class functions. It is inevitable that students will need to provide functions (not just flat data) to what your Teachpack exports. Show them the invocations of your Teachpack in terms of named functions (that they define).</p></li>
 <li>
  <p>Try to provide a few extra-credit routes for ambitious students. Options include letting students peel back even more of the Teachpack, or adding interesting features.</p></li></ul></div>
  <a class="more" href='/2007/12/the-design-of-extended-exercises.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>29 Dec 2007</p></col-1>

<col-2>
  <h1><a href='/2007/12/plt-scheme-v372.html'>PLT Scheme v372</a></h1>
  <div class="truncate">
<p><em>posted by Eli Barzilay</em></p>

<p>PLT Scheme version 372 is now available from <a href="http://download.plt-scheme.org/">http://download.plt-scheme.org/</a></p>

<p>This is mostly a bug-fix release. Changes:</p>

<ul>
 <li>
  <p>DrScheme now supports name completion via Ctl-/ (Windows and X) or Cmd-/ (Mac OS X). Completion is sensitive to the current language in DrScheme, but it is not sensitive to lexical bindings.</p></li>
 <li>
  <p>DrScheme&rsquo;s stepper now supports the &ldquo;check-expect&rdquo;, &ldquo;check-within&rdquo;, and &ldquo;check-error&rdquo; forms of the testing.ss teachpack.</p></li>
 <li>
  <p>A number of bug fixes and small improvements for ProfessorJ. The grammar for the current release slightly differs from the one in HtDC.Feedback Welcome.</p></li></ul></div>
  <a class="more" href='/2007/12/plt-scheme-v372.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>19 Dec 2007</p></col-1>

<col-2>
  <h1><a href='/2007/12/your-security-hole-is-my-fun-hack-or-computing-factorial-in-drscheme-with-a-click-powered-loop.html'>Your security hole is my fun hack, or: computing factorial in DrScheme with a click-powered loop.</a></h1>
  <div class="truncate">
<p><em>posted by Robby Findler</em></p>

<p>One of the many changes in v4.0 is to close a security hole in DrScheme. Specifically, DrScheme v371 lets the program in the definitions window get a hold of the editor containing said program and manipulate it programmatically. There are lots of bad things one might do with this fact, like circumventing DrScheme&rsquo;s protections and cause it to crash, or even spontaneously exit.</p>

<p>But, we can do something even more fun. Put the following program into a DrScheme window (in v371) and set the language to the mzscheme/textual language. Change &ldquo;input&rdquo; to whatever number you wish to compute the factorial of and then hit the Run button until your program transforms itself into the final result.</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="n">input</span> <span class="mi">10</span><span class="p">)</span>
<span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._require))" style="color: inherit">require</a></span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._lib))" style="color: inherit">lib</a></span> <span class="s2">"mred.ss"</span> <span class="s2">"mred"</span><span class="p">)</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._lib))" style="color: inherit">lib</a></span> <span class="s2">"class.ss"</span><span class="p">))</span>
<span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let*))" style="color: inherit">let*</a></span> <span class="p">([</span><span class="n">ed</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let-syntax))" style="color: inherit">let-syntax</a></span> <span class="p">([</span><span class="n">m</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._~ce~bb))" style="color: inherit">λ</a></span> <span class="p">(</span><span class="n">stx</span><span class="p">)</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._with-syntax))" style="color: inherit">with-syntax</a></span> <span class="p">([</span><span class="n">x</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._syntax-source))" style="color: inherit">syntax-source</a></span> <span class="n">stx</span><span class="p">)])</span> <span class="o">#'</span><span class="n">x</span><span class="p">))])</span>
             <span class="p">(</span><span class="n">m</span><span class="p">))]</span>
       <span class="p">[</span><span class="n">mth</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/regexp.html#(def._((quote._~23~25kernel)._regexp-match))" style="color: inherit">regexp-match</a></span> 
             <span class="sr">#rx"^; ([0-9]+) ([0-9]+)"</span> 
             <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">get-text</span> <span class="mi">0</span> 
                   <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">paragraph-end-position</span> <span class="mi">0</span><span class="p">)))]</span>
       <span class="p">[</span><span class="n">lckd</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">is-locked?</span><span class="p">)])</span>
  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">begin-edit-sequence</span><span class="p">)</span>
  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">lock</span> <span class="no">#f</span><span class="p">)</span>
  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit">if</a></span> <span class="n">mth</span>
      <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="p">([</span><span class="n">n</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._string-~3enumber))" style="color: inherit">string-&gt;number</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list-ref))" style="color: inherit">list-ref</a></span> <span class="n">mth</span> <span class="mi">1</span><span class="p">))]</span>
            <span class="p">[</span><span class="n">acc</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._string-~3enumber))" style="color: inherit">string-&gt;number</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list-ref))" style="color: inherit">list-ref</a></span> <span class="n">mth</span> <span class="mi">2</span><span class="p">))])</span>
        <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">delete</span> <span class="mi">0</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">paragraph-end-position</span> <span class="mi">0</span><span class="p">))</span>
        <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit">if</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3d))" style="color: inherit">=</a></span> <span class="n">n</span> <span class="mi">1</span><span class="p">)</span>
            <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit">begin</a></span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">delete</span> <span class="mi">0</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">paragraph-end-position</span> <span class="mi">0</span><span class="p">))</span>
                   <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">insert</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._format))" style="color: inherit">format</a></span> <span class="s2">"~a</span><span class="se">\n</span><span class="s2">#|"</span> <span class="n">acc</span><span class="p">)</span> <span class="mi">0</span><span class="p">)</span>
                   <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">insert</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">|#"</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">last-position</span><span class="p">)))</span>
            <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin))" style="color: inherit">begin</a></span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">delete</span> <span class="mi">0</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">paragraph-end-position</span> <span class="mi">0</span><span class="p">))</span>
                   <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">insert</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._format))" style="color: inherit">format</a></span> <span class="s2">"; <a href="http://docs.racket-lang.org/reference/strings.html#(def._((lib._racket/format..rkt)._~7ea))" style="color: inherit">~a</a> ~a"</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._-))" style="color: inherit">-</a></span> <span class="n">n</span> <span class="mi">1</span><span class="p">)</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._*))" style="color: inherit">*</a></span> <span class="n">n</span> <span class="n">acc</span><span class="p">))</span> <span class="mi">0</span> <span class="mi">0</span><span class="p">))))</span>
      <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">insert</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._format))" style="color: inherit">format</a></span> <span class="s2">"; <a href="http://docs.racket-lang.org/reference/strings.html#(def._((lib._racket/format..rkt)._~7ea))" style="color: inherit">~a</a> 1</span><span class="se">\n</span><span class="s2">"</span> <span class="n">input</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">lock</span> <span class="n">lckd</span><span class="p">)</span>
  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/ivaraccess.html#(form._((lib._racket/private/class-internal..rkt)._send))" style="color: inherit">send</a></span> <span class="n">ed</span> <span class="n">end-edit-sequence</span><span class="p">))</span>
</pre></div>

</div></div>
  <a class="more" href='/2007/12/your-security-hole-is-my-fun-hack-or-computing-factorial-in-drscheme-with-a-click-powered-loop.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>12 Nov 2007</p></col-1>

<col-2>
  <h1><a href='/2007/11/getting-rid-of-set-car-and-set-cdr.html'>Getting rid of <code>set-car!</code> and <code>set-cdr!</code></a></h1>
  <div class="truncate">
<p><em>posted by Matthew Flatt</em></p>

<h2 id="functional-is-beautiful">Functional is Beautiful</h2>

<p>Scheme is a “mostly functional” language. Although Schemers don’t hesitate to use <code>set!</code> when mutation solves a problem best, Scheme programmers prefer to think functionally. Purely functional programs are easier to test, they make better and more reliable APIs, and our environments, compilers, and run-time systems take advantage of functional style.</p>

<p>A Schemer’s functional bias is especially strong when writing programs that process and produce lists. The <code>map</code> function, which does both, is a thing of beauty:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span>  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit">map</a></span> <span class="n">f</span> <span class="n">l</span><span class="p">)</span>
   <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._cond))" style="color: inherit">cond</a></span>
     <span class="p">[(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._null~3f))" style="color: inherit">null?</a></span> <span class="n">l</span><span class="p">)</span> <span class="o">'</span><span class="p">()]</span>
     <span class="p">[</span><span class="k"><a href="http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._else))" style="color: inherit">else</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cons))" style="color: inherit">cons</a></span> <span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._car))" style="color: inherit">car</a></span> <span class="n">l</span><span class="p">))</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit">map</a></span> <span class="n">f</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cdr))" style="color: inherit">cdr</a></span> <span class="n">l</span><span class="p">)))]))</span>
</pre></div>

</div>

<p>The <code>map</code> function is most beautiful when the given <code>f</code> is functional. If <code>f</code> has side-effects, the the above implementation over-specifies <code>map</code>, which is traditionally allowed to process the list in any order that it wants (though PLT Scheme guarantees left-to-right order, as above). Arguably, when some other Schemer provides a non-functional <code>f</code>, then it’s their problem; they have to deal with the consequences (which may well be minor compared to some benefits of using mutation).</p>

<p>The <code>map</code> function might also receive a non-list, but the <code>map</code> implementor can guard against such misuse of <code>map</code> by wrapping it with a check,</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span>  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="p">(</span><span class="n">checked-map</span> <span class="n">f</span> <span class="n">l</span><span class="p">)</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit">if</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list~3f))" style="color: inherit">list?</a></span> <span class="n">l</span><span class="p">)</span>
        <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit">map</a></span> <span class="n">f</span> <span class="n">l</span><span class="p">)</span>
        <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/exns.html#(def._((quote._~23~25kernel)._error))" style="color: inherit">error</a></span> <span class="o">'</span><span class="ss"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit">map</a></span> <span class="s2">"not a list"</span><span class="p">)))</span>
</pre></div>

</div>

<p>and then exporting <code>checked-map</code> instead of the raw <code>map</code>. This kind of checking gives nicer error messages, and it helps hide implementation details of <code>map</code>. We could further also imagine that the raw <code>map</code> is compiled without run-time checks on <code>car</code> and <code>cdr</code>.</p>

<h2 id="the-problem-with-mutable-pairs">The Problem with Mutable Pairs</h2>

<p>What if someone calls <code>checked-map</code> like this?:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span>  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="n">l</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._list))" style="color: inherit">list</a></span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span> <span class="mi">5</span><span class="p">))</span>
  <span class="p">(</span><span class="n">checked-map</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
                 <span class="p">(</span><span class="n">set-cdr!</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cddr))" style="color: inherit">cddr</a></span> <span class="n">l</span><span class="p">)</span> <span class="mi">5</span><span class="p">))</span>
               <span class="n">l</span><span class="p">)</span>
</pre></div>

</div>

<p>The <code>f</code> provided to <code>map</code> in this case is not purely functional. Moreover, it uses mutation in a particularly unfortunate way: the <code>list?</code> test in <code>checked-map</code> succeeds, because the argument is initially a list, and the mutation is ultimately discovered by a call to <code>cdr</code> &mdash; but only if checks haven&rsquo;t been disabled.</p>

<p>If you’re a Schemer, then unless you’ve seen this before, or unless you thought a bit about the title of this section, then you probably didn&rsquo;t think of the above test case for <code>map</code>. A Schemer’s view of lists is so deeply functional that it&rsquo;s hard to make this particular leap.</p>

<p>Furthermore, this example is not contrived. If you have either Chez Scheme version 6.1 or a pre&ndash;200 MzScheme sitting around, calling <code>map</code> as above leads to a seg fault or an invalid memory access:</p>

<div class="brush: bash">
 <div class="pygments">
  <pre><span></span>  Chez Scheme Version <span class="m">6</span>.1
  Copyright <span class="o">(</span>c<span class="o">)</span> <span class="m">1998</span> Cadence Research Systems

  &gt; <span class="o">(</span>define l <span class="o">(</span>list <span class="m">1</span> <span class="m">2</span> <span class="m">3</span> <span class="m">4</span> <span class="m">5</span><span class="o">))</span>
  &gt; <span class="o">(</span>map <span class="o">(</span>lambda <span class="o">(</span>x<span class="o">)</span> <span class="o">(</span>set-cdr! <span class="o">(</span>cddr l<span class="o">)</span> <span class="m">5</span><span class="o">))</span> l<span class="o">)</span>

  Error: invalid memory reference.
  Some debugging context may have been lost.
</pre></div>

</div>

<p>The <code>map</code> example illustrates how mutable pairs can break a Schemer’s natural and ingrained model of programming. Of course, if optimizing and providing friendly error messages for <code>map</code> were the only issues with mutable pairs, then it wouldn’t matter; Scheme implementors are smart enough to (eventually) get this right. Unfortunately, the underlying problem is more pervasive.</p>

<p>In the API for a typical Scheme library, lists can be used for many kinds of input and output. Flags for options might be provided in a list. A function might provide information about the current configuration (e.g., the current items in a GUI list box) in a list. Procedures or methods that deal gracefully with list mutation are few and far between. In most cases, the result of unexpected mutation is merely a bad error message; sometimes, however, unexpected mutation of a list can break the library’s internal invariants. In the worst case, the library whose internal invariants are broken plays some role in a system’s overall security.</p>

<p>Mutable lists also interfere with the language’s extensibility. The PLT Scheme contract system, for example, offers a way to wrap an exported function with a contract that constrains its input and outputs, which are optionally (in principle) enforced by run-time checks. Higher-order contracts, such as “a list of functions that consume and produce numbers”, require wrappers on sub-pieces, and these wrappers can be installed only by copying the enclosing list. Copying a mutable list changes the semantics of a program, however, whereas contracts are supposed to enforce invariants without otherwise changing the program. Copying an immutable list creates no such problem.</p>

<p>Finally, mutable lists make the language’s specification messy. The R6RS editors spent considerable energy trying to pin down the exception-raising guarantees of <code>map</code>; the possibility of mutable pairs made it difficult to provide much of a guarantee. The standard says that implementations should check that the lists provided to<code>map</code> are the same length, but it’s not worth much to require that check, since an argument’s length as a list can change via mutation to the list’s pairs.</p>

<h2 id="switching-to-immutable-pairs">Switching to Immutable Pairs</h2>

<p>The designers of PLT Scheme long ago recognized the problems of mutable pairs, and we introduced functions like <code>cons-immutable</code> and<code>list-immutable</code> to support programming with immutable lists. These additions solved some problems &mdash; but only in the cases where we were careful to use immutable lists. The R6RS editors also recognized the problems of mutable pairs, so that <code>set-car!</code> and <code>set-cdr!</code> were banished to their own library &mdash; but programmers are still free to use that library.</p>

<p>While these are worthwhile steps for many reasons, they do not solve the underlying problem. Library implementors who deal in lists must still either set up elaborate guards against mutation, pretend that the problem doesn&rsquo;t matter, or require the use of a special immutable-list datatype that is incompatible with libraries whose authors set up elaborate guards or ignore the problem.</p>

<p>Why all this hassle? If most Scheme code really does use and expect pairs in a functional way, can&rsquo;t we just switch to immutable pair? Most Scheme code will still work, untold security holes will have been closed, specifications will become instantly tighter, and language extensions like contracts will work better.</p>

<p>Schemers have been reluctant to make this leap, because it has never been clear just how much code relies on mutable pairs. We don’t know how much the switch will cost in porting time and long-term incompatibility, and we don’t really know how much we will gain. We won&rsquo;t know until we try it.</p>

<p>For PLT Scheme v4.0, we’re going to try it. In our main dialects of Scheme (such as the <code>mzscheme</code> language), <code>cons</code> will create immutable pairs, and <code>pair?</code> and <code>list?</code> will recognize only immutable pairs and lists. The <code>set-car!</code> and <code>set-cdr</code> procedures will not exist. A new set of procedure <code>mcons</code>, <code>mcar</code>, <code>mcdr</code>, <code>set-mcar!</code>, and <code>set-mcdr!</code> will support mutable pairs. (A related v4.0 change is that <code>define-struct</code> by default creates immutable structure types.)</p>

<p>Of course, PLT Scheme v4.0 will support an R5RS language where <code>cons</code> is <code>mcons</code>, and so on, so many old programs can still run easily in the new version. The difference is that interoperability between R5RS libraries and PLT Scheme libraries will be less direct than before.</p>

<h2 id="experience-so-far">Experience So Far</h2>

<p>PLT Scheme v3.99.0.2 exists already in a branch of our SVN repository, and it will soon move to the SVN trunk. That is, we have already ported at least a half million lines of Scheme code to a dialect without <code>set-car!</code> and <code>set-cdr!</code>.</p>

<p>The conversion took about eight hours. Obviously, relatively little code had to change. The following are the typical porting scenarios:</p>

<ul>
 <li>
  <p>The <code>reverse!</code> and <code>append!</code> functions were frequently used for “linear updates” by performance-conscious implementors. As our underlying Scheme implementation has improved, however, the performance benefits of these functions has become less. All uses could be replaced with <code>reverse</code> and <code>append</code>.</p></li>
 <li>
  <p>The <code>set-cdr!</code> operation was often used to implement an internal queue. Such internal queues were easily changed to use <code>mcons</code>,<code>mcar</code>, <code>mcdr</code>, and <code>set-mcdr!</code>.</p></li>
 <li>
  <p>An association-list mapping was sometimes updated with <code>set-cdr!</code> when a mapping was present, otherwise the list was extended. Since the extension case was supported, it was easy to just update the list functionally. (The relevant lists were short; if the lists were long, the right change would be to use a hash table instead of a list.)</p></li>
 <li>
  <p>A pair was sometime used for an updatable mapping where a distinct structure type is better. The quick solution was to throw in a mutable box in place of the value.</p></li></ul>

<p>The PLT Scheme code might be better positioned for the switch than arbitrary Scheme code. Most of it was written by a handful of people who understood the problems of mutable pairs, and who might therefore shy away from them. However, the PLT Scheme code base includes a lot of code that was not written specifically for PLT Scheme, including Slatex, Tex2page, and many SRFI reference implementations. With the exception of SRFI&ndash;9, which generalizes <code>set!</code> to work with pairs, the SRFI implementations were remarkably trouble free. (Thanks to Olin Shivers for making mutation optional in the “linear update” functions like <code>reverse!</code> from SRFIs 1 and 32.)</p>

<p>In addition, we looked at a number of standard Scheme benchmarks, which can be found here:</p>

<p><a href="http://svn.plt-scheme.org/plt/trunk/collects/tests/mzscheme/benchmarks/common/"> http://svn.plt-scheme.org/plt/trunk/collects/tests/mzscheme/benchmarks/common/</a></p>

<p>Of the 28 benchmarks, eight of them mutate pairs. Four of those are trivially converted to functional programs, along the lines of the scenarios above. One, <code>destruct</code>, is designed specifically to test mutation performance, so it makes no sense to port. Another, <code>sort1</code>, is a sorting algorithm that inherently relies on mutation; a functional sort is obviously possible, but that would be a different benchmark. The <code>conform</code> benchmark uses mutable pairs for tables in a relatively non-local way; as a modern Scheme program, it would probably be written with structures, but it’s not trivial to port. The <code>peval</code> benchmark uses pairs to represent Scheme programs, and it partially evaluates the program by mutating it, so it is not trivial to port. To summarize, out of 28 old, traditional benchmark programs, only two represent interesting programs that are not easily adapted to immutable pairs. (They run in PLT Scheme’s R5RS language, of course.)</p>

<p>Finally, we selected a useful third-party library that is not included with PLT Scheme. We checked the generic SSAX implementation (not the PLT Scheme version), and we found a couple of uses of <code>set-car!</code> and <code>set-cdr!</code>. Again, they fall into the above queue and association-list categories that are easily and locally converted.</p>

<p>Meanwhile, as we start to use v3.99 to run scripts in our day-to-day work, immutable pairs have so far created no difficulty at all. So far, then, our optimism in trying immutable pairs seems to be justified; it just might work.</p>

<h2 id="but-its-lisp-tradition">But It’s Lisp Tradition!</h2>

<p>A typical response to news of the demise of mutable pairs is that it will create lot of trouble, because mutable pairs are Scheme tradition, and surely lots of useful old code exploits them in lots of places.</p>

<p>We’re eager to hear whether anyone has such code. Our initial hypothesis is that practically all old code falls into one of two categories:</p>

<ul>
 <li>
  <p>The code is easily ported to immutable pairs, along the same lines as above (i.e., local queues and small association lists).</p></li>
 <li>
  <p>The code so old and generic that it can be run as an R5RS program. It won’t call into the large PLT Scheme set of libraries that will expect immutable pairs, and it can easily be used as a library with wrappers that convert mutable pairs back and forth with immutable pairs.</p></li></ul>

<p>Frankly, we’re not so eager to hear opinions based on guesswork about existing code and how it might get used. Download v3.99 from SVN or as a nightly build when it becomes available; let us know your guesses about how running your old code would go, but then let us know what actually happens.</p>

<p>The immutable-pairs plan for v4.0 is not set in stone, but we won’t make the decision based on guesswork. More libraries (other than R5RS) to aid compatibility may be useful, but so far we don’t have a tangible need for them. In any case, we’ll revert to mutable pairs only if significant experience with the pre-release version demonstrates that it really won’t work.</p></div>
  <a class="more" href='/2007/11/getting-rid-of-set-car-and-set-cdr.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>14 Sep 2007</p></col-1>

<col-2>
  <h1><a href='/2007/09/dont-say-abstract-instead-say-general.html'>Don&rsquo;t say &ldquo;abstract&rdquo; (instead say &ldquo;general&rdquo;)</a></h1>
  <div class="truncate">
<p><em>posted by John Clements</em></p>

<p>The word &ldquo;abstract&rdquo; is common in computer science. An abstract thing is one where some part of the whole is unspecified. For instance, the expression &ldquo;3*x + 3&rdquo; is an abstraction of the expression &ldquo;3*4+3&rdquo;, because the &ldquo;x&rdquo; is unspecified. Likewise, a function is an abstraction over some set of values, supplied when the function is called.</p>

<p>The word &ldquo;general&rdquo; is not at all common in computer science. In non-computer-science use, the word &ldquo;general&rdquo; is used to describe things that may be applied to more than one thing or situation. For instance, a &ldquo;more general solution&rdquo; is one that applies not just to the problem at hand, but instead to a larger set of problems.</p>

<p>From a computer science perspective, things that are abstract are also general. Things that are general are also abstract. Substituting the word &ldquo;general&rdquo; for the word &ldquo;abstract&rdquo; would not be a terrible hurdle.</p>

<p>From a non-computer-science perspective, however, &ldquo;general&rdquo; and &ldquo;abstract&rdquo; have very different implications. Something that is general is better: it is more useful, it applies more frequently. Something that is abstract, though, is worse: it is lacking detail, it is non-concrete.</p>

<p>This is one difference&mdash;the major difference?&mdash;between computer science (and of course mathematics) and the real world: the abstract is no less concrete. We can abstract over expressions using functions, and we can even abstract over syntactic things, using hygienic macros. The result of such abstraction is a perfectly well-defined element in our universe of expressions.</p>

<p>In computer science, then, the pejorative sense of the word &ldquo;abstract&rdquo; is misleading, and the use of the terms &ldquo;abstract&rdquo; and &ldquo;abstraction&rdquo; merely provides ammunition for those who wish that we could all still be writing assembly language.</p>

<p>I suggest instead the use of the word &ldquo;general.&rdquo;</p>

<p>John &ldquo;purveyor of barbarous neologisms&rdquo; Clements</p></div>
  <a class="more" href='/2007/09/dont-say-abstract-instead-say-general.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>09 Sep 2007</p></col-1>

<col-2>
  <h1><a href='/2007/09/completions-in-drscheme-finally.html'>Completions in DrScheme (finally)</a></h1>
  <div class="truncate">
<p><em>posted by Robby Findler</em></p>

<p>DrScheme now supports a language- sensitive (but not lexical- scope sensitive) completion feature. Type -/ and see what names are available to finish off the word you&rsquo;re typing.</p>

<p>Thanks to <a href="http://www.cs.uchicago.edu/~jacobm/">Jacob</a> (and do follow that link; we all need a little more love in our lives) and <a href="http://turingcompletewasteoftime.blogspot.com/">Mike</a> for taking the initiative to actually implement what is probably the most requested feature in DrScheme at the moment.</p></div>
  <a class="more" href='/2007/09/completions-in-drscheme-finally.html'>more →</a>
<col-2>

</row>

</article>
<footer>
 <ul class="pagination">
  <li><a href="/index-12.html">
    <quote>&larr;</quote></a></li>
  <li><a href="/index.html">1</a></li>
  <li><a href="/index-2.html">2</a></li>
  <li><a href="/index-3.html">3</a></li>
  <li><a href="/index-4.html">4</a></li>
  <li><a href="/index-5.html">5</a></li>
  <li><a href="/index-6.html">6</a></li>
  <li><a href="/index-7.html">7</a></li>
  <li><a href="/index-8.html">8</a></li>
  <li><a href="/index-9.html">9</a></li>
  <li><a href="/index-10.html">10</a></li>
  <li><a href="/index-11.html">11</a></li>
  <li><a href="/index-12.html">12</a></li>
  <li class="active"><a href="/index-13.html">13</a></li>
  <li><a href="/index-14.html">14</a></li>
  <li><a href="/index-15.html">15</a></li>
  <li><a href="/index-14.html">
    <quote>&rarr;</quote></a></li></ul></footer>

<row class="one-column" id="bottom"><col-1></col-1><col-2>
<p>Made with <a href="https://github.com/greghendershott/frog">Frog</a>, a static-blog generator written in Racket.
<br /><a href="https://github.com/racket/racket-lang-org">Source code</a> for this blog.</col-2></row>
  </body>
</html>