<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <title>Racket Blog (page 3)</title>
    <meta name="description" content="Racket Blog (page 3)">
    <meta name="author"      content="The Unknown Author">
    <meta name="keywords"    content="Chez Scheme, all">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon"      href="/favicon.ico">
    <link rel="canonical" href="http://blog.racket-lang.org/index-3.html">


    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="stylesheet" type="text/css" href="/css/blog-fonts.css">
    <!-- Feeds -->
    <link rel="alternate" type="application/atom+xml" href="/feeds/all.atom.xml" title="Atom Feed">
    <link rel="alternate" type="application/rss+xml" href="/feeds/all.rss.xml" title="RSS Feed">
    <!-- JS -->
    </head>
  <body>
<row class="one-column" id="logo"><col-1><a href="http://racket-lang.org"><div id="logo-container"><img id="logo" src="/img/racket-logo.svg"/> Racket</div></a></col-1><col-2><p><a href="/index.html">blog</a></p></col-2></row>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>23 Nov 2015</p></col-1>

<col-2>
  <h1><a href='/2015/11/racket-v63.html'>Racket v6.3</a></h1>
  <div class="truncate">
<p><em>posted by Ryan Culpepper</em></p>

<p>Racket version 6.3 is now available from <a href="http://racket-lang.org/">http://racket-lang.org/</a></p>

<ul>
 <li>
  <p>Racket&rsquo;s macro expander uses a new representation of binding called &ldquo;set of scopes&rdquo;. The new binding model provides a simpler explanation of how macros preserve binding, especially across module boundaries and in hygiene-bending expansions. The new expander is mostly compatible with existing Racket macros, but there are some incompatibilities. For the formally inclined, a research paper on this macro system will appear at POPL next year: <a href="http://www.cs.utah.edu/plt/scope-sets/">http://www.cs.utah.edu/plt/scope-sets/</a></p></li>
 <li>
  <p>Racket&rsquo;s GUI library now uses Gtk+ 3 when available, instead of Gtk+ 2. Set the <code>PLT_GTK2</code> environment variable to select Gtk+ 2.</p></li>
 <li>
  <p>Added a new Redex tutorial based on a week-long workshop in SLC.</p></li>
 <li>
  <p>Better syntax error checking for Redex patterns that do not use holes correctly.</p></li>
 <li>
  <p>The blueboxes are more agressive about finding names to look up in the docs, meaning they are useful much more often.</p></li>
 <li>
  <p>Submodules are now fully supported in Typed Racket. Previously, some uses of submodules would produce internal errors, making it hard to <code>module+ test</code> and <code>module+ main</code> effectively in Typed Racket. The switch to the set-of-scopes expander fixed these problems, and submodules are now happily at home in Typed Racket.</p></li>
 <li>
  <p>The <code>typed/racket/unsafe</code> library provides import and export forms that circumvent contract generation. This improves performance for typed-untyped interaction at the cost of safety and debuggability.</p></li>
 <li>
  <p>Typed Racket provides experimental support for units (from <code>racket/unit</code>).</p></li>
 <li>
  <p>The experimental <code>define-new-subtype</code> form allows overlaying finer distinctions between otherwise identical types, similar to Haskell&rsquo;s <code>new type</code>.</p></li>
 <li>
  <p>The <code>Promise</code> type constructor changes in a backwards-incompatible way to exclude promises created with <code>promise/name</code>.</p></li>
 <li>
  <p>The <code>unstable-*</code> packages are out of the main distribution. Most of their contents have been either merged with established Racket libraries or spun off as their own packages. This change is backwards compatible for packages that properly list their dependencies. <a href="../../2015/10/retiring-unstable.html">Full details</a></p></li>
 <li>
  <p>edu: <code>big-bang</code> supports a display-mode clause so that world programs can take over the entire screen.</p></li></ul>

<p>Feedback welcome</p></div>
  <a class="more" href='/2015/11/racket-v63.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>30 Oct 2015</p></col-1>

<col-2>
  <h1><a href='/2015/10/retiring-unstable.html'>Retiring <code>unstable</code></a></h1>
  <div class="truncate">
<p><em>posted by Vincent St-Amour</em></p>

<p>Some of you may be familiar with the <code>unstable</code> collection, whose purpose was to serve as a staging ground for new APIs that hadn&rsquo;t yet found a more permanent home. With the advent of the package system, packages can serve that same purpose, which removes the need for a dedicated <code>unstable</code> collection provided by the main distribution.</p>

<p>For this reason we are moving <code>unstable-*</code> packages out of the main distribution.</p>

<p>For backwards compatibility, the packages remain available from the package catalog. Packages that properly list their dependencies (as they should! it&rsquo;s an error not to!) are unaffected by this change. Packages that are missing dependencies may need to be adjusted to include the appropriate <code>unstable</code> dependencies.</p>

<p>The <code>unstable</code> packages contained many useful functions and APIs, and we merged many of them into established Racket libraries. Others were spun off as their own packages. The remaining APIs, which we judged too narrow or too immature, we left in <code>unstable</code> packages, where they are still available in their original form. In all cases, the original <code>unstable</code> libraries continue to export the same bindings they always did, to ensure backwards compatibility.</p>

<p>For completeness, here is a list of the fate of each unstable library that used to be part of the main distribution.</p>

<ul>
 <li><code>unstable/2d</code>
  <ul>
   <li>Moved to the <code>2d</code> package.</li></ul></li>
 <li><code>unstable/arrow</code>
  <ul>
   <li>Left in <code>unstable-lib</code>.</li></ul></li>
 <li><code>unstable/automata</code>
  <ul>
   <li>Moved to the <code>automata</code> package.</li></ul></li>
 <li><code>unstable/bytes</code>
  <ul>
   <li>Left in <code>unstable-lib</code>.</li></ul></li>
 <li><code>unstable/class-iop</code>
  <ul>
   <li>Moved to the <code>class-iop</code> package.</li></ul></li>
 <li><code>unstable/contract</code>
  <ul>
   <li>
    <p>Moved <code>non-empty-string?</code> to <code>racket/string</code>.</p></li>
   <li>
    <p>Moved <code>port-number?</code> and <code>tcp-listen-port?</code> to <code>racket/tcp</code>, the latter renamed to <code>listen-port-number?</code>.</p></li>
   <li>
    <p>Moved <code>if/c</code>, <code>failure-result/c</code>, <code>predicate/c</code> and <code>rename-contract</code> to <code>racket/contract</code>.</p></li>
   <li>
    <p>Moved <code>treeof</code> to <code>plot/utils</code>.</p></li>
   <li>
    <p>Moved <code>sequence/c</code> to <code>racket/sequence</code>.</p></li>
   <li>
    <p>Left <code>path-piece?</code>, <code>maybe/c</code>, <code>truth/c</code> in <code>unstable-contract-lib</code>.</p></li></ul></li>
 <li><code>unstable/custom-write</code>
  <ul>
   <li>
    <p>Moved <code>make-constructor-style-printer</code> to <code>racket/struct</code>.</p></li>
   <li>
    <p>Left <code>prop:auto-custom-write</code> in <code>unstable-lib</code>.</p></li></ul></li>
 <li><code>unstable/debug</code>
  <ul>
   <li>Left in <code>unstable-debug-lib</code>.</li></ul></li>
 <li><code>unstable/define</code>
  <ul>
   <li>Left in <code>unstable-lib</code>.</li></ul></li>
 <li><code>unstable/error</code>
  <ul>
   <li>Left in <code>unstable-lib</code>.</li></ul></li>
 <li><code>unstable/find</code>
  <ul>
   <li>Left in <code>unstable-lib</code>.</li></ul></li>
 <li><code>unstable/flonum</code>
  <ul>
   <li>Superseded by <code>math/flonum</code>. Left in <code>unstable-flonum-lib</code>.</li></ul></li>
 <li><code>unstable/function</code>
  <ul>
   <li>Merged with <code>racket/function</code>.</li></ul></li>
 <li><code>unstable/future</code>
  <ul>
   <li>Merged with <code>racket/future</code>.</li></ul></li>
 <li><code>unstable/gui/notify</code>
  <ul>
   <li>Moved to <code>framework/notify</code>, with naming changes.</li></ul></li>
 <li><code>unstable/gui/pict</code>
  <ul>
   <li>
    <p>Moved <code>color/c</code>, <code>light</code>, <code>dark</code>, <code>red</code>, <code>orange</code>, <code>yellow</code>, <code>green</code>, <code>blue</code>, <code>purple</code>, <code>black</code>, <code>brown</code>, <code>gray</code>, <code>white</code>, <code>cyan</code>, and <code>magenta</code> to <code>pict/color</code>.</p></li>
   <li>
    <p>Moved <code>show</code>, <code>hide</code>, <code>pict-if</code>, <code>pict-cond</code>, and <code>pict-case</code> to <code>pict/conditional</code>.</p></li>
   <li>
    <p>Merged <code>scale-to</code> with <code>pict</code>&rsquo;s <code>scale-to-fit</code>.</p></li>
   <li>
    <p>Merged <code>ellipse/border</code>, <code>circle/border</code>, <code>rectangle/border</code>, <code>rounded-rectangle/border</code> with <code>pict</code>&rsquo;s <code>ellipse</code>, <code>circle</code>, <code>rectangle</code>, and <code>rounded-rectangle</code>, respectively.</p></li>
   <li>
    <p>Merged <code>pin-label-line</code>, <code>pin-arrow-label-line</code>, and <code>pin-arrows-label-line</code> with <code>pict</code>&rsquo;s <code>pin-line</code>, <code>pin-arrow-line</code>, and <code>pin-arrows-line</code>, respectively.</p></li>
   <li>
    <p>Moved <code>blur</code>, <code>shadow</code>, and <code>shadow-frame</code> to <code>pict/shadow</code>.</p></li>
   <li>
    <p>Moved <code>unstable/gui/pict/align</code> to <code>ppict/align</code>, in the <code>ppict</code> package.</p></li>
   <li>
    <p>Left <code>color</code>, <code>pict-match</code>, <code>pict-combine</code>, <code>with-pict-combine</code>, <code>fill</code>, <code>strike</code>, <code>shade</code>, <code>blur-bitmap!</code>, <code>arch</code>, <code>draw-pict-centered</code>, <code>backdrop</code>, <code>cross-out</code>, and <code>make-plt-title-background</code> in <code>unstable-lib</code>.</p></li></ul></li>
 <li><code>unstable/gui/ppict</code>
  <ul>
   <li>Moved to the <code>ppict</code> package.</li></ul></li>
 <li><code>unstable/gui/prefs</code>
  <ul>
   <li>Moved to <code>framework/preferences</code>, with naming changes.</li></ul></li>
 <li><code>unstable/gui/redex</code>
  <ul>
   <li>Left in <code>unstable-redex</code>.</li></ul></li>
 <li><code>unstable/gui/scribble</code>
  <ul>
   <li>Left in <code>unstable-lib</code>.</li></ul></li>
 <li><code>unstable/gui/slideshow</code>
  <ul>
   <li>
    <p>Moved <code>with-size</code>, <code>with-scale</code>, <code>big</code>, <code>small</code>, <code>with-font</code>, <code>with-style</code>, <code>bold</code>, <code>italic</code>, <code>subscript</code>, <code>superscript</code>, <code>caps</code>, and <code>blank-line</code> to <code>slideshow/text</code>.</p></li>
   <li>
    <p>Moved <code>slide/staged</code>, <code>staged</code>, <code>stage</code>, <code>stage-name</code>, <code>at</code>, <code>before</code>, <code>after</code>, <code>before/at</code>, <code>after/at</code> to the <code>staged-slide</code> package.</p></li>
   <li>
    <p>Left <code>column</code>, <code>columns</code>, <code>column-size</code>, <code>two-columns</code>, <code>mini-slide</code>, <code>tabular</code>, <code>reveal</code>, <code>revealing-slide</code>, and <code>items-slide</code> in <code>unstable-lib</code>.</p></li></ul></li>
 <li><code>unstable/gui/snip</code>
  <ul>
   <li>Left in <code>unstable-lib</code>.</li></ul></li>
 <li><code>unstable/hash</code>
  <ul>
   <li>Merged with <code>racket/hash</code>.</li></ul></li>
 <li><code>unstable/latent-contract</code>
  <ul>
   <li>Left in <code>unstable-latent-contract-lib</code>.</li></ul></li>
 <li><code>unstable/lazy-require</code>
  <ul>
   <li>
    <p><code>lazy-require</code> has been in <code>racket/lazy-require</code> for some time.</p></li>
   <li>
    <p>Left <code>begin-on-demand</code> in <code>unstable-lib</code>.</p></li></ul></li>
 <li><code>unstable/list</code>
  <ul>
   <li>
    <p>Moved <code>check-duplicates</code>, <code>remf</code>, <code>remf*</code>, <code>group-by</code>, <code>cartesian-product</code>, <code>list-update</code>, and <code>list-set</code> to <code>racket/list</code>. * Moved <code>list-prefix?</code>, <code>take-common-prefix</code>, <code>drop-common-prefix</code>, and <code>split-common-prefix</code> to <code>racket/list</code>, with slight API changes to harmonize with Racket&rsquo;s list API.</p></li>
   <li>
    <p>Left <code>filter-multiple</code>, <code>extend</code>, <code>map/values</code>, and <code>map2</code> in <code>unstable-list-lib</code>.</p></li></ul></li>
 <li><code>unstable/logging</code>
  <ul>
   <li>
    <p>Moved <code>with-intercepted-logging</code> and <code>with-logging-to-port</code> to <code>racket/logging</code>.</p></li>
   <li>
    <p>Left <code>start-recording</code> and <code>stop-recording</code> in <code>unstable-lib</code>.</p></li></ul></li>
 <li><code>unstable/macro-testing</code>
  <ul>
   <li>Moved to <code>syntax/macro-testing</code>.</li></ul></li>
 <li><code>unstable/markparam</code>
  <ul>
   <li>Moved to the <code>markparam</code> package.</li></ul></li>
 <li><code>unstable/open-place</code>
  <ul>
   <li>Moved <code>open-place</code> to <code>racket/place</code>, and renamed it <code>place/context</code>.</li></ul></li>
 <li><code>unstable/options</code>
  <ul>
   <li>Moved to the <code>option-contract</code> package.</li></ul></li>
 <li><code>unstable/parameter-group</code>
  <ul>
   <li>Moved to the <code>parameter-group</code> package.</li></ul></li>
 <li><code>unstable/pretty</code>
  <ul>
   <li>
    <p>Merged <code>pretty-format/write</code>, <code>pretty-format/display</code>, and <code>pretty-format/print</code> with <code>racket/pretty</code>&rsquo;s <code>pretty-format</code>.</p></li>
   <li>
    <p>Left <code>break-lines</code> in <code>unstable-pretty-lib</code>.</p></li></ul></li>
 <li><code>unstable/recontract</code>
  <ul>
   <li>Merged with <code>racket/contract</code> some time ago.</li></ul></li>
 <li><code>unstable/sandbox</code>
  <ul>
   <li>Merged with <code>scribble/eval</code>.</li></ul></li>
 <li><code>unstable/sequence</code>
  <ul>
   <li>
    <p>Moved <code>in-syntax</code> and <code>in-slice</code> to <code>racket/sequence</code>.</p></li>
   <li>
    <p>Left <code>in-pairs</code>, <code>in-sequence-forever</code>, and <code>sequence-lift</code> in <code>unstable-lib</code>.</p></li></ul></li>
 <li><code>unstable/socket</code>
  <ul>
   <li>Moved to the <code>unix-socket</code> package.</li></ul></li>
 <li><code>unstable/string</code>
  <ul>
   <li>Left in <code>unstable-lib</code>.</li></ul></li>
 <li><code>unstable/struct</code>
  <ul>
   <li>
    <p>Moved <code>struct-&gt;list</code> to <code>racket/struct</code>.</p></li>
   <li>
    <p>Left <code>make</code> in <code>unstable-lib</code>.</p></li></ul></li>
 <li><code>unstable/syntax</code>
  <ul>
   <li>
    <p>Moved <code>make-variable-like-transformer</code> to <code>syntax/transformer</code>.</p></li>
   <li>
    <p>Moved <code>syntax-source-directory</code> and <code>syntax-source-file-name</code> to <code>syntax/location</code>.</p></li>
   <li>
    <p>Left <code>explode-module-path-index</code>, <code>phase-of-enclosing-module</code>, <code>format-unique-id</code>, <code>syntax-length</code>, and <code>syntax-within?</code> in <code>unstable/syntax</code>.</p></li></ul></li>
 <li><code>unstable/temp-c</code>
  <ul>
   <li>Moved to the <code>temp-c</code> package.</li></ul></li>
 <li><code>unstable/time</code>
  <ul>
   <li>Left in <code>unstable-lib</code>.</li></ul></li>
 <li><code>unstable/wrapc</code>
  <ul>
   <li>Moved to <code>syntax/contract</code>.</li></ul></li></ul></div>
  <a class="more" href='/2015/10/retiring-unstable.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>22 Sep 2015</p></col-1>

<col-2>
  <h1><a href='/2015/09/racket-package-server-security-vulnerabilities.html'>Racket Package Server Security Vulnerabilities</a></h1>
  <div class="truncate">
<p><em>posted by Sam Tobin-Hochstadt</em></p>

<p>Recently, we discovered several security vulnerabilities with how both the Racket package catalog server and the Racket package client work. The vulnerabilities have now all been fixed, and we do not know of any exploitation of them. However, we encourage you to take the following steps:</p>

<ul>
 <li>
  <p>Change your password on the <a href="http://pkgs.racket-lang.org">http://pkgs.racket-lang.org</a> site.</p></li>
 <li>
  <p>Check any packages you have uploaded to the site, to ensure that no unexpected changes have been made to them.</p></li>
 <li>
  <p>Do not use the released versions of the raco pkg catalog-archive command, or the <code>file/untar</code> and <code>file/unzip</code> libraries, on untrusted inputs. If you use these tools or libraries, use a snapshot build available from <a href="http://pre.racket-lang.org/">http://pre.racket-lang.org/</a>.</p></li></ul>

<h2 id="the-errors-and-how-they-were-fixed">The errors, and how they were fixed</h2>

<p>A total of 5 errors related to package handling were reported to us by Tony Garnock-Jones and Asumu Takikawa. Two were XSS vulnerabilities relating to handling user input in the package administration dialog. One was an error where unsanitized email addresses with path name components in them could allow a malicious user to impersonate someone else, whom they shared an email suffix with (such addresses are illegal on most mail servers, like Outlook and GMail, but not illegal in SMTP itself.) Two were errors in handling MANIFEST files and tar/zip archives, which allowed decompression to write to arbitrary locations on the file system. These last errors affected not only the server, which decompresses packages to analyze them, but also clients using the commands described above.</p>

<p>The relevant server-side code was fixed to appropriately sanitize user input. The package handling libraries now reject any attempts to navigate up the filesystem hierarchy, meaning that these attacks are no longer possible.</p>

<p>Unfortunately, due to the nature of these attacks, we cannot be sure that they were not exploited, but we have no evidence that they were. Therefore, we encourage anyone with an account to change their password, and to treat the password as compromised. Please also check your existing packages to make sure they are as you left them.</p>

<p>Furthermore, using the <code>file/untar</code> and <code>file/unzip</code> libraries, the raco pkg catalog-archive command, and the internal functions that manipulate packages is not safe on untrusted inputs in released versions of Racket. Since raco pkg install executes code, it is already unsafe to use on untrusted packages, but simply extracting malicious packages is also unsafe.</p>

<p>We have not released a new version of Racket, but encourage anyone who needs to perform these commands to use a snapshot build. The next version of Racket will be released on-schedule in October. If, however, you would benefit from a patched version of Racket 6.2.1, please let us know.</p></div>
  <a class="more" href='/2015/09/racket-package-server-security-vulnerabilities.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>11 Aug 2015</p></col-1>

<col-2>
  <h1><a href='/2015/08/modules-packages-and-collections.html'>Modules, Packages and Collections</a></h1>
  <div class="truncate">
<p><em>posted by Vincent St-Amour</em></p>

<p>Racket, the Racket docs and Racketeers use a number of terms to refer to various units of Racket code. Of those, module, package and collection refer to related but distinct concepts. Their exact relations and distinctions can be confusing for new users. This is an attempt at explaining those concepts, what they are for, and how they relate to each other.</p>

<p>To begin with the smallest of the three, a file that begins with #lang and the name of a language is a module. There are also other ways to construct modules, but let&rsquo;s not worry about those.</p>

<p>A module is the basic unit of functionality for Racket code.</p>

<p>Once your Racket programs get larger, though, you&rsquo;ll want to split them over multiple modules. This allows you to organize your source better, enables separate compilation, and makes it possible for you to mix and match modules written in different Racket languages (<a href="http://docs.racket-lang.org/guide/index.html">Racket</a>, <a href="http://docs.racket-lang.org/ts-guide/index.html">Typed Racket</a>, <a href="http://docs.racket-lang.org/datalog/index.html">Datalog</a>, <a href="http://docs.racket-lang.org/scribble/index.html">Scribble</a>, etc.).</p>

<p>That&rsquo;s where packages and collections come in. They help you organize your modules.</p>

<p>A package is an group of modules that you can install together, and that usually provide one piece of functionality. To pick a random example, take the <a href="http://pkg-build.racket-lang.org/doc/pict3d/index.html">pict3d</a> package from <a href="http://pkgs.racket-lang.org/">pkgs.racket-lang.org</a>. That package is a collection of modules which together implement a functional 3D engine. You can install it using raco pkg install pict3d, or via the graphical package manager in DrRacket.</p>

<p>So, to sum up, packages are units of code distribution.</p>

<p>A collection is a group of modules whose functionality is related to the same topic, for example data structures (the data collection), or wrapper libraries for use with Typed Racket (the typed collection). Modules are referred to and required using collection paths. For example, when you require racket/class, you&rsquo;re requiring the class module from the racket collection.</p>

<p>Modules within a collection do not necessarily come from the same package, and may not be developed together. For example, some data structures in the data collection are provided as part of the core of Racket, such as the integer sets in <a href="http://docs.racket-lang.org/data/integer-set.html"><code>data/integer-set</code></a>. Other data structures are provided by additional packages which you may need to install separately, such as the hash-array-mapped tries in <code>data/hamt</code>, which are provided by the <a href="http://pkg-build.racket-lang.org/doc/hamt/index.html"><code>hamt</code></a> package. Having both of those in the data collection signals that they both provide data structures. If you develop your own data structures, putting them in the data collection is probably the right thing to do.</p>

<p>Many packages, however, provide functionality that does not fall under existing categories, and provide their own, new collection. For example, the <code>pict3d</code> package we discussed above puts its modules in the <code>pict3d</code> collection. For that reason, the distinction between package and collection is sometimes a bit blurred.</p>

<p>So, to sum up, collections are units of code classification.</p>

<p>The term library does not have a technical meaning in Racket. We usually use it to refer to a package, or to a set of packages that are developed together. For example, the <a href="http://docs.racket-lang.org/rackunit/index.html">Rackunit</a> library is split across multiple packages: <code>rackunit</code>, <code>rackunit-lib</code>, <code>rackunit-gui</code>, <code>rackunit-plugin-lib</code>, <code>rackunit-doc</code> and <code>rackunit-test</code>. This allows packages to only depend on part of Rackunit. For example, a package for a string-processing library probably should not depend on the <a href="http://docs.racket-lang.org/gui/index.html">Racket GUI library</a> (to be deployed on headless servers, for example), and so should depend on the <code>rackunit-lib</code> package for its testing, instead of on the full <code>rackunit</code> package, which brings in GUI support via the <code>rackunit-gui</code> package, and would introduce a dependency to Racket&rsquo;s GUI library.</p>

<p>Hopefully, this clarifies the Racket code organization terminology a bit.</p></div>
  <a class="more" href='/2015/08/modules-packages-and-collections.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>10 Aug 2015</p></col-1>

<col-2>
  <h1><a href='/2015/08/racket-v621.html'>Racket v6.2.1</a></h1>
  <div class="truncate">
<p><em>posted by Ryan Culpepper</em></p>

<p>Racket v6.2.1 is now available from <a href="http://racket-lang.org/">http://racket-lang.org/</a></p>

<p>Version 6.2.1 patches the recent v6.2 release in three small ways:</p>

<ul>
 <li>
  <p>For the How to Design Programs teaching languages, DrRacket offers an option to use the old style for printing the constants <code>true</code>, <code>false</code>, and <code>empty</code> instead of <code>#true</code>, <code>#false</code>, and <code>'()</code>.</p></li>
 <li>
  <p>The teaching languages come with some additional functions to match the August 2015 <a href="http://www.ccs.neu.edu/home/matthias/HtDP2e/index.html">stable release of HtDP 2nd edition</a>.</p></li>
 <li>
  <p>A repair to the compiler avoids an infinite loop at compile time for certain expressions that should loop forever at run time.</p></li></ul>

<p>Feedback Welcome</p></div>
  <a class="more" href='/2015/08/racket-v621.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>19 Jun 2015</p></col-1>

<col-2>
  <h1><a href='/2015/06/racket-v62.html'>Racket v6.2</a></h1>
  <div class="truncate">
<p><em>posted by Ryan Culpepper</em></p>

<p>Racket version 6.2 is now available from <a href="http://racket-lang.org/">http://racket-lang.org/</a></p>

<p>With this release we are taking a major step forward to get our user community even more involved than in the past. Over the past six months, we have re-organized the Racket code base into a small core code repo and many other package repos, all found on GitHub. If you have time and if you wish to get involved, please take a look at the GitHub repos and find your favorite places to learn, fix, and enhance our world.</p>

<p>The core repo is at <a href="https://github.com/plt/racket">https://github.com/plt/racket</a>, and the package repos are listed at <a href="https://github.com/racket/">https://github.com/racket/</a>.</p>

<p><a href="https://github.com/plt/racket">core repo</a></p>

<ul>
 <li>
  <p>The package manager supports a direct references to Git repositories via &ldquo;git://[&hellip;]&rdquo;, &ldquo;http://[&hellip;].git&rdquo;, and &ldquo;https://[&hellip;].git&rdquo; URLs. (Previously, only references to GitHub were supported.)</p></li>
 <li>
  <p>A <code>--clone</code> option for <code>raco pkg install</code> or <code>raco pkg update</code> facilitates Git-based package development. If a package X has a Git repository source, installing and updating the package pulls from the repository in a read-only mode. Using <code>raco pkg update --clone X</code> switches the local installation to a repository checkout that is suitable for modifying the package implementation, issuing pull requests, pushing changes, and so on.</p></li></ul>

<p>Using <code>raco pkg update --lookup X</code> switches the package back to the default installation mode.</p>

<p><a href="https://github.com/racket/drracket">drracket</a></p>

<ul>
 <li>
  <p>Its on-line check syntax works with graphical content.</p></li>
 <li>
  <p>Increased availability of DrRacket&rsquo;s blueboxes, including method and constructor information.</p></li>
 <li>
  <p>The &ldquo;Open Require Path&rdquo; menu item supports ".." in relative pathnames.</p></li></ul>

<p><a href="https://github.com/racket/data">data</a></p>

<ul>
 <li>Added <code>data/enumerate</code>, a library that supports efficient enumeration of data structures</li></ul>

<p><a href="https://github.com/racket/redex">redex</a></p>

<ul>
 <li>
  <p>Its <code>redex-check</code> facility uses data (in addition to random) enumeration to try to find counter-examples.</p></li>
 <li>
  <p>Its <code>generate-term</code> function accepts additional arguments to return the &ldquo;i&rdquo;-th member of a pattern using <code>data/enumerate</code> (meaning it efficiently supports very large values of &ldquo;i&rdquo;).</p></li>
 <li>
  <p>The examples collection includes Launchbury&rsquo;s 1993 big-step lazy semantics.</p></li></ul>

<p><a href="https://github.com/racket/htdp">htdp</a></p>

<ul>
 <li>
  <p><code>2htdp/image</code>&rsquo;s polygon may be built out of bezier curves instead of just straight lines (see the docs for <code>pulled-point</code>).</p></li>
 <li>
  <p><code>2htdp/abstraction</code> is a teachpack for instructors and students who wish to use <code>for/*</code> loops, <code>match</code>, <code>define-type</code> and <code>type-cases</code> in ISL and ISL+.</p></li>
 <li>
  <p><code>2htdp/universe</code> programs can be exported using DrRacket&rsquo;s executable creation mechanism and they behave properly when run independently.</p></li></ul>

<p><a href="https://github.com/racket/typed-racket">typed-racket</a></p>

<ul>
 <li>
  <p>Typed Racket in DrRacket displays tooltips that show the types of expressions. Tooltips are also displayed for type errors.</p></li>
 <li>
  <p>Typed Racket loads generated contracts only when needed. This reduces memory use and startup time for Typed Racket programs.</p></li>
 <li>
  <p>Typed Racket has improved support for prefab structures, future semaphores, and async channels.</p></li>
 <li>
  <p>Typed Racket understands when two different variables refer to the same thing, and updates types accordingly. This particularly improves the type checking of macros such as <code>match</code>.</p></li></ul>

<p>Feedback Welcome</p></div>
  <a class="more" href='/2015/06/racket-v62.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>03 May 2015</p></col-1>

<col-2>
  <h1><a href='/2015/05/king-of-the-hill-on-rosetta-code.html'>King of the Hill on Rosetta Code</a></h1>
  <div class="truncate">
<p><em>posted by Tim Brown</em></p>

<p>Racket is <em>&ldquo;King of the Hill&rdquo;</em> on Rosetta Code: <strong>This announcement is a follow up to &ldquo;800!&rdquo;.</strong></p>

<p>In it I said we&rsquo;d <em>"[S]ee you at 1000!"</em>; but you&rsquo;ll understand why we stopped at this milestone.</p>

<p>Please read that article if you need an introduction to Rosetta Code, and the efforts being made to implement Racket tasks there, and more detail on how you can help. It is more instructive and less braggart than this post.</p>

<p>On Rosetta Code (RC), early in the morning on April 29th, Racket drew level with Tcl in the number of tasks that had been implemented for it. Shortly after that we could announce that:</p>

<p><strong>Racket has the Most Tasks Implemented in Any Language on Rosetta Code!</strong></p>

<p>Before I go into too much detail, it must be said that this is another amazing achievement. I, and I&rsquo;m sure the rest of the Racket community, want to thank and congratulate everyone who has contributed to this effort.</p>

<h2 id="how-did-this-happen">How Did This Happen?</h2>

<p> On the front page of RC&rsquo;s site, it states its goal as:</p>

<blockquote>
 <p>&hellip; to present solutions to the same task in as many different languages as possible, to demonstrate how languages are similar and different, and to aid a person with a grounding in one approach to a problem in learning another.</p></blockquote>

<p> As well as achieving these comparative goals, implementing tasks also provides a useful library of tools, applications and examples for Racket users themselves. Therefore, doing so is a laudable activity in its own right. The persistent effort and progress have been made by Racketeers on RC, both before and since the &ldquo;800!&rdquo; tasks post has been (mostly) performed in that spirit. And that should be plenty enough incentive for <em>you</em> to do so, too.</p>

<p> But I admit, there is a competitive element that creeps in (affecting some more than others). After having passed the 800 task mark after spending so much time in second place to get past the current leader, Tcl to stay <a href="Python,">ahead of Python</a> these, too, provide plenty of motivation to implement tasks. And if winning isn&rsquo;t important, why, then, do we keep score?</p>

<p> And in <em>that</em> spirit, early in the morning on April 29th, I was busily [cherry-picking] [2] tasks on Rosetta Code to help close the gap with Tcl; when I thought I would take a quick check on Tcl&rsquo;s and Racket&rsquo;s [task counts][3]. From what I could see, both had a task count of 845! Racket had drawn level with, Tcl as the <em>Joint Most Popular Programming Language</em> on RC.</p>

<p> I got the independent verification of this from the #racket [IRC Channel][4]. It was true! But Racket was <em>only joint first.</em> This point was not lost on the denizens of IRC (<code>zedoary</code> being one); who posted two more tasks in very quick succession, bringing Racket up to 847 &mdash; two clear of the previous leader!</p>

<p> How does this Help Racket?  &mdash;</p>

<p> <strong>Plenty of Examples</strong>  Look back at the intentions of Rosetta Code itself. It is expected that users of other languages can come and compare what they know with what Racket provides. Strictly speaking, of course, in a lot of cases they won&rsquo;t be able to compare since the other language won&rsquo;t be represented whereas Racket will.</p>

<p> There is also, now, a large collection of Racket examples, which Racketeers themselves can use to improve their understanding of Racket. Strangely, this is not actually one of the stated objectives of RC; it is a welcome side-effect of the work.</p>

<p> <strong>A Tool for Advocacy</strong>  Advocates of Racket can use this position on Rosetta Code to show that Racket is as, if not more, capable than any language. Especially for general purpose computing.</p>

<p> &ldquo;Racket is Number One on Rosetta Code&rdquo; isn&rsquo;t a bad place to start with, I guess.</p>

<p> Additionally, I would like to point out that whatever any of the other languages (or tasks) seem to throw at it, there is something in Racket that allows it to take it in its stride. Sometimes the implementations have had high [line counts][5]; but they rarely, if ever, seem contrived.</p>

<p> If you need to provide reasons for tasks not being implemented in Racket, here are a few you can use:</p>

<ul>
 <li>
  <p><em>Nobody has implemented them &ldquo;yet&rdquo;:</em> let it be known that we&rsquo;ve done the best part of 850 tasks, and there are only so many hours in the day.</p></li>
 <li>
  <p><em>Someone has written an FFI for Tcl to an obscure library:</em> The task for Tcl has then simply been to load the FFI. The task for Racket is either to a) implement the library, which is much more effort than Tcl put in or b) to produce FFI bindings itself, which after the first time doesn&rsquo;t bring much to the party. The same holds true for tasks written <em>for</em> languages which are basically DSLs, showing off how they work in domain for which they are specific.</p></li>
 <li>
  <p><em>The task is written and documented entirely in Russian:</em> This makes translating it an &ldquo;exercise.&rdquo;</p></li></ul>

<h2 id="is-it-time-to-rest-on-our-laurels">Is it Time to Rest on our Laurels?</h2>

<p> That was a rhetorical question.</p>

<p>Please ignore it.</p>

<p>There are many reasons to continue to work on Rosetta Code.</p>

<h2 id="we-havent-finished">We Haven&rsquo;t Finished</h2>

<p><strong>Implement Some Outstanding Tasks!</strong></p>

<p>There are 922 tasks on Rosetta Code. 849 are implemented in Racket (more have been added as we speak)! Even excluding the impossible and Russian tasks, that&rsquo;s still many more tasks to implement.</p>

<p><strong>Improve Existing Tasks!</strong></p>

<p>Some tasks are old, and lack style. Some may even be re-branded Scheme tasks. Anyone can edit these tasks. Add style to them. Tasks can then not only be an example of how to use the syntax and features of Racket, but also exemplars of well-written code.</p>

<p><strong>Propose New Tasks!</strong></p>

<p>There are things that Racket and other Lisps do well that haven&rsquo;t been illustrated on RC. How about the fancier macro facilities that Racket provides?</p>

<p>I&rsquo;m sure you can think of something. Might you suggest something involving <em>anaphoric macros</em>?</p>

<p>Oh, and if you <em>do</em> suggest something, maybe you can implement it, too!</p>

<h2 id="they-havent-finished">They Haven&rsquo;t Finished</h2>

<p><strong>New Tasks are Being Invented!</strong></p>

<p>Tasks are being added to Rosetta Code constantly. Keep an eye out, some of these are really quite interesting.</p>

<p><strong>Tasks are Being Implemented!</strong></p>

<p> Tcl and Python (and maybe others in the future) will want what we have earned here, and they are going to continue to propose and implement tasks. <em>&ldquo;King of the Hill&rdquo;</em> is a precarious place. The more clear blue water between us and them Just do it! Buy glucose sports drinks</p>

<p> Maybe I <em>am</em> getting too competitive.</p>

<p> Finally  &mdash;</p>

<p> Once again, many thanks to the people who have contributed to Racket on Rosetta Code. Including those who have answered questions on the mailing list or IRC. Your help has been invaluable even if the questions made you wonder &ldquo;why on earth does he or she want to do <em>that?</em>&rdquo;</p>

<p> Finally, but certainly not least: Thanks to the folk at Rosetta Code. They&rsquo;ve provided a site and experience which have been instructive, educational and fun; and without whom none of this would have been possible.</p>

<p>is also doing magnificently well, to be sure. It even had the audacity to draw level with Racket according to the FUPPLR a couple of times.</p>

<p>[2] A good way to start on Rosetta Code is to find tasks that are <em>easy</em> to implement. In order to find <em>easy</em> tasks you will need to browse the unimplemented tasks (and maybe some implemented ones, too) and decide what you could either implement and/or translate without breaking too much of a sweat. In the process you will also develop a sense of what tasks are out there ready to be implemented. A good example of an <em>easy</em> task would have been <a href="http://www.rosettacode.org/wiki/Pentagram">Pentagram</a>.</p>

<p>[3] There is a <a href="http://timb.net/popular-languages.html">Frequently Updated Popular Programming Languages Report</a>, which I refer to but recently it has been miscounting tasks, and needs a bit of a look at.</p>

<p>[4] The <code>#racket</code> IRC channel is a fantastic community if you need support with your Racket issues</p>

<p>[5] Remember that Rosetta Code is not a <em>Golf</em> site. If it were, J&rsquo;s weird 20-character-strings-that-do-anything (if only you could remember what they do 30 seconds after you&rsquo;ve written them) would win hands down. Keep to the <a href="http://www.ccs.neu.edu/home/matthias/Style/style/">Style Guide</a> as best you can. And since RC is a wiki, if you&rsquo;re not perfect, others can improve the style of your code.</p></div>
  <a class="more" href='/2015/05/king-of-the-hill-on-rosetta-code.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>20 Apr 2015</p></col-1>

<col-2>
  <h1><a href='/2015/04/scheme-workshop-2015.html'>Scheme Workshop 2015</a></h1>
  <div class="truncate">
<p><em>posted by Ryan Culpepper</em></p>

<p>Call For Papers:</p>

<p>Scheme and Functional Programming Workshop 2015</p>

<p>Vancouver, British Columbia, Canada</p>

<p>(Co-located with ICFP 2015)</p>

<p><a href="http://andykeep.com/SchemeWorkshop2015/">http://andykeep.com/SchemeWorkshop2015/</a></p>

<p>Submissions related to Scheme, Racket, Clojure, and functional programming are welcome and encouraged. Topics of interest include but are not limited to:</p>

<ul>
 <li>
  <p>Program-development environments, debugging, testing</p></li>
 <li>
  <p>Implementation (interpreters, compilers, tools, benchmarks, etc.)</p></li>
 <li>
  <p>Syntax, macros, hygiene</p></li>
 <li>
  <p>Distributed computing, concurrency, parallelism</p></li>
 <li>
  <p>Interoperability with other languages, FFIs</p></li>
 <li>
  <p>Continuations, modules, object systems, types</p></li>
 <li>
  <p>Theory, formal semantics, correctness</p></li>
 <li>
  <p>History, evolution and standardization of Scheme</p></li>
 <li>
  <p>Applications, experience and industrial uses of Scheme</p></li>
 <li>
  <p>Education</p></li>
 <li>
  <p>Scheme pearls (elegant, instructive uses of Scheme)</p></li></ul>

<p>We also welcome submissions related to dynamic or multiparadigmatic languages and programming techniques.</p>

<p>Important Dates:</p>

<p>May 22nd, 2015 - Paper deadline</p>

<p>June 26th, 2015 - Author notification</p>

<p>July 19th, 2015 - Camera-ready deadline</p>

<p>September 4th, 2015 - Workshop</p>

<p>Submissions must be in ACM proceedings format, no smaller than 9-point type (10-point type preferred). Microsoft Word and LaTeX templates for this format are available at: <a href="http://www.acm.org/sigs/sigplan/authorInformation.htm">http://www.acm.org/sigs/sigplan/authorInformation.htm</a></p>

<p>Submissions should be in PDF and printable on US Letter.</p>

<p>To encourage authors to submit their best work, this year we are encouraging shorter papers (around 6 pages, excluding references). This is to allow authors to submit longer, revised versions of their papers to archival conferences or journals. Longer papers (10&mdash;12 pages) are also acceptable, if the extra space is needed. There is no maximum length limit on submissions, but good submissions will likely be in the range of 6 to 12 pages.</p>

<p>More information available at: <a href="http://andykeep.com/SchemeWorkshop2015/">http://andykeep.com/SchemeWorkshop2015/</a></p>

<p>Organizers:</p>

<p>Andy Keep, Cisco Systems Inc. (General Chair)</p>

<p>Ryan Culpepper, Northeastern University (Program Chair)</p>

<p>(Apologies for duplications from cross-posting.)</p></div>
  <a class="more" href='/2015/04/scheme-workshop-2015.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>10 Dec 2014</p></col-1>

<col-2>
  <h1><a href='/2014/12/the-racket-package-system-and-planet.html'>The Racket package system and PLaneT</a></h1>
  <div class="truncate">
<p><em>posted by Jay McCarthy</em></p>

<p>We have recently moved the majority of Racket&rsquo;s code base into packages and repositories separate from the main core repository. This has given the Racket package system another cycle of attention. Whenever this happens, there are often questions and confusion about how to solve various distribution problems with the package system. A natural point of comparison is the older PLaneT system provided by Racket that appears to solve similar problems. In this blog post, I attempt to explain the purpose of the package system and its relation to PLaneT.</p>

<p>The package system and PLaneT do not solve the same problem and don&rsquo;t exist for the same reason.</p>

<p>PLaneT is:</p>

<ul>
 <li>
  <p>A file distribution mechanism for source code.</p>
  <p>Via <code>.plt</code> files that are installed into a particular place on your machine and then <code>raco setup</code>&rsquo;d.</p></li>
 <li>
  <p>A mechanism for automatically downloading and installing source code just before it is needed by programs.</p>
  <p>Via the <code>(planet ...)</code> require form.</p></li>
 <li>
  <p>A centralized database of libraries</p>
  <p>Via the PLaneT website and its server &amp; protocol which were undocumented and proprietary for the majority of PLaneT&rsquo;s life</p></li>
 <li>
  <p>A prescriptive model of how programs and libraries should be composed.</p>
  <p>Specifically the system of major/minor versions, tagging packages by author name, and embedding the names of packages in source code.</p></li></ul>

<p>In contrast, the package system is:</p>

<ul>
 <li>A file distribution mechanism for source code, byte code, and documentation. Via the <code>raco pkg</code> command.</li></ul>

<p>In this way, the package system is almost identical to an operating system package system like Debian&rsquo;s dpkg and apt systems. The problem is very finely tailored and becomes more flexible as a result (notice that we can now distribute byte code and documentation.) This design aspires to follow the admonition of <a href="http://people.csail.mit.edu/jaffer/r3rs_2.html#SEC2">holy writ</a>: &ldquo;Programming languages should be designed not by piling feature on top of feature, but by removing the weaknesses and restrictions that make additional features appear necessary.&rdquo;</p>

<p>Furthermore, it was intended to solve practical problems throughout the Racket ecosystem. In particular, one of the common complaints people had and have about PLaneT is the very long install times because of long builds. The package system allows this problem to be solved by distributing pre-built code.</p>

<p>Since the package system specifically does not address jobs 2, 3, or 4 of PLaneT, we have to ask, &ldquo;Do they need to be solved?&rdquo; and if so, &ldquo;How can we solve them on top of the package system, i.e. as a library in honor of the design principle?&rdquo;.</p>

<p>In particular, 2 and 3 are very painful for people wanting to just use the file distribution mechanism of PLaneT. 2 causes unpredictability, because you don&rsquo;t know if running a program will start a long invocation of &ldquo;raco setup&rdquo;, require Internet access, and start running un-vetted code. 3 requires you to share your code if you want to use the file distribution mechanism and is a single point of failure for doing installation.</p>

<p>By not mandating how to address 2 and 3 in the package system, we offer flexibility. Here is where the solutions to these jobs are now:</p>

<ol>
 <li>
  <p>There is currently no way to get automatic installs of packages. However, both DrRacket and xrepl offer advice about which packages you might want to install to compile and run the program. It would be natural to extend this advice to be automatic and patches are welcome. Given the experiences of operating systems which merely make suggestions (<code>nethack: command not found, provided by nethack-console</code>), I personally feel like we are at the sweet spot.</p></li>
 <li>
  <p>The file distribution mechanism&rsquo;s flexible package sources combine with a very simple protocol for package catalogs (Take a URL, add<code>/pkg/</code>, add a string, get a <code>read</code>-able hash table) to look up packages you don&rsquo;t yet have. As a service, we run a few catalogs (one for each release, plus <a href="http://pkgs.racket-lang.org">pkgs.r-l.o</a>). But we expect that users with special needs (such as sensitive installations that need exactly certain tested and trusted versions, especially with proprietary software) will build their own catalogs on private Web sites.</p></li></ol>

<p>Clearly, however, job 4 is where PLaneT and the package system differ the most.</p>

<p>With the package system, we follow the precedent of operating systems. An OS package&rsquo;s job is to get files into the right spot. An OS package contains a binary and instructions to install it as <code>/usr/bin/zsh</code>. It is not typical in OSes to be able to install multiple packages (such as different &ldquo;versions&rdquo; of the &ldquo;same&rdquo; package) that both provide <code>/usr/bin/zsh</code>. When you&rsquo;re at a Unix prompt, you don&rsquo;t have to write <code>zsh-5.0.5/usr/bin/zsh</code>. It&rsquo;s possible that many consider this is a big problem with OSes and indeed we do observe that it is fairly common to provide packages that provide binaries and libraries with embedded names such as how on my machine I have <code>python2.6</code>, <code>python2.7</code>, and <code>python3.2</code> all in my <code>$PATH</code>. It is important to realize, however, that the <code>deb</code> format and the <code>apt</code> tool didn&rsquo;t need to change to support this change or future changes in perspective in how to compose code.</p>

<p>I hope this analogy helps understand the Racket package system. In the package system, a package doesn&rsquo;t install &ldquo;binaries&rdquo;, &ldquo;man pages&rdquo;, and &ldquo;init scripts&rdquo;, but installs similar things, such as &ldquo;module paths&rdquo;, &ldquo;documentation manuals&rdquo;, and "<code>raco</code> commands". Each of these has a notion of conflict: can&rsquo;t have two <code>zsh</code>s or two <code>racket/list</code>s; can&rsquo;t have two <code>zsh.1</code> pages or two docs named <code>doc</code>; can&rsquo;t have two modules trying to provide <code>raco neo-tokyo-is-about-to-explode</code>. If you find a random <code>.deb</code> on the Internet, can you predict what binaries it will contain from its name? No. The same goes for Racket packages. However, if you are egregiously weird, then people probably won&rsquo;t want to install your packages, just like for random <code>deb</code>s.</p>

<p>However, clearly rules are helpful. In the world of operating systems, you know that basically all packages distributed by Debian can be installed at the same time, except for &ldquo;virtual packages&rdquo; that do stuff like selecting whether <code>postfix</code> or <code>sendmail</code> should be responsible for the <code>sendmail</code> command. These rules are not enforced through technology, though. Instead, the Debian maintainers have a social process that enforces them, with information being provided by technology (such as regression systems that identify unintended conflicts.) The catalog server that the Racket team provides helps facilitate a similar process with the concentric rings (all ring &lt;=1 packages can be installed at once and ring 1&lt; packages can do anything.)</p>

<p>Non-conflicting sets of packages is the simplest rule to define and enforce. Other rules about backwards compatibility are much more complicated to define and enforce. I do not believe there is much precedent in the world of OSes, although we can see a little bit of what they do through things like <code>libgtk</code>, <code>libgtk2</code>, and <code>libgtk3</code>, where generally code written for one <code>libgtk2</code> package is compatible with all <code>libgtk2</code> packages made in the future, but <code>libgtk3</code> is effectively a totally different package and introduces totally separate binaries like <code>gtk3-config</code>.</p>

<p>The most that the Racket team attempts to do here is to say, &ldquo;Here are the rules we will follow and we think you should follow them too.&rdquo; Specifically, that we will maintain backwards compatibility or make a new package. We can&rsquo;t and won&rsquo;t enforce this, nor do we always live up to it with our own work (but we feel really bad about it when we do.)</p>

<p>Although my main goal of this section has been to explain my solution to (4), a great thing about the package system is that it is not binding at all. You can decide to follow the same rules as PLaneT. It is easy to do so:</p>

<ul>
 <li>
  <p>Always name your packages <code>$AUTHOR-$PACKAGE-$MAJOR</code></p></li>
 <li>
  <p>Always provide modules from only the collection, <code>$AUTHOR-$PACKAGE-$MAJOR</code></p></li>
 <li>
  <p>Maintain backwards compatibility within releases of <code>$AUTHOR-$PACKAGE-$MAJOR</code></p></li>
 <li>
  <p>Update the <code>'version</code> metadata in the package <code>info.rkt</code> to reflect the <code>$MINOR</code> version.</p></li></ul>

<p>And, boom!, you&rsquo;ve recreated the rules of PLaneT to a T except for two things: (a) you&rsquo;ll still need to put a dependency on <code>$AUTHOR-$PACKAGE-$MAJOR</code> on the outside of code in a package <code>info.rkt</code> file rather than just inside files and (b) you can&rsquo;t use <code>$AUTHOR-$PACKAGE</code> to refer to &ldquo;whatever the current <code>$MAJOR</code>&rdquo; is.</p>

<p>The first compromise of adding something to the <code>info.rkt</code> is fairly modest, as it requires O(1) line modifications.</p>

<p>The second compromise is more severe, although actually you could just maintain such a package and deal with the breakage that occurs when you try to upgrade. Such breakage, however, was present in PLaneT too, as when a package was installed based on <code>$AUTHOR-$PACKAGE</code> only the local machine would cache the version used, so if you took the requiring module to another machine, it would download a new version and, potentially, have a backwards incompatibility problem. Using the package system in the most naive way (i.e. installing the <code>$AUTHOR-$PACKAGE</code> at some point and programming to that) would work exactly the same as PLaneT, except that the package system was designed to be able to port installations from one machine to another with <code>raco pkg migrate</code>.</p>

<p>I hope this blog post has helped explain the package system and shown that it does not prevent you from doing anything that PLaneT let you do, it only allows you to do more.</p></div>
  <a class="more" href='/2014/12/the-racket-package-system-and-planet.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>23 Nov 2014</p></col-1>

<col-2>
  <h1><a href='/2014/11/800.html'>800!</a></h1>
  <div class="truncate">
<p><em>posted by Tim Brown</em></p>

<p> 800 (Racket Tasks On Rosetta Code)</p>

<p> Since (and even before) Asumu Takikawa&rsquo;s post &ldquo;200!&rdquo; at the beginning of March 2013, folk have been beavering away, implementing tasks on <a href="http://rosettacode.org">Rosetta Code</a>. And on November 15th 2014:</p>

<p> <strong>800 tasks have now been Implemented1 in Racket on the Rosetta Code website!</strong></p>

<p> Before I go any further it must be said that, without a doubt… this is awesome! This achievement represents a lot of work, and a lot of code. And everyone who has participated should be thanked and congratulated for getting this far.</p>

<p> So thank you. And <em>well done!</em></p>

<p> What is Rosetta Code?: Rosetta Code (RC) describes itself as:</p>

<blockquote>
 <p>&hellip; a <a href="http://en.wikipedia.org/wiki/Chrestomathy">programming chrestomathy</a> site. The idea is to present solutions to the same task in as many different languages as possible, to demonstrate how languages are similar and different, and to aid a person with a grounding in one approach to a problem in learning another. Rosetta Code currently has 758 tasks, 134 draft tasks, and is aware of 560 languages, though we do not (and cannot) have solutions to every task in every language."2</p></blockquote>

<p> Of these tasks, 800 have been implemented in Racket… some tasks, like <a href="http://rosettacode.org/wiki/Hello_world/Text">Hello World/Text</a>, have been implemented in hundreds of languages. Some, however, like <a href="rosettacode.org/wiki/Time-based_One-time_Password_Algorithm">Time-based One-time Password Algorithm</a>, have only been implemented in 3 (including Racket).</p>

<p> If you haven&rsquo;t already, I suggest you take a quick look about the site to get a feel of what that means in practice.</p>

<p> <strong>WARNING:</strong> Rosetta Code is a wiki. Like any wiki it will steal your time from you as you browse tasks, algorithms, languages and the occasional link to Wikipedia. Don&rsquo;t say I didn&rsquo;t warn you.</p>

<p> What Can You Do With Rosetta Code?  &mdash;</p>

<p> <strong>Learn From It</strong>  Rosetta Code is a valuable resource with plenty of material to absorb and ideas to be had from. If you&rsquo;re new to Racket, there are tasks like <a href="http://rosettacode.org/wiki/Loops/For">Loops/For</a> which will get you on your way with fundamental programming tasks.</p>

<p> If you want something juicier there are other tasks (like <a href="http://rosettacode.org/wiki/Nonogram_solver">Nonogram solver</a> which runs to over 400 lines of Racket) for you to pick over.</p>

<p> And there&rsquo;s everything in between.</p>

<p> <strong>Write Code!</strong></p>

<p>Each task gives you a chance to think, &ldquo;Is this how I would do this?&rdquo;</p>

<p>Even if I don&rsquo;t submit something, I find it&rsquo;s fun to write some code around the task. In fact, I don&rsquo;t even have to type code into a REPL, the thought exercise is often fun enough!</p>

<p>Some tasks, like (&ldquo;Chess Player&rdquo;), are shall we say, very challenging. But don&rsquo;t let even that put you off thinking of, tinkering around or coding a solution to them.</p>

<p><strong>If there isn&rsquo;t a Racket implementation for a task you like the looks of, have a go.</strong></p>

<p> Someone might have a better idea of how to do it in Racket later. But if there isn&rsquo;t an implementation now &mdash; change that now!</p>

<p> Remember that others will be reading your code to understand Racket all the better. So please try to adhere to the <a href="http://docs.racket-lang.org/style/index.html">Racket Style Guide</a> as best you can3. Again, don&rsquo;t worry about getting that perfect. Like anything, learning Racket style takes practice, and nobody expects perfection. And the experienced contributors/documentors are always at hand to <a href="http://permalink.gmane.org/gmane.comp.lang.racket.user/18248">help correct style</a>.</p>

<p> <em>Hints:</em></p>

<ul>
 <li>
  <p>I always have a <a href="https://en.wikipedia.org/wiki/Help:Cheatsheet">Wikimedia Cheatsheet</a> to hand. I can never remember its markdown syntax (which unfortunately doesn&rsquo;t really support <code>&lt;code/&gt;</code>, either)</p></li>
 <li>
  <p>Pick whatever task you want… but it would be good to clear all the &ldquo;Complete Tasks&rdquo; (as opposed to &ldquo;Draft Tasks&rdquo;) if you have a choice.</p></li>
 <li>
  <p>Don&rsquo;t add code until it&rsquo;s running and producing the output you expect. This isn&rsquo;t Project Euler, you don&rsquo;t have to guess the answer in most cases &mdash; it&rsquo;s likely someone has some sample output to compare to.4</p></li>
 <li>
  <p>If you can&rsquo;t get your head around the algorithm in the task description then try to translate another language into Racket. You&rsquo;ll learn Racket, you&rsquo;ll learn the other language, and in working it through for yourself you&rsquo;ll also see how the algorithm takes shape and works.</p></li>
 <li>
  <p>My workflow for posting a new solution is this: Once I have something to submit, I add a &ldquo;Stub&rdquo; Racket implementation. I edit the whole Task page (because that is all that is available to edit at that point), find whatever is after Racket alphabetically, and insert boilerplate code. I check this template code as a &ldquo;minor edit&rdquo; described as &ldquo;Racket stub added &mdash; implementation later&rdquo;. This then allows is for me to be able to edit the Racket section in isolation and keeps the rest of the task (everyone else&rsquo;s hard work) safe from any, er, silliness. <code>{{header|Racket}}
&lt;lang racket&gt;
&lt;/lang racket&gt;
{{out}}
&lt;pre&gt;
&lt;/pre&gt;</code></p></li>
 <li>
  <p>I have started to make it my habit (especially when showcasing one or two functions) to use <code>#lang racket/base</code> and <code>require</code>ing the salient individual functions.</p></li>
 <li>
  <p>It is often not appropriate to fully document the functionality of Racket functions in the RC task implementation. You can, however, point to the canonical documentation on the Racket website. So I also include a link to <code>http://docs.racket-lang.org/reference/...</code> when I need to.</p></li>
 <li>
  <p>The RC administrators have switched off image uploading (or I, at least, cannot find out how). Even though Racket can produce images as results, think hard about whether you want the hassle of trying to present images to the reader. If you find out a method that works for you <em>please tell me</em>, I&rsquo;d love to know. I suppose you could also extend all of the above to coding in another language &mdash; if you really have to.</p></li></ul>

<h2 id="improve-whats-already-there">Improve What&rsquo;s Already There</h2>

<p> Rosetta Code is a wiki.</p>

<p>It is open to anyone to edit.</p>

<p> Don&rsquo;t be afraid to. If you see something that could be implemented, styled or documented better &mdash; work to improve it.</p>

<p> Once you have your improved entry together, show it to the author of the original post. Besides being courteous, he or she might have an opinion on what else you might do. Often, there is something bugging them, and you are scratching an itch of theirs!</p>

<p> I have never had anyone react badly to a change request. Everyone appreciates that you have made an effort to produce your change (and that you&rsquo;re not just standing in the aisles complaining that it doesn&rsquo;t look right).</p>

<p> Teach Through It  &mdash;</p>

<p>If there is an aspect of Racket, algorithm or other &ldquo;CS task&rdquo; (in the broadest sense) that you want to share: see to it that it is adequately illustrated on Rosetta Code. If it is not, then create a task to demonstrate it. Not only will you show how something is done properly (i.e. in Racket), but you will also be inviting others to implement the task in their own favourite languages.</p>

<h2 id="the-competition">The Competition</h2>

<p> Back at <em>200</em>, Racket was the 54th most popular language. But for some time now, it has been sitting at #2 in the popularity1 ranking for quite some time now. For a while, it has been placed a long way behind TCL, and being hotly pursued by Python (never more than 10 tasks behind).</p>

<p> One of <em>my</em> motivators is that having seen Racket get to #2 &mdash; I don&rsquo;t want to see it any lower in the rankings. I&rsquo;m sure there&rsquo;s something in the Python lot that wants to overtake us! This healthy competition has kept both of the communities pushing ahead with implementing the tasks.</p>

<p> The <a href="https://github.com/plt/racket/wiki/Intro-Projects"><em>Intro Projects</em></a> page of the racket wiki has &ldquo;Implement a Rosetta code task&rdquo; as a &ldquo;Small Project&rdquo;. I think of it as slightly more of a &ldquo;Recreational&rdquo; project (this at least justifies to myself the element of competition that has crept in.)</p>

<p> The Rallying Call  &mdash;</p>

<p> or <strong>&ldquo;What Specifically Would Help Racket on Rosetta Code?&rdquo;</strong></p>

<p> RC is a good way to present Racket as a most general programming language. So as a tool for Racket advocacy, as well as for the purposes of RC, we need to:</p>

<ul>
 <li>
  <p><strong>Implement more tasks in Racket to keep a high profile:</strong> 800 tasks, #2 in the popularity stakes. This keeps Racket visible; and proves it capable of (almost) anything. I would <em>so</em> love to give TCL a run for its money &mdash; so there&rsquo;s 41 tasks to go before we can even think of taking a breather!</p></li>
 <li>
  <p>We have implemented 800 tasks in Racket. The quote above says there are 892 (758+134) tasks in total. That means that there are 92 more tasks to get to grips with.</p></li>
 <li>
  <p><strong>Suggest new tasks:</strong> Especially tasks that will demonstrate the latest shiny feature of the latest shiny versions of Racket!</p></li></ul>

<p> Personally I can&rsquo;t believe that there are less than 900 things that you would want to do with a programming language. If you think of a task, add it. Even impossible tasks provoke thought and imagination &mdash; and interesting solutions!</p>

<ul>
 <li>
  <p><strong>Improve those tasks that have been implemented in Racket:</strong> We want to maintain a body of good, useful code, to allow us to teach and demonstrate Racket. There are a number of reasons why existent tasks need revisiting:</p></li>
 <li>
  <p>Racket technology has moved on (and moves on) apace. What was unavailable and experimental even 18 months ago is now available and reliable. This new technology needs to be demonstrated.</p></li>
 <li>
  <p>Code that is even older is very &ldquo;schemey&rdquo; (I have in some cases simply copied the Scheme implementation and stuck a <code>#lang racket</code> tag on the front). Although compatible, Racket has moved quite a way on from Scheme.</p></li>
 <li>
  <p>Some implementors (not a million miles from where I&rsquo;m standing, for example), were not as <em>au fait</em> with the language and/or style guide as they might be now. It&rsquo;s a housekeeping job, I know, but giving the examples as consistent a style as possible will help satisfy this aspiration from the Racket Style Guide:</p></li></ul>

<p> &ldquo;Doing so will help us … and our users, who use the open source code … as an implicit guide to Racket programming.&rdquo;</p>

<ul>
 <li>
  <p><strong>Document tasks:</strong> see my hint about documentation and links above for what I now think is good practice. If some code seems utterly heiroglyphic, see if it can be made clearer. Remember this is Racket, not APL.</p></li>
 <li>
  <p>General tidying up never goes amiss.</p></li>
 <li>
  <p>RC is run by someone outside the Racket community. At the bottom of the &ldquo;Small Projects&rdquo; section of the Racket wiki is a suggestion to collect the RC examples into something &ldquo;owned&rdquo; by the Racket community. I&rsquo;ve been thinking about this… if anyone has suggestions, let me know. There are limits to what we can put on RC (defined by the purpose of RC itself). It would be good to remove those limits by implementing something along RC&rsquo;s lines oursleves.</p></li>
 <li>
  <p>Very specifically… anyone with a joystick, drivers and some spare time - please could you do &ldquo;Joystick Position&rdquo;. The possession of a joystick puts you in a position of <em>great power</em> with respect to that task. Exercise your responsibility. And Finally…: Well done everyone again! Keep up the good work. And see you at 1000!</p></li>
 <li>
  <p>You can track Racket (and everyone else&rsquo;s) progress on the <a href="http://timb.net/popular-languages.html">Popular Programming Languages</a> report, which is updated hourly or so.<a href="#g76184-footnote-1-return">↩</a></p></li>
 <li>
  <p>Rosetta Code&rsquo;s Front Page<a href="#g76184-footnote-2-return">↩</a></p></li>
 <li>
  <p>The style guide is actually the chapter called &ldquo;How to Program Racket&rdquo; in the main Racket documentation. One of the RC &ldquo;style&rdquo; rules is that code should be 80 characters wide. Personally, I ignore that in favour of Racket&rsquo;s more generous 102. Sometimes someone on RC objects. Sometimes I then care enough to put the required newlines in.<a href="#g76184-footnote-3-return">↩</a></p></li>
 <li>
  <p>Even if there are example results don&rsquo;t necessarily trust them. e.g. in <a href="http://rosettacode.org/wiki/The_ISAAC_Cipher">The ISAAC Cipher</a>, the cypher engine isn&rsquo;t reset between test runs in the Pascal implementation. That error is propagated through all other implementations. Mine (Racket) conforms to show that I&rsquo;m doing the same thing as everyone else; but I also do what I think to be a more correct test later.<a href="#g76184-footnote-4-return">↩</a></p></li>
 <li>
  <p>Hold on a mo… this is meant to be a pedagogical exercise, not a competition<a href="#g76184-footnote-5-return">↩</a></p></li></ul></div>
  <a class="more" href='/2014/11/800.html'>more →</a>
<col-2>

</row>

</article>
<footer>
 <ul class="pagination">
  <li><a href="/index-2.html">
    <quote>&larr;</quote></a></li>
  <li><a href="/index.html">1</a></li>
  <li><a href="/index-2.html">2</a></li>
  <li class="active"><a href="/index-3.html">3</a></li>
  <li><a href="/index-4.html">4</a></li>
  <li><a href="/index-5.html">5</a></li>
  <li><a href="/index-6.html">6</a></li>
  <li><a href="/index-7.html">7</a></li>
  <li><a href="/index-8.html">8</a></li>
  <li><a href="/index-9.html">9</a></li>
  <li><a href="/index-10.html">10</a></li>
  <li><a href="/index-11.html">11</a></li>
  <li><a href="/index-12.html">12</a></li>
  <li><a href="/index-13.html">13</a></li>
  <li><a href="/index-14.html">14</a></li>
  <li><a href="/index-15.html">15</a></li>
  <li><a href="/index-4.html">
    <quote>&rarr;</quote></a></li></ul></footer>

<row class="one-column" id="bottom"><col-1></col-1><col-2>
<p>Made with <a href="https://github.com/greghendershott/frog">Frog</a>, a static-blog generator written in Racket.
<br /><a href="https://github.com/racket/racket-lang-org">Source code</a> for this blog.</col-2></row>
  </body>
</html>