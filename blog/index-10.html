<!DOCTYPE html>
<html lang="en">
  <head>

    <meta charset="utf-8">
    <title>Racket Blog (page 10)</title>
    <meta name="description" content="Racket Blog (page 10)">
    <meta name="author"      content="The Unknown Author">
    <meta name="keywords"    content="Chez Scheme, all">
    <meta name="viewport"    content="width=device-width, initial-scale=1.0">
    <link rel="icon"      href="/favicon.ico">
    <link rel="canonical" href="http://blog.racket-lang.org/index-10.html">


    <!-- CSS -->
    <link rel="stylesheet" type="text/css" href="/css/main.css">
    <link rel="stylesheet" type="text/css" href="/css/blog-fonts.css">
    <!-- Feeds -->
    <link rel="alternate" type="application/atom+xml" href="/feeds/all.atom.xml" title="Atom Feed">
    <link rel="alternate" type="application/rss+xml" href="/feeds/all.rss.xml" title="RSS Feed">
    <!-- JS -->
    </head>
  <body>
<row class="one-column" id="logo"><col-1><a href="http://racket-lang.org"><div id="logo-container"><img id="logo" src="/img/racket-logo.svg"/> Racket</div></a></col-1><col-2><p><a href="/index.html">blog</a></p></col-2></row>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>01 Dec 2009</p></col-1>

<col-2>
  <h1><a href='/2009/12/plt-scheme-v423.html'>PLT Scheme v4.2.3</a></h1>
  <div class="truncate">
<p><em>posted by Eli Barzilay</em></p>

<p>PLT Scheme version 4.2.3 is now available from <a href="http://plt-scheme.org/"><code>http://plt-scheme.org/</code></a></p>

<ul>
 <li>
  <p>The unit test framework for the teaching languages provides <code>check-member-of</code> and <code>check-range</code> for checking &ldquo;random functions&rdquo;, i.e., &ldquo;functions&rdquo; that may produce several different results for one and the same argument.</p></li>
 <li>
  <p>Added a new image library, <code>2htdp/image</code>. Significant changes from <code>htdp/image</code>:</p></li>
 <li>
  <p>copying and pasting does not introduce jaggies</p></li>
 <li>
  <p><code>equal?</code> comparisons are more efficient</p></li>
 <li>
  <p>added rotation &amp; scaling</p></li>
 <li>
  <p>got rid of pinholes (new overlay, beside, above functions based on bounding boxes)</p></li>
 <li>
  <p>The <code>scheme/vector</code> library provides common vector operations (also reprovided by <code>scheme</code>).</p></li>
 <li>
  <p>The <code>scheme/promise</code> library provides several new kinds of promises with alternatives execution strategies.</p></li>
 <li>
  <p>New port-reading utilities: <code>in-port</code>, <code>port-&gt;list</code>, <code>file-&gt;list</code>.</p></li>
 <li>
  <p>A new require-macro, <code>path-up</code>, for  requiring a file that is higher in the directory tree.</p></li></ul></div>
  <a class="more" href='/2009/12/plt-scheme-v423.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>04 Oct 2009</p></col-1>

<col-2>
  <h1><a href='/2009/10/plt-scheme-v422.html'>PLT Scheme v4.2.2</a></h1>
  <div class="truncate">
<p><em>posted by Eli Barzilay</em></p>

<p>PLT Scheme version 4.2.2 is now available from <a href="http://plt-scheme.org/"><code>http://plt-scheme.org/</code></a></p>

<ul>
 <li>
  <p>DrScheme now, by default, compiles all of the files that are loaded when it runs a program and saves the compiled files in the filesystem. This should lead to faster load times (not faster runtimes) since it avoids re-compiling files whose dependencies have not changed.</p></li>
 <li>
  <p>New Scribble libraries and documentation make it easier to get started with Scribble, especially for uses other than PLT documentation. DrScheme now has better indentation and syntax coloring support for Scribble languages (and generally all @-exp based languages).</p></li>
 <li>
  <p>The new <code>syntax/keyword</code> library provides support for macros with keyword options. A new quick start guide has been added to the documentation for the <code>syntax/parse</code> library.</p></li>
 <li>
  <p>Added support for abstract contracts via the #:exists keywords. This is an experiment to add support for data hiding to the contract system.</p></li>
 <li>
  <p>Added <code>in-producer</code>: a sequence expression makes it easy to iterate over producer functions (e.g., <code>read</code>). A new <code>scheme/generator</code> library creates generators that can use a (parameterized) yield function.</p></li>
 <li>
  <p>HtDP langs: several primitives now consume 0 and 1 arguments in ISL (and up), including <code>append</code>, <code>+</code> and <code>*</code>. In addition, <code>make-list</code> was added to the primitives.</p></li>
 <li>
  <p>The API to Universe has a number of new constructs. All Universe programs should run unchanged. The most important change is the addition of <code>animate</code> as an alternative name for <code>run-simulation</code>. In addition, adding the clause <code>(state true)</code> to a world description now pretty-prints the state of the world into a separate canvas.</p></li>
 <li>
  <p>A number of changes were made to the DeinProgramm / DMdA language levels: The <code>check-property</code> and <code>contract</code> forms were added, <code>define-record-procedures-parametric</code> has changed. See the documentation for details.</p></li>
 <li>
  <p>The test engine in the HtDP languages no longer warns programmers when the Definitions window has no tests.</p></li>
 <li>
  <p>ProfessorJ (and related code) is no longer included in the PLT distributions. It may re-appear in the future as a PLaneT package.</p></li></ul></div>
  <a class="more" href='/2009/10/plt-scheme-v422.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>21 Sep 2009</p></col-1>

<col-2>
  <h1><a href='/2009/09/set-vs-set-box-and-unbox.html'><code>set!</code> vs. <code>set-box!</code> and <code>unbox</code></a></h1>
  <div class="truncate">
<p><em>posted by Robby Findler</em></p>

<p>A few weeks ago I was chatting with some PLT folks and was surprised to hear them say that they avoided <code>set!</code> because using <code>set-box!</code> and <code>unbox</code> was easier to see what was going on.</p>

<p>This struck me as wrong since one might pass boxes around and then you can&rsquo;t be sure which box you&rsquo;re mutating, but you cannot pass variable references around and thus which variable you&rsquo;re using is always lexically apparent. (Of course, when you add <code>lambda</code> into the mix that isn&rsquo;t really true, since you can capture a variable in a closure and pass that around.)</p>

<p>Their point seemed to be that you had to write something special at each use of the box, unlike with <code>set!</code> where you simply write a variable reference and it might be getting a changing quantity and it might not be. This made me realize I could do something to help, at least, and so I changed Check Syntax so that it colored <code>set!</code>&rsquo;d variables in red, like this:</p></div>
  <a class="more" href='/2009/09/set-vs-set-box-and-unbox.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>30 Jul 2009</p></col-1>

<col-2>
  <h1><a href='/2009/07/plt-scheme-v421.html'>PLT Scheme v4.2.1</a></h1>
  <div class="truncate">
<p><em>posted by Eli Barzilay</em></p>

<p>PLT Scheme version 4.2.1 is now available from  <a href="http://plt-scheme.org/"><code>http://plt-scheme.org/</code></a></p>

<ul>
 <li>This is the last release that includes ProfessorJ. As of the next release, Kathy Gray who created and maintained the Professor will move the code to planet and maintain only at a minimal level.</li>
 <li>Typed Scheme 2.0 extends the type system significantly, making it more expressive. For example, predicates applied to selectors, such as (number? (car x)), are meaningful to the type system.</li>
 <li>Faster installation of Planet packages that trigger install of other Planet packages, because the documentation index is updated only once after a group of packages is installed.</li>
 <li>The <code>syntax/parse</code> library provides macro writers with an enhanced syntax pattern matcher that reports errors based on the patterns&rsquo; declared classes of syntax.</li>
 <li>Identifier mappings following the v4 dictionary interface and naming conventions are available from the <code>syntax/id-table</code> library.</li>
 <li>Redex: added <code>define-relation</code> and generalized patterns that appear in &ldquo;where&rdquo; clauses to use the full Redex pattern matcher. (This is a backwards incompatible change, but one often requested; see the Redex release notes for details.)</li>
 <li>The Web Server&rsquo;s serializable closures are now available for other purposes through the web-server/lang/serial-lambda library.</li>
 <li>Teachpacks: small changes to universe portion of the &ldquo;universe.ss&rdquo; API, plus the addition of a form for launching many (communicating) worlds simultaneously. Bug fixes concerning conversion to strings.</li>
 <li>It is now possible to create custom scribble readers with a command characters different than <code>@</code>, see <code>make-at-reader/inside</code> and <code>make-at-reader</code></li>
 <li>Note: this is likely to be the last release that includes a solaris distribution. If you need these builds, or if you have access to a (Sparc) Solaris machine than can be used in PLT builds, then please let me know.</li></ul></div>
  <a class="more" href='/2009/07/plt-scheme-v421.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>23 Jun 2009</p></col-1>

<col-2>
  <h1><a href='/2009/06/serializable-closures-in-plt-scheme.html'>Serializable Closures in PLT Scheme</a></h1>
  <div class="truncate">
<p><em>posted by Jay McCarthy</em></p>

<p>PLT Scheme supports an extensible <a href="http://docs.plt-scheme.org/reference/serialization.html">serialization</a> system for structures. A structure is serializable if it has a <code>prop:serializable</code> property. There are many <a href="http://docs.plt-scheme.org/search/index.html?q=prop%3A">properties</a> in PLT Scheme for other extensions, such as <a href="http://docs.plt-scheme.org/reference/procedures.html#(def._((lib._scheme/base..ss)._prop~3aprocedure))">applicable structures</a> and <a href="http://docs.plt-scheme.org/reference/booleans.html#(def._((quote._~23~25kernel)._prop~3aequal+hash))">custom equality predicates</a>.</p>

<p>The <a href="http://docs.plt-scheme.org/web-server/index.html">PLT Web</a> application development framework uses these features to provide <a href="http://docs.plt-scheme.org/web-server/stateless.html#(part._.Serializable_.Continuations)">serializable continuations</a> through a number of source transformations and a serializable closure structure.</p>

<p><em>Warning: This remainder post refers to features only available in the latest SVN revision of PLT Scheme.</em></p>

<p>I&rsquo;ve recently made these closures more accessible to non-Web programs through <code>web-server/lang/serial-lambda</code>. Here&rsquo;s a demo:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="kn">#lang </span><span class="nn">scheme</span>
<span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._require))" style="color: inherit">require</a></span> <span class="n">web-server/lang/serial-lambda</span>
         <span class="n">scheme/serialize</span><span class="p">)</span>

<span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="n">f</span>
  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="p">([</span><span class="n">z</span> <span class="mi">5</span><span class="p">])</span>
    <span class="p">(</span><span class="n">serial-lambda</span>
     <span class="p">(</span><span class="n">x</span> <span class="n">y</span><span class="p">)</span>
     <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit">+</a></span> <span class="n">x</span> <span class="n">y</span> <span class="n">z</span><span class="p">))))</span>

<span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="p">(</span><span class="n">test-it</span><span class="p">)</span>
  <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._printf))" style="color: inherit">printf</a></span> <span class="s2">"~S~n"</span> <span class="p">(</span><span class="n">f</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">))</span>
  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="p">([</span><span class="n">fs</span> <span class="p">(</span><span class="n"><a href="http://docs.racket-lang.org/reference/serialization.html#(def._((lib._racket/private/serialize..rkt)._serialize))" style="color: inherit">serialize</a></span> <span class="n">f</span><span class="p">)])</span>
    <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._printf))" style="color: inherit">printf</a></span> <span class="s2">"~S~n"</span> <span class="n">fs</span><span class="p">)</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="p">([</span><span class="n">df</span> <span class="p">(</span><span class="n"><a href="http://docs.racket-lang.org/reference/serialization.html#(def._((lib._racket/private/serialize..rkt)._deserialize))" style="color: inherit">deserialize</a></span> <span class="n">fs</span><span class="p">)])</span>
      <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._printf))" style="color: inherit">printf</a></span> <span class="s2">"~S~n"</span> <span class="n">df</span><span class="p">)</span>
      <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._printf))" style="color: inherit">printf</a></span> <span class="s2">"~S~n"</span> <span class="p">(</span><span class="n">df</span> <span class="mi">1</span> <span class="mi">2</span><span class="p">)))))</span>

<span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3e))" style="color: inherit">&gt;</a></span> <span class="p">(</span><span class="n">test-it</span><span class="p">)</span>
<span class="mi">8</span>
<span class="p">((</span><span class="mi">2</span><span class="p">)</span> <span class="mi">1</span> <span class="p">((</span><span class="s2">#"/Users/jay/Dev/svn/plt/collects/web-server/exp/test-serial.ss"</span> <span class="o">.</span> <span class="s2">"lifted.6"</span><span class="p">))</span> <span class="mi">0</span> <span class="p">()</span> <span class="p">()</span> <span class="p">(</span><span class="mi">0</span> <span class="mi">5</span><span class="p">))</span>
<span class="o">#</span><span class="p">(</span><span class="ss">struct:7a410aca70b31e88b4c2f0fe77fa7ffe:0</span> <span class="ss">#</span><span class="p">)</span>
<span class="mi">8</span>
</pre></div>

</div>

<p>Now, let&rsquo;s see how it is implemented. <a href="http://svn.plt-scheme.org/plt/trunk/collects/web-server/lang/serial-lambda.ss"><code>web-server/lang/serial-lambda</code></a> is thin wrapper around <a href="http://svn.plt-scheme.org/plt/trunk/collects/web-server/lang/closure.ss"><code>web-server/lang/closure</code></a>, which has two syntax transformer functions: <code>define-closure!</code> which defines the closure structure and <code>make-closure</code> which instantiates the closure. (The two tasks are separated to easily provide a user top-level definition syntax for named closures with different free identifires, rather than simply anonymous lambdas with fixed free identifiers.)</p>

<p><code>make-closure</code> does the following:</p>

<ol>
 <li>
  <p>Expands the procedure syntax using <a href="http://docs.plt-scheme.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._local-expand))"><code>local-expand</code></a>, so it can use <a href="http://docs.plt-scheme.org/syntax/syntax-helpers.html#(def._((lib._syntax/free-vars..ss)._free-vars))"><code>free-vars</code></a> to compute the free identifires.</p></li>
 <li>
  <p>Uses <code>define-closure!</code> to define the structure and get the name for the constructor.</p></li>
 <li>
  <p>Instantiates the closure with the current values of the free identifiers.</p></li></ol>

<p>The more interesting work is done by <code>define-closure!</code>. At a high-level, it needs to do the following:</p>

<ol>
 <li>
  <p>Create a deserialization function.</p></li>
 <li>
  <p>Create a serialization function that references the deserializer.</p></li>
 <li>
  <p>Define the closure structure type that references the serializer.</p></li>
 <li>
  <p>Provide the deserializer from the current module so that arbitrary code can deserialize instances of this closure type.</p></li></ol>

<p>These tasks are complicated in a few ways:</p>

<ul>
 <li>
  <p>The deserializer needs the closure structure type definition to create instances and the serializer needs the closure structure type to access their fields.</p></li>
 <li>
  <p>The serializer needs the syntactic identifier of the deserializer so that <code>scheme/serialize</code> can <a href="http://docs.plt-scheme.org/reference/Module_Names_and_Loading.html#(def._((quote._~23~25kernel)._dynamic-require))"><code>dynamic-require</code></a> it during deserialization.</p></li>
 <li>
  <p>The deserializer must be defined at the top-level, so it may be provided.</p></li>
 <li>
  <p>All this may occur in a syntactic expression context.</p></li></ul>

<p>Thankfully, the PLT Scheme <a href="http://docs.plt-scheme.org/reference/Macros.html">macro system</a> is powerful to support all this.</p>

<ul>
 <li>
  <p><a href="http://docs.plt-scheme.org/reference/stxtrans.html#(def._((quote._~23~25kernel)._syntax-local-lift-expression))"><code>syntax-local-lift-expression</code></a> allows a syntax transformer to lift an expression to the top-level of a module and returns the identifier it is bound to.</p></li>
 <li>
  <p><a href="http://docs.plt-scheme.org/search/index.html?q=syntax-local-lift-values-expression"><code>syntax-local-lift-values-expression</code></a> (added in 4.2.0.3) provides the same for expressions that return multiple values, such as <a href="http://docs.plt-scheme.org/reference/creatingmorestructs.html#(def._((quote._~23~25kernel)._make-struct-type))"><code>make-struct-type</code></a>, which is used to define structures.</p></li>
 <li>
  <p><a href="http://docs.plt-scheme.org/search/index.html?q=syntax-local-lift-provide"><code>syntax-local-lift-provide</code></a> (added in 4.2.0.4) allows a syntax transformer to lift a provide to the top-level.</p></li></ul>

<p>The only complicated piece is allowing the deserializer and serializer to refer to the closure structure constructor and accessors. This is easily accomplished by first defining lifting boxes that will hold these values and initializing them when the structure type is defined. This is safe because all accesses to the boxes are under lambdas that are guaranteed not to be run before the structure type is defined.</p>

<p><strong>An aside on the closure representation.</strong> The closure is represented as a structure with one field: the environment. The environment is represented as a thunk that returns <em>n</em> values, one for each of the free identifiers. This ensures that references that were under lambdas in the original syntax, remain under lambdas in the closure construction, so the serializable closures work correctly inside <code>letrec</code>. This thunk is applied by the serializer and the free values are stored in a vector. The closure also uses the <code>prop:procedure</code> structure property to provide an application function that simply invokes the environment thunk and binds its names, then <code>apply</code>s the original procedure syntax to the arguments.</p>

<p><strong>An aside on the serializer.</strong> The deserializer is bound to lifted identifier which is represented in PLT Scheme as an unreadable symbol. Version 4.2.0.5 added support for (de)serializing these.</p></div>
  <a class="more" href='/2009/06/serializable-closures-in-plt-scheme.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>01 Jun 2009</p></col-1>

<col-2>
  <h1><a href='/2009/06/plt-scheme-v42.html'>PLT Scheme v4.2</a></h1>
  <div class="truncate">
<p><em>posted by Eli Barzilay</em></p>

<p>PLT Scheme version 4.2 is now available from <a href="http://plt-scheme.org/">http://plt-scheme.org/</a> Internally, this version includes a conversion from C++ to Scheme for part of the GUI toolbox &mdash; specifically, 25k lines of code that implement the general text and pasteboard editor. This conversion is a start on a larger reimplementation of the GUI toolbox. Although we believe that this change will help make PLT Scheme better in the long run, we must expect bugs in the short term due to porting errors. Users should therefore be aware of the change, even though the new implementation is meant to behave the same as previous versions.</p>

<ul>
 <li>
  <p>A new statistical profiler is now available; see the &ldquo;profiler&rdquo; manual for more information. Currently, the profiler supports only textual output, but future plans include a GUI interface and DrScheme integration.</p></li>
 <li>
  <p>The <code>world</code> teachpack is now deprecated. Its replacement <code>universe</code> has a new interface that uses strings instead of symbols and characters.</p></li>
 <li>
  <p>Web-server: Native continuations in the stateless servlet language support capturing continuations from untransformed contexts; soft state library for stateless servlets.</p></li>
 <li>
  <p>DrScheme&rsquo;s Stepper can now jump to a selected program expression.</p></li>
 <li>
  <p>New in <code>scheme/base</code>: <code>hash-has-key?</code>, <code>hash-ref!</code>, <code>in-sequences</code>, <code>in-cycle</code>. New in <code>scheme</code>: <code>count</code>, <code>make-list</code> (from <code>scheme/list</code>), <code>const</code> (from <code>scheme/function</code>).</p></li>
 <li>
  <p>Some performance improvements, including faster start-up for small programs. The latter is a result of delaying module invocations at higher phases (compile time, meta-compile time, etc.) until compilation is demanded at the next lower phase; this on-demand instantiation is per-phase, as opposed to per-module within a phase.</p></li></ul>

<p>[Note that mirror sites can take a while to catch up with the new downloads.]</p>

<p>Feedback Welcome.</p></div>
  <a class="more" href='/2009/06/plt-scheme-v42.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>25 May 2009</p></col-1>

<col-2>
  <h1><a href='/2009/05/typed-scheme-20.html'>Typed Scheme 2.0</a></h1>
  <div class="truncate">
<p><em>posted by Sam Tobin-Hochstadt</em></p>

<p>Typed Scheme version 2.0 is now available from SVN.</p>

<p>One persistent limitation of Typed Scheme has been that while this expression works as expected:</p>

<p><code>(if (number? x) (add1 x) 7)</code></p>

<p>The simple transformation of making <code>x</code> a part of a structure breaks Typed Scheme&rsquo;s ability to reason about the code. So this expression doesn&rsquo;t typecheck:</p>

<p><code>(if (number? (car x)) (add1 (car x)) 7)</code></p>

<p>With the newest version of Typed Scheme, now available in SVN, both of these will now work. In general, Typed Scheme can now follow paths into arbitrary immutable structures, including pairs.</p>

<p>This is part of a more general reworking of underlying mechanisms of the Typed Scheme typechecker, which makes it both simpler and more flexible. I hope that it will be possible, sing this new foundation to add additional features that make more programs easy to express in Typed Scheme.</p>

<p>Of course, these changes mean that Typed Scheme may be more unstable, so if you notice any new bugs, please let us know.</p>

<p>Unfortunately, this won&rsquo;t be available in the upcoming 4.2 release, but it will be in the release after that.</p>

<p>If you have any questions or comments or feature requests for Typed Scheme, please let us know.</p></div>
  <a class="more" href='/2009/05/typed-scheme-20.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>24 May 2009</p></col-1>

<col-2>
  <h1><a href='/2009/05/explicit-renaming-macros-implicitly.html'>Explicit Renaming Macros; Implicitly</a></h1>
  <div class="truncate">
<p><em>posted by Eli Barzilay</em></p>

<p>It&rsquo;s been one too many times that I hear respectable Schemers talk about how they like explicit renaming macros — not because they&rsquo;re more powerful, but because using them is close to using simple <code>defmacro</code>s. In this post I&rsquo;ll show how you can easily write ER-like macros in PLT, just so I won&rsquo;t need to explain the same thing once again.</p>

<p>Disclaimers:</p>

<ul>
 <li>
  <p>If you&rsquo;re not interested in ER-macros, then you shouldn&rsquo;t read this.</p></li>
 <li>
  <p>I&rsquo;m not claiming that ER macros are not respectable, I&rsquo;m just surprised at the knee jerk reaction to <code>syntax-case</code>.</p></li>
 <li>
  <p>This is not an attempt at providing some portable library or even a PLT library. The intention is to show that <code>syntax-case</code>-style macros are &ldquo;as convenient&rdquo; as ER macros, if you really want to get down to that level.</p></li>
 <li>
  <p>This is also not an attempt at any kind of formal claim of equivalence in any direction, only a demonstration that you can get the same kind of convenience.</p></li>
 <li>
  <p>The bottom line here should be just the convenience point, addressed at people who like ER macros for that, and who think that <code>syntax-case</code> macros are somehow magical or that you lose the ability to play with S-expressions.</p></li></ul>

<p>The important fact here is that while PLT&rsquo;s <code>syntax-case</code> macro system does not give you raw S-expressions, what you get is a simple wrapper holding them. A macro is a syntax transformer: a function that consumes a syntax value and returns one. For example:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit">define-syntax</a></span> <span class="p">(</span><span class="n">foo</span> <span class="n">stx</span><span class="p">)</span>
    <span class="o">#'</span><span class="mi">123</span><span class="p">)</span>
</pre></div>

</div>

<p>is a macro that always expands to 123 (with <code>#'123</code> being the usual shorthand for <code>(syntax 123)</code>).</p>

<p>A syntax object in PLT Scheme (the input to macro functions) is an S-expression, with some lexical information added — this includes the lexical context (in an opaque form), source location, and a few more things. To be more precise, a syntax value is a nested structure of wrappers holding lists and pairs, holding more wrappers, with identifiers at the leaves, where an identifier is a wrapper holding a symbol. It&rsquo;s easy to strip off all wrappers using <code>syntax-&gt;datum</code> if you like to work with S-expressions, but you <em>don&rsquo;t</em> want to strip it off of identifiers, since that will lose the important gravy. (In fact, the <code>defmacro</code> library works by stripping off all information, even from identifiers, then reconstructing it by trying to match names in the output form with the original input.)</p>

<p>Instead of throwing away all information, what we want to do is preserve identifiers. We can use <code>syntax-&gt;list</code> for this: this is a function that takes a syntax value that contains a list, and strips off the top-level extra information leaving you with a list of syntaxes for the sub-expressions (returning <code>#f</code> if the input syntax does not hold a list). Once we have such a list, we can do the usual kind of processing with it, and when we&rsquo;re done turn the result back into a syntax using <code>datum-&gt;syntax</code> (which &ldquo;borrows&rdquo; the original input expression&rsquo;s information). For example,</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit">define-syntax</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._add1))" style="color: inherit">add1</a></span> <span class="n">stx</span><span class="p">)</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="p">([</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit">+</a></span> <span class="o">#'</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit">+</a></span><span class="p">])</span>
      <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._datum-~3esyntax))" style="color: inherit">datum-&gt;syntax</a></span> <span class="n">stx</span> <span class="o">`</span><span class="p">(</span><span class="o">,</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._+))" style="color: inherit">+</a></span> <span class="mi">1</span> <span class="o">,@</span><span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cdr))" style="color: inherit">cdr</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._syntax-~3elist))" style="color: inherit">syntax-&gt;list</a></span> <span class="n">stx</span><span class="p">)))</span> <span class="n">stx</span><span class="p">)))</span>
</pre></div>

</div>

<p>That&rsquo;s a very simple example though; if you try something a little more complicated, you quickly find out that all this unwrapping is inconvenient:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit">define-syntax</a></span> <span class="p">(</span><span class="n">mylet</span> <span class="n">stx</span><span class="p">)</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="p">([</span><span class="n">*lambda</span> <span class="o">#'</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span><span class="p">])</span>
      <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._datum-~3esyntax))" style="color: inherit">datum-&gt;syntax</a></span>
       <span class="n">stx</span>
       <span class="o">`</span><span class="p">((</span><span class="o">,</span><span class="n">*lambda</span> <span class="o">,</span><span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit">map</a></span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._car))" style="color: inherit">car</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._syntax-~3elist))" style="color: inherit">syntax-&gt;list</a></span> <span class="n">x</span><span class="p">)))</span>
                         <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._syntax-~3elist))" style="color: inherit">syntax-&gt;list</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cadr))" style="color: inherit">cadr</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._syntax-~3elist))" style="color: inherit">syntax-&gt;list</a></span> <span class="n">stx</span><span class="p">))))</span>
                   <span class="o">,@</span><span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cddr))" style="color: inherit">cddr</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._syntax-~3elist))" style="color: inherit">syntax-&gt;list</a></span> <span class="n">stx</span><span class="p">)))</span>
         <span class="o">,@</span><span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit">map</a></span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cadr))" style="color: inherit">cadr</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._syntax-~3elist))" style="color: inherit">syntax-&gt;list</a></span> <span class="n">x</span><span class="p">)))</span>
                <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._syntax-~3elist))" style="color: inherit">syntax-&gt;list</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cadr))" style="color: inherit">cadr</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._syntax-~3elist))" style="color: inherit">syntax-&gt;list</a></span> <span class="n">stx</span><span class="p">)))))</span>
       <span class="n">stx</span><span class="p">)))</span>
</pre></div>

</div>

<p>(Note also the <code>*lambda</code> that is used to avoid the <code>lambda</code> expressions used in the meta-code.)</p>

<p>What can help here is some helper function that receive a syntax value as its input, and turn all wrapped lists into real lists recursively, but will leave identifiers intact:</p>

<div class="brush: (begin-for-syntax">
 <div class="pygments">
  <pre><span></span>    (define (strip stx)
      (let ([maybe-list (syntax-&gt;list stx)])
        ;; syntax-&gt;list returns #f if the syntax is not a list
        (if maybe-list (map strip maybe-list) stx))))
</pre></div>

</div>

<p>But as long as we&rsquo;re writing a syntax utility, we can make it do a litte more work: feed the resulting tree to <em>your</em> transformer, grab its result, and do the necessary <code>datum-&gt;syntax</code> voodoo on it:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/begin.html#(form._((quote._~23~25kernel)._begin-for-syntax))" style="color: inherit">begin-for-syntax</a></span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="p">(</span><span class="n">er-like-transformer</span> <span class="n">transformer</span><span class="p">)</span>
      <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="p">(</span><span class="n">strip</span> <span class="n">stx</span><span class="p">)</span>
        <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="p">([</span><span class="n">maybe-list</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._syntax-~3elist))" style="color: inherit">syntax-&gt;list</a></span> <span class="n">stx</span><span class="p">)])</span>
          <span class="c1">;; syntax-&gt;list returns #f if the syntax is not a list</span>
          <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit">if</a></span> <span class="n">maybe-list</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit">map</a></span> <span class="n">strip</span> <span class="n">maybe-list</span><span class="p">)</span> <span class="n">stx</span><span class="p">)))</span>
      <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="n">stx</span><span class="p">)</span>
        <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/stxops.html#(def._((quote._~23~25kernel)._datum-~3esyntax))" style="color: inherit">datum-&gt;syntax</a></span> <span class="n">stx</span> <span class="p">(</span><span class="n">transformer</span> <span class="p">(</span><span class="n">strip</span> <span class="n">stx</span><span class="p">))</span> <span class="n">stx</span><span class="p">))))</span>
</pre></div>

</div>

<p>With this utility defined, the above macro becomes much easier to deal with:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit">define-syntax</a></span> <span class="n">mylet</span>
    <span class="p">(</span><span class="n">er-like-transformer</span>
     <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._exp))" style="color: inherit">exp</a></span><span class="p">)</span>
       <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="p">((</span><span class="n">vars</span>  <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit">map</a></span> <span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._car))" style="color: inherit">car</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cadr))" style="color: inherit">cadr</a></span> <span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._exp))" style="color: inherit">exp</a></span><span class="p">)))</span>
             <span class="p">(</span><span class="n">inits</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/map..rkt)._map))" style="color: inherit">map</a></span> <span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cadr))" style="color: inherit">cadr</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cadr))" style="color: inherit">cadr</a></span> <span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._exp))" style="color: inherit">exp</a></span><span class="p">)))</span>
             <span class="p">(</span><span class="n">body</span>  <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cddr))" style="color: inherit">cddr</a></span> <span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._exp))" style="color: inherit">exp</a></span><span class="p">)))</span>
         <span class="o">`</span><span class="p">((</span><span class="o">,</span><span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._syntax))" style="color: inherit">syntax</a></span> <span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span><span class="p">)</span> <span class="o">,</span><span class="n">vars</span> <span class="o">,@</span><span class="n">body</span><span class="p">)</span>
           <span class="o">,@</span><span class="n">inits</span><span class="p">)))))</span>
 <span class="o">```</span>

 <span class="ss">...and</span> <span class="k"><a href="http://docs.racket-lang.org/reference/createclass.html#(form._((lib._racket/private/class-internal..rkt)._this))" style="color: inherit">this</a></span> <span class="n">is</span> <span class="n">almost</span> <span class="n">identical</span> <span class="n">to</span> <span class="n">the</span> <span class="n">explicit</span> <span class="n">renaming</span> <span class="nb"><a href="http://docs.racket-lang.org/reference/runtime.html#(def._((quote._~23~25kernel)._version))" style="color: inherit">version</a></span> <span class="n">of</span> <span class="n">the</span> <span class="n">macro</span><span class="c1">; for example, compare it with the sample code in the [MIT-Scheme manual](http://groups.csail.mit.edu/mac/projects/scheme/documentation/scheme_3.html#SEC49).  The only change is that `(rename &#39;lambda)` is replaced with `(syntax lambda)`.</span>

<span class="n">Obviously</span><span class="o">,</span> <span class="k"><a href="http://docs.racket-lang.org/reference/createclass.html#(form._((lib._racket/private/class-internal..rkt)._this))" style="color: inherit">this</a></span> <span class="n">is</span> <span class="n">very</span> <span class="n">close</span><span class="o">,</span> <span class="n">but</span> <span class="n">doesn</span><span class="o">'</span><span class="ss">t</span> <span class="n">show</span> <span class="n">intentional</span> <span class="n">captures.</span>  <span class="n">So</span> <span class="n">I</span> <span class="n">just</span> <span class="n">grabbed</span> <span class="n">the</span> <span class="o">`</span><span class="ss">loop</span><span class="o">`</span> <span class="ss">example</span> <span class="n">from</span> <span class="n">the</span> <span class="n">same</span> <span class="n">page</span><span class="o">,</span> <span class="k"><a href="http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._and))" style="color: inherit">and</a></span> <span class="n">did</span> <span class="n">the</span> <span class="n">same</span> <span class="n">change</span> <span class="n">—</span> <span class="k"><a href="http://docs.racket-lang.org/reference/creatingunits.html#(form._((lib._racket/unit..rkt)._only))" style="color: inherit">only</a></span> <span class="k"><a href="http://docs.racket-lang.org/reference/createclass.html#(form._((lib._racket/private/class-internal..rkt)._this))" style="color: inherit">this</a></span> <span class="k"><a href="http://docs.racket-lang.org/reference/time.html#(form._((lib._racket/private/more-scheme..rkt)._time))" style="color: inherit">time</a></span> <span class="n">I</span> <span class="n">used</span> <span class="o">`#'</span><span class="ss">foo</span><span class="o">`</span> <span class="ss">instead</span> <span class="n">of</span> <span class="o">`</span><span class="p">(</span><span class="ss"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._syntax))" style="color: inherit">syntax</a></span> <span class="ss">foo</span><span class="p">)</span><span class="o">`</span> <span class="p">(</span><span class="ss"><a href="http://docs.racket-lang.org/reference/if.html#(form._((lib._racket/private/letstx-scheme..rkt)._and))" style="color: inherit">and</a></span> <span class="ss">I</span> <span class="ss">also</span> <span class="ss">changed</span> <span class="ss">the</span> <span class="ss">one-sided</span> <span class="o">`</span><span class="ss"><a href="http://docs.racket-lang.org/reference/if.html#(form._((quote._~23~25kernel)._if))" style="color: inherit">if</a></span><span class="o">`</span> <span class="ss">to</span> <span class="ss">a</span> <span class="o">`</span><span class="ss"><a href="http://docs.racket-lang.org/reference/when_unless.html#(form._((lib._racket/private/letstx-scheme..rkt)._when))" style="color: inherit">when</a></span><span class="o">`</span><span class="p">)</span><span class="o">.</span>  <span class="n">The</span> <span class="n">resulting</span> <span class="n">macro</span> <span class="n">works</span> <span class="n">fine:</span>  

<span class="o">```</span><span class="ss">racket</span>
<span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit">define-syntax</a></span> <span class="n">loop</span>
    <span class="p">(</span><span class="n">er-like-transformer</span>
     <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="n">x</span><span class="p">)</span>
       <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="p">((</span><span class="n">body</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((quote._~23~25kernel)._cdr))" style="color: inherit">cdr</a></span> <span class="n">x</span><span class="p">)))</span>
         <span class="o">`</span><span class="p">(</span><span class="o">,#'</span><span class="nb"><a href="http://docs.racket-lang.org/reference/cont.html#(def._((quote._~23~25kernel)._call-with-current-continuation))" style="color: inherit">call-with-current-continuation</a></span>
           <span class="p">(</span><span class="o">,#'</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="ss"><a href="http://docs.racket-lang.org/reference/Exiting.html#(def._((quote._~23~25kernel)._exit))" style="color: inherit">exit</a></span><span class="p">)</span>
            <span class="p">(</span><span class="o">,#'</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="o">,#'</span><span class="n">f</span> <span class="p">()</span> <span class="o">,@</span><span class="n">body</span> <span class="p">(</span><span class="o">,#'</span><span class="n">f</span><span class="p">))))))))</span>

  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define-syntax))" style="color: inherit">define-syntax</a></span> <span class="n">while</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._syntax-rules))" style="color: inherit">syntax-rules</a></span> <span class="p">()</span>
      <span class="p">((</span><span class="n">while</span> <span class="n">test</span> <span class="n">body</span> <span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit">...</a></span><span class="p">)</span>
       <span class="p">(</span><span class="n">loop</span> <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/when_unless.html#(form._((lib._racket/private/letstx-scheme..rkt)._when))" style="color: inherit">when</a></span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/booleans.html#(def._((quote._~23~25kernel)._not))" style="color: inherit">not</a></span> <span class="n">test</span><span class="p">)</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/Exiting.html#(def._((quote._~23~25kernel)._exit))" style="color: inherit">exit</a></span> <span class="no">#f</span><span class="p">))</span>
             <span class="n">body</span> <span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt)._......))" style="color: inherit">...</a></span><span class="p">))))</span>

  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/let.html#(form._((lib._racket/private/letstx-scheme..rkt)._let))" style="color: inherit">let</a></span> <span class="p">((</span><span class="n">x</span> <span class="mi">10</span><span class="p">))</span>
    <span class="p">(</span><span class="n">while</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._~3e))" style="color: inherit">&gt;</a></span> <span class="n">x</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._printf))" style="color: inherit">printf</a></span> <span class="s2">"~s</span><span class="se">\n</span><span class="s2">"</span> <span class="n">x</span><span class="p">)</span>
      <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/set_.html#(form._((quote._~23~25kernel)._set!))" style="color: inherit">set!</a></span> <span class="n">x</span> <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/generic-numbers.html#(def._((quote._~23~25kernel)._-))" style="color: inherit">-</a></span> <span class="n">x</span> <span class="mi">1</span><span class="p">))))</span>
</pre></div>

</div>

<p>This is pretty close to a library, and indeed, as I was writing this text I found <a href="http://www.mail-archive.com/larceny-users@lists.ccs.neu.edu/msg00097.html">a post by Andre van Tonder</a> on the Larceny mailing list that uses a very similar approach and <em>does</em> make a library out of it. This is done by adding two arguments to the expected ER-transformation function — one is a <code>rename</code> function (since the above method uses <code>syntax</code> it is limited to immediate identifiers), and the other is always passed as <code>free-identifier=?</code>. Such a compatibility library is, however, not the purpose of this post.</p>

<p>Finally, there is still a minor issue with this — PLT has an implicit <code>#%app</code> which is used wherever there are parentheses that stand for a function application — and in this code they are used unhygienically. This is usually not a noticeable problem, and if it is, you can add explicit <code>#%app</code>s. It might also be possible to find a more proper solution (e.g., use a hash table to keep track of lists that were disassembled by the client transformer), but at this point it might be better to just use the more natural <code>syntax-case</code> anyway.</p></div>
  <a class="more" href='/2009/05/explicit-renaming-macros-implicitly.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>18 May 2009</p></col-1>

<col-2>
  <h1><a href='/2009/05/the-two-state-solution-native-and-serializable-continuations-in-the-plt-web-server.html'>The Two State Solution: Native and Serializable Continuations in the PLT Web Server</a></h1>
  <div class="truncate">
<p><em>posted by Jay McCarthy</em></p>

<p>One of the annoyance of the <a href="http://docs.plt-scheme.org/web-server/stateless.html">stateless Web application</a> language that comes with the PLT Web Server is that you can&rsquo;t call <em>third-party higher-order library procedures with arguments that try to capture serializable continuations</em>. (I know, you try to do that all the time.) For example:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/list..rkt)._build-list))" style="color: inherit">build-list</a></span>
 <span class="mi">3</span>
 <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
   <span class="p">(</span><span class="n">call-with-serializable-current-continuation</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">(</span><span class="n"><a href="http://docs.racket-lang.org/reference/serialization.html#(def._((lib._racket/private/serialize..rkt)._serialize))" style="color: inherit">serialize</a></span> <span class="n">k</span><span class="p">)))))</span>
</pre></div>

</div>

<p>The problem is that the stateless language performs a transformation on your program to extract the continuations into a serializable representation. If you really need to do this, we&rsquo;ve developed a compromise called &ldquo;The Two State Solution&rdquo;: one state on the client and the other on the server. Only the third-party parts of the continuation (in this case, the code inside <code>build-list</code>) are stored on the server; everything else is shipped to the client. You just need to annotate your code slightly to indicate where the transition is:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="n">serial-&gt;native</span>
 <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/list..rkt)._build-list))" style="color: inherit">build-list</a></span>
  <span class="mi">3</span>
  <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">(</span><span class="n">native-&gt;serial</span>
     <span class="p">(</span><span class="n">call-with-serializable-current-continuation</span>
      <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="p">(</span><span class="n"><a href="http://docs.racket-lang.org/reference/serialization.html#(def._((lib._racket/private/serialize..rkt)._serialize))" style="color: inherit">serialize</a></span> <span class="n">k</span><span class="p">)))))))</span>
</pre></div>

</div>

<p><code>serial-&gt;native</code> signals the transition to the third-party and <code>native-&gt;serial</code> signals the transition back.</p>

<p>It is still a little annoying to find when you&rsquo;ve called these <em>third-party higher-order library procedures with arguments that try to capture serializable continuations</em>, so there&rsquo;s a simple macro that provides a transitioning wrapper for you:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="n">define-native</span> <span class="p">(</span><span class="n">build-list/native</span> <span class="k"><a href="http://docs.racket-lang.org/reference/stx-patterns.html#(form._((lib._racket/private/stxcase-scheme..rkt).__))" style="color: inherit">_</a></span> <span class="n">ho</span><span class="p">)</span> <span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/list..rkt)._build-list))" style="color: inherit">build-list</a></span><span class="p">)</span>
</pre></div>

</div>

<p>expands to:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="p">(</span><span class="n">build-list/native</span> <span class="n">fst</span> <span class="n">snd</span><span class="p">)</span>
  <span class="p">(</span><span class="n">serial-&gt;native</span>
   <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/pairs.html#(def._((lib._racket/private/list..rkt)._build-list))" style="color: inherit">build-list</a></span>
    <span class="n">fst</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="n">args</span>
      <span class="p">(</span><span class="n">native-&gt;serial</span>
       <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/procedures.html#(def._((lib._racket/private/base..rkt)._apply))" style="color: inherit">apply</a></span> <span class="n">snd</span> <span class="n">args</span><span class="p">))))))</span>
</pre></div>

</div>

<p>This new feature is documented in the <a href="http://faculty.cs.byu.edu/~jay/plt-doc/web-server/stateless.html#(part._.Serializable_.Continuations)">online manual</a>, of course.</p></div>
  <a class="more" href='/2009/05/the-two-state-solution-native-and-serializable-continuations-in-the-plt-web-server.html'>more →</a>
<col-2>

</row>

</article>
<article class="index" id="home">
<row>

<col-1>
  <p class='date-and-tags'>18 May 2009</p></col-1>

<col-2>
  <h1><a href='/2009/05/soft-state-in-the-plt-web-server.html'>Soft State in the PLT Web Server</a></h1>
  <div class="truncate">
<p><em>posted by Jay McCarthy</em></p>

<p>Many Web applications and network protocols have values in the continuation that are necessary to complete the computation, but that may be recomputed if they are not available. This is &ldquo;soft state&rdquo;.</p>

<p>For example, a Web application may cache a user&rsquo;s preferences from a database and deliver it to a Web browser as a hidden value; when the value is returned to the application in subsequent steps, it is used to customize the display. However, if the preferences were not available (or were corrupted in some way), the application could retrieve them from the database.</p>

<p>When using the PLT Web Server&rsquo;s native continuations, this roughly corresponds to the use of a <em>weak box</em>: a box that the GC is allowed to erase the contents of. When using the PLT Web Server&rsquo;s serializable continuations it roughly corresponds to a weak box and a <em>weak hash table</em> (that holds its keys weakly) to give the box a serializable value as an identifier.</p>

<p>This programming pattern is a bit difficult to get right. So, a library that implements it is now provided with PLT Scheme: <a href="http://faculty.cs.byu.edu/~jay/plt-doc/web-server/stateless.html#(part._.Soft_.State)"><code>web-server/lang/soft</code></a>.</p>

<p>Here&rsquo;s a trivial example:</p>

<div class="brush: racket">
 <div class="pygments">
  <pre><span></span><span class="kn">#lang </span><span class="nn">web-server</span>

<span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/require.html#(form._((lib._racket/private/base..rkt)._provide))" style="color: inherit">provide</a></span> <span class="n">interface-version</span> <span class="n">start</span><span class="p">)</span>
<span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="n">interface-version</span> <span class="o">'</span><span class="ss">stateless</span><span class="p">)</span>

<span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="n">softie</span>
  <span class="p">(</span><span class="n">soft-state</span>
   <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._printf))" style="color: inherit">printf</a></span> <span class="s2">"Doing a long computation...~n"</span><span class="p">)</span>
   <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/threads.html#(def._((quote._~23~25kernel)._sleep))" style="color: inherit">sleep</a></span> <span class="mi">1</span><span class="p">)))</span>

<span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/define.html#(form._((lib._racket/private/base..rkt)._define))" style="color: inherit">define</a></span> <span class="p">(</span><span class="n">start</span> <span class="n">req</span><span class="p">)</span>
  <span class="p">(</span><span class="n">soft-state-ref</span> <span class="n">softie</span><span class="p">)</span>
  <span class="p">(</span><span class="nb"><a href="http://docs.racket-lang.org/reference/Writing.html#(def._((quote._~23~25kernel)._printf))" style="color: inherit">printf</a></span> <span class="s2">"Done~n"</span><span class="p">)</span>
  <span class="p">(</span><span class="n">start</span>
   <span class="p">(</span><span class="n">send/suspend</span>
    <span class="p">(</span><span class="k"><a href="http://docs.racket-lang.org/reference/lambda.html#(form._((lib._racket/private/base..rkt)._lambda))" style="color: inherit">lambda</a></span> <span class="p">(</span><span class="n">k-url</span><span class="p">)</span>
      <span class="o">`</span><span class="p">(</span><span class="ss">html</span> <span class="p">(</span><span class="ss">body</span> <span class="p">(</span><span class="ss">a</span> <span class="p">([</span><span class="ss">href</span> <span class="o">,</span><span class="n">k-url</span><span class="p">])</span> <span class="s2">"Done"</span><span class="p">)))))))</span>
</pre></div>

</div></div>
  <a class="more" href='/2009/05/soft-state-in-the-plt-web-server.html'>more →</a>
<col-2>

</row>

</article>
<footer>
 <ul class="pagination">
  <li><a href="/index-9.html">
    <quote>&larr;</quote></a></li>
  <li><a href="/index.html">1</a></li>
  <li><a href="/index-2.html">2</a></li>
  <li><a href="/index-3.html">3</a></li>
  <li><a href="/index-4.html">4</a></li>
  <li><a href="/index-5.html">5</a></li>
  <li><a href="/index-6.html">6</a></li>
  <li><a href="/index-7.html">7</a></li>
  <li><a href="/index-8.html">8</a></li>
  <li><a href="/index-9.html">9</a></li>
  <li class="active"><a href="/index-10.html">10</a></li>
  <li><a href="/index-11.html">11</a></li>
  <li><a href="/index-12.html">12</a></li>
  <li><a href="/index-13.html">13</a></li>
  <li><a href="/index-14.html">14</a></li>
  <li><a href="/index-15.html">15</a></li>
  <li><a href="/index-11.html">
    <quote>&rarr;</quote></a></li></ul></footer>

<row class="one-column" id="bottom"><col-1></col-1><col-2>
<p>Made with <a href="https://github.com/greghendershott/frog">Frog</a>, a static-blog generator written in Racket.
<br /><a href="https://github.com/racket/racket-lang-org">Source code</a> for this blog.</col-2></row>
  </body>
</html>