<!DOCTYPE html>
<!--[if lt IE 7]> <html class="no-js ie6 oldie" lang="en"> <![endif]-->
<!--[if IE 7]>    <html class="no-js ie7 oldie" lang="en"> <![endif]-->
<!--[if IE 8]>    <html class="no-js ie8 oldie" lang="en"> <![endif]-->
<!--[if IE 9]>    <html class="no-js ie9" lang="en"> <![endif]-->
<!--[if gt IE 9]><!--> <html class="no-js" lang="en" itemscope itemtype="http://schema.org/Product"> <!--<![endif]-->
<html>
<head>
<title>Racket: git intro</title>
<meta name="generator" content="Racket" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta charset="utf-8" />
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<link rel="icon" href="https://racket-lang.org/plticon-1-2.ico" type="image/ico" />
<link rel="shortcut icon" href="https://racket-lang.org/plticon-1-2.ico" type="image/x-icon" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
<link rel="stylesheet" href="https://racket-lang.org/gumby-1-2.css" />
<script src="https://racket-lang.org/modernizr-2.6.2.min.js"></script>
<style type="text/css">
.p {
  display: block;
  margin: 1em 0;
  }
.code, .path, .man, pre {
  font-family: monospace;
  font-size: large;
  font-weight: bold;
  background-color: #eeeeee;
}
.code, .path, .man {
  white-space: nowrap;
}
.the_text a:link, .the_text a:visited {
  text-decoration: underline;
}
.the_text pre {
  margin-left: 2em;
  padding: 0.6em 0 0.6em 0.6em;
}
.the_text ul, .the_text ol, .the_text dl,
.the_text li, .the_text dt, .the_text dd {
  margin-top: 1em;
  margin-bottom: 1em;
}
</style>
</head>
<body><div class="navbar gumby-content" style="position: fixed;" gumby-fixed="top" id="nav1"><div class="row"><a class="toggle" gumby-trigger="#nav1 &gt; .row &gt; ul" href="#"><i class="icon-menu"></i></a>
<a class="four columns logo" href="https://racket-lang.org/"><img class="logo" src="https://racket-lang.org/logo-and-text-1-2.png" width="198" height="60" alt="Racket" /></a>
<span class="one colums"></span> <ul class="five columns">


</ul></div></div><div style="height: 60px;"></div>
<div class="bodycontent"><div class="row"><div class="ten columns centered"><ul><li><a href="#getting_git" style="text-decoration: none;">Getting git</a></li>
<li><a href="#general_git_setup" style="text-decoration: none;">General git setup</a></li>
<li><a href="#ssh_setup" style="text-decoration: none;">SSH setup</a></li>
<li><a href="#gitolite_the_server_s_gateway" style="text-decoration: none;">Gitolite: the server's gateway</a></li>
<li><a href="#a_very_quick_introduction_to_git" style="text-decoration: none;">A (very) quick introduction to git</a></li>
<li><a href="#clone_the_plt_repository" style="text-decoration: none;">Clone the PLT repository</a></li>
<li><a href="#start_working_git_commits_vs_subversion_commits" style="text-decoration: none;">Start working: git commits vs subversion commits</a></li>
<li><a href="#fooling_around_with_git" style="text-decoration: none;">Fooling around with git</a></li>
<li><a href="#the_staging_area" style="text-decoration: none;">The staging area</a></li>
<li><a href="#configuring_and_extending_git" style="text-decoration: none;">Configuring and extending git</a></li>
<li><a href="#user_repositories" style="text-decoration: none;">User repositories</a></li>
<li><a href="#working_with_git" style="text-decoration: none;">Working with git</a><ul style="font-size: small;"><li><a href="#working_with_git_basics" style="text-decoration: none;">Basics</a></li>
<li><a href="#working_with_git_concurrent_development" style="text-decoration: none;">Concurrent development</a></li>
<li><a href="#working_with_git_additional_forms_of_history_tweaking" style="text-decoration: none;">Additional forms of history tweaking</a></li>
<li><a href="#working_with_git_resetting_the_tree" style="text-decoration: none;">Resetting the tree</a></li>
<li><a href="#working_with_git_other_forms_of_reverting" style="text-decoration: none;">Other forms of reverting</a></li>
<li><a href="#working_with_git_dealing_with_conflicts" style="text-decoration: none;">Dealing with conflicts</a></li>
<li><a href="#working_with_git_copying_renaming_files" style="text-decoration: none;">Copying/renaming files</a></li>
<li><a href="#working_with_git_managing_branches" style="text-decoration: none;">Managing branches</a></li>
<li><a href="#working_with_git_using_branches" style="text-decoration: none;">Using branches</a></li>
<li><a href="#working_with_git_managing_remotes" style="text-decoration: none;">Managing remotes</a></li>
<li><a href="#working_with_git_using_private_repositories" style="text-decoration: none;">Using private repositories</a></li></ul></li>
<li><a href="#collaborating_with_others" style="text-decoration: none;">Collaborating with others</a><ul style="font-size: small;"><li><a href="#collaborating_with_others_patch_based_workflow_br_instructions_for_the_patch_sender_side" style="text-decoration: none;">Patch-based workflow<br />
— instructions for the patch sender side</a></li>
<li><a href="#collaborating_with_others_patch_based_workflow_br_instructions_for_the_patch_receiver_side" style="text-decoration: none;">Patch-based workflow<br />
— instructions for the patch receiver side</a></li>
<li><a href="#collaborating_with_others_making_a_private_repository_publicly_available" style="text-decoration: none;">Making a private repository publicly available</a></li>
<li><a href="#collaborating_with_others_pull_request_workflow" style="text-decoration: none;">Pull-request workflow</a></li>
<li><a href="#collaborating_with_others_pull_request_workflow_br_recipe_for_the_sender_side" style="text-decoration: none;">Pull-request workflow<br />
— recipe for the sender side</a></li>
<li><a href="#collaborating_with_others_pull_request_workflow_br_recipe_for_the_receiver_side" style="text-decoration: none;">Pull-request workflow<br />
— recipe for the receiver side</a></li>
<li><a href="#collaborating_with_others_merging_github_pull_requests" style="text-decoration: none;">Merging github pull-requests</a></li></ul></li>
<li><a href="#additional_resources" style="text-decoration: none;">Additional Resources</a></li></ul></div></div>

<div class="row"><div class="ten columns centered">
<div class="the_text">
<h2><a name="getting_git">Getting git</a></h2>
<div class="p">I <strong>highly</strong> recommend getting a new git installation.  Git itself is
pretty stable (that is, you probably will not run into bugs with whatever
version you have installed), but there are many usability related
improvements.  Specifically, I am using 1.7.x and it is likely that some
things in this document are specific to that version.</div>
<div class="p">You can <a href="http://git-scm.com/download">download a recent version</a>,
available in binary form for several popular platforms.  In addition to
these, you can get a build for
<ul><li>Ubuntu:
<pre>sudo add-apt-repository ppa:git-core/ppa
sudo apt-get update
sudo apt-get install git-core</pre></li>
<li>OSX using macports:
<pre>sudo port selfupdate
sudo port install git-core +svn</pre></li></ul>
(For OSX, you can also get <a href="http://gitx.frim.nl/"><span class="code">GitX</span></a> —
it's a good gui front-end for git, similar to <span class="code">gitk</span> and <span class="code">git gui</span>.)</div>
<div class="p">You can also build git from source is — here are the steps that I'm using to
install a new version:
<pre>GVER=1.7.10
BASE=http://git-core.googlecode.com/files
TARGET=/usr/local
cd /tmp; curl $BASE/git-$GVER.tar.gz | gunzip | tar xf -; cd git-$GVER
make prefix=$TARGET all &amp;&amp; sudo make prefix=$TARGET install</pre>
If you do this and you want the <a href="http://www.kernel.org/pub/software/scm/git/docs/">man pages</a> too, then getting the
pre-built man pages is the easiest route (building them requires some
“exotic” tools):
<pre>cd $TARGET/share/man
curl $BASE/git-manpages-$GVER.tar.gz | gunzip | sudo tar xf -</pre></div>

<h2><a name="general_git_setup" style="page-break-before: always;">General git setup</a></h2>
<div class="p">Commits to a git repository are done locally, so git needs to know who you
are.  (Unlike subversion, where you need to identify yourself to be able to
talk to the server, so the commit object is created there based on who you
authenticated as.)  To get git to know you, run the following two commands:
<pre>git config --global user.name &quot;My Name&quot;
git config --global user.email &quot;foo@racket-lang.org&quot;</pre>
This sets your <em>default</em> name and email for <em>all</em> repositories — it
stores this information in <span class="path">~/.gitconfig</span> which is the global
configuration file, used for such defaults.  You can edit this file directly
too — it is in a fairly obvious textual format.  There is a lot that can be
configured, see below for some of these (and see the <a href="http://www.kernel.org/pub/software/scm/git/docs/git-config.html"><span class="man">git-config</span></a> man
page for many more details).</div>
<div class="p">In addition to this file, each repository has its own configuration file
(located at <span class="path">.git/config</span>).  Whenever git needs to check some option, it
will use both the repository-specific config file (if you're in a repository)
and the global one.  The <span class="code">--global</span> flag above tells git to set the
option in the global file.  Note that a configuration file cannot be part of
the repository itself — so when you get a repository, you still need to do
any local configuration you want.  (This is intentional, since the
configuration file can specify various commands to run, so it avoids a major
security hazard.)</div>
<div class="p">Important: this sets your default identity name and email for <em>all</em>
repositories.  This may be a problem if you want to commit to different git
repositories under different identities.  See the section on customizing git
below for more details on this.</div>

<h2><a name="ssh_setup" style="page-break-before: always;">SSH setup</a></h2>
<div class="p">Since git is a distributed system, you can do everything locally on your own
repository, but obviously, the goal is to communicate with other people so
you'll need to push these changes somewhere else.  The most popular way to
communicate with remote repositories — including repositories on the PLT
server, is via ssh.  (Access is controlled via a tool called “gitolite” —
more on this below.)  The username and hostname of the server is
<span class="code">git@git.racket-lang.org</span> — and you should be able to connect to this account
using the ssh identity key that corresponds to the public key that you use
with the git server.  To try it, run
<pre>ssh git@git.racket-lang.org</pre>
and the server (gitolite, actually) should reply with information about your
current permissions.  The exact details of this is not important for now,
just the fact that you were able to connect and get some reply.</div>
<div class="p">Using an ssh configuration file (usually <span class="path">~/.ssh/config</span>), you
can set up a short name for the server.  For example, you can have this:
<pre>Host pltgit
  HostName git.racket-lang.org
  User git</pre>
and now you can simply use <span class="code">ssh pltgit info</span> instead of the last example:
<span class="code">ssh</span> will know that <span class="code">pltgit</span> is actually defined as
<span class="code">git@git.racket-lang.org</span>.</div>
<div class="p">This is the <strong>preferred</strong> way to set things up: besides being more
convenient in that you need to type less — it is also a useful extra level of
indirection, so if the server settings ever change (for example, we might
switch to a non-standard port number), you can simply edit your ssh config
file, and continue working as usual.  In addition, such a configuration is
needed if you created a specific ssh identity file to be used with git —
specifying an alternative identity file on the <span class="code">ssh</span> command line is
possible (an <span class="code">-i</span> flag, in the case of openssh), but remember that most
of your interactions with the remote server are done implicitly through git.
(It is possible to configure how git invokes ssh, but it is much easier to
just configure ssh).  In this case, you will have:
<pre>Host pltgit
  HostName git.racket-lang.org
  User git
  IdentityFile ~/.ssh/my-plt-git-identity-file</pre></div>
<div class="p">In addition to an ssh configuration file, git also has a way to create prefix
shorthands.  For example, if you use this configuration:
<pre>git config --global url.git@foo.org:.insteadOf foo:</pre>
then whenever git expects a repository URL, it will replace <span class="code">foo:</span>
with <span class="code">git@foo.org:</span>, for example:
<pre>git clone foo:bar</pre>
While it is possible to use this instead of an ssh config file to access the
<span class="code">plt</span> repository, the former is preferable.  The reason for that is that
you will also interact with the server directly via ssh commands (described
in the following section).  Keeping the alias in your ssh configuration means
that you will use the same alias for both <span class="code">git</span> commands and other
<span class="code">ssh</span>-based commands.  You may still want to use it for other servers,
specifically, here is a popular setup for github (this is configuration text
that you can paste into your global <span class="code">.gitconfig</span> file):
<pre>[url &quot;git://github.com/&quot;]
  insteadOf = github:
[url &quot;git@github.com:&quot;]
  pushInsteadOf = github:
  pushInsteadOf = git://github.com/</pre>
It translates <span class="code">github:</span> to a github read-only <span class="code">git://</span> URL, and it
translates pushes to the same prefix to use github's ssh URLs.  Note that it
also translates the read-only <span class="code">git://</span> url to an ssh url for pushing.
(The same setup can be used for <span class="code">gist.github.com</span>, to deal with github
gists via <span class="code">git</span>.)</div>

<h2><a name="gitolite_the_server_s_gateway" style="page-break-before: always;">Gitolite: the server's gateway</a></h2>
<div class="p">All access to the PLT server is done via <span class="code">ssh</span>, and this is where
gitolite comes in as the “who can do what” manager.  What actually happens on
the server is that no matter what command you're trying to run (as you
usually would, for example: <span class="code">ssh somewhere ls</span>), the server has settings
that make it always run its own command — and that is a gitolite script.  The
script knows the command that you were actually trying to run, and it will
reply based on that.  In the above ssh example, you're not specifying any
command (so if it wasn't for the pre-set gitolite script, you'd be asking for
a remote shell to start), and gitolite responds by telling you about your
permissions.</div>
<div class="p">This is actually the <span class="code">info</span> command, so you get the same reply with
<span class="code">ssh pltgit info</span>.  Again, this connects to ssh and tries to run
<span class="code">info</span>; gitolite sees that you're trying to run <span class="code">info</span>, and instead
of running it, it responds with that information.  There are a few additional
commands that you can use this way — these are all “meta commands” in the
sense that you're not interacting with a git process on the other end, but
rather get gitolite to perform various tasks on your behalf.  You can run the
<span class="code">help</span> command (<span class="code">ssh pltgit help</span>) to see a list of available
commands.  They are mostly useful in dealing with your private repositories
on the server, which will be discussed further below.</div>

<h2><a name="a_very_quick_introduction_to_git" style="page-break-before: always;">A (very) quick introduction to git</a></h2>
<div class="p">This is a quick description; see the last section for more resources
(specifically,
<a href="http://eagain.net/articles/git-for-computer-scientists/">Git for Computer Scientists</a> covers these basics well).  Understanding how
git models and stores data will make it significantly easier to work with it.</div>
<div class="p">A git repository is actually a database of a few kinds of objects, which form
a DAG.  There are only a few of these kinds of objects, and they are all
addressed by the SHA1 checksum of their contents.  You will generally see a
lot of these SHA1 strings (40 hexadecimal characters), since they form a kind
of a universal address for such objects.  (For convenience, any unique prefix
of a SHA1 can be used with git commands when you need to refer to it.)
Whenever the following descriptions mention a pointer — this is actually such
a SHA1 hash.</div>
<ul><li>A <em>blob</em> object is a generic container for any information, which
(usually) represents a file.  This object has no pointers to any other
objects.  It does not have anything except for the actual contents: no name,
permission bits, etc.</li>
<li>A <em>tree</em> object represents a directory hierarchy: it contains a list of
names, and for each name a pointer to the object that is its contents.  Some
of these will point at blobs (when the tree contains a file), and some of
these will point at other trees (when it contains a sub-tree).  (These
objects are similar to directories in a file system in that they contain all
“meta” information on files: their names and permission bits are kept here.)</li>
<li>A <em>commit</em> object represents a versioned snapshot of a tree, forming a
line of work.  It has the following bits of information:
<ul><li>tree: a pointer to the tree object that was committed</li>
<li>parent: a pointer to the previous commit, which this one revised</li>
<li>author: the identity of the commit author (name, email, date)</li>
<li>committer: the identity of the committer</li>
<li>the text of the commit message (which can be arbitrarily long)</li></ul>
The parent field is actually any number of parents: there will be no parents
if this is the first commit in the line of work, or more than one parent if
this is a “merge” commit that merges two lines of work.  Furthermore, there
is nothing that prevents a git repository from having completely separate
lines of work — in fact, you can have several independent projects contained
in your repository.
<br />
<small>(Note that git distinguishes the author of a commit from the person
who actually performed the commit, for example — a patch could be created
by X, and sent to Y to be committed.)</small></li>
<li>Finally, there is a <em>tag</em> object, which is very roughly a pointer to
another object (almost always a commit), and is not important for now.</li></ul>
<div class="p">The fact that all of these objects are addressed by the SHA1 hash of their
contents has some immediate important implications.</div>
<ul><li>Since SHA1 are cryptographic checksums, they can be considered <em>unique</em>
for all practical purposes.</li>
<li>The git repository is inherently hash-consed: you can never have “two
identical files” in git — because a file is stored at its SHA1 hash, two
identical files will always be stored once. (Note that the name of a file is
stored in the tree that contains it, so the SHA1 of the contents does not
depend on it.)  The same holds for two trees: if you have two identical
directories (same contents of files, same names, etc), then there will
actually be only one tree stored in the repository.</li>
<li>Furthermore, these addresses are actually global: any two repositories that
hold a file with the same contents will have it at the exact same SHA1 hash.
(For example, if I have a repository that contains several projects, and
each project contains several copies of the same LGPL text, then I'll have
only a single blob object with that contents.)  This is not only making the
store efficient, it also makes it possible to refer to an object by its hash
— for example, you can refer to the SHA1 of a specific file at a specific
version in an email, and this will have the exact same meaning for anyone
that reads the file (eg, anyone can run <span class="code">git show <i>SHA1</i></span> to see that
file).  (This does require that the readers have the actual object in their
repository, of course — but no mistakes can happen, statistically speaking.)</li>
<li>This holds for commits too: since a commit has the SHA1 of the tree it
points to, then the commit SHA1 depends on the tree it points to.  More
importantly, since a commit object has the SHA1 of its parent(s), then the
commit depends on them.  This means that “replaying” a number of commits on
a different parent commit (eg, when doing a “rebase”) will always result in
a separate line of commit objects.  These SHA1s are also global, meaning
that talking about a specific revision by its SHA1 will always refer to it
unambiguously (as long as others have that object in their repositories).</li>
<li>By itself, this kind of storage <em>cannot</em> have any reference cycle.  (At
least there is no practical way to get one.)  The storage is therefore
inherently a DAG.  In addition to this object store, git does have a number
of external references (eg, a branch is actually a pointer to a SHA1) — and
those could be arbitrary, but the object storage itself cannot have cycles.</li>
<li>The fact that a commit has a pointer to a tree is what makes git keep
revisions of the whole tree — a commit cannot mark a change to a subtree.
(At least not with the usual higher-level commands that git implements.)</li></ul>
<div class="p">On top of this object store, there is a layer of meta-information about it.
The most important component here are branches (and tags).  A branch is
basically a file that has the SHA1 of a specific commit (for example, your
<span class="code">master</span> branch is a SHA1 that is stored in
<span class="path">.git/refs/heads/master</span>).  This is what makes branch creation extremely
cheap: all you need to do is create a new file with the SHA1.</div>
<div class="p">In addition, the <span class="code">HEAD</span> (where your working directory is currently), will
usually have a symbolic reference rather than a SHA1 (you can see this
symbolic reference in the <span class="path">.git/HEAD</span> file, which should usually look
like <span class="code">ref: refs/heads/<i>branch-name</i></span>).  When you commit a new version,
a new commit object is created, and the branch that the <span class="code">HEAD</span> points to
is updated.  It is also possible to checkout a specific SHA1 of a commit
directly — the result of this is called “detached HEAD”, since the HEAD is
not a symbolic reference.  The possible danger in doing this is that <span class="code">git
commit</span> will create new commits that are derived from the one you're on, but
no branch is updated; if you later checkout something else, no reference is
left to your new commit which means that it could be lost now.  For this
reason, if you checkout a SHA1 directly, git will spit out a detailed
warning, including instructions on how you could name your current position
(create a branch that points there).</div>
<div class="p">Tags come in two flavors: lightweight tags are SHA1 pointers like branches.
The problem with this is that such a tag could easily move to a different
commit, which is considered bad practice.  For this reason, there are also
“annotated tags”, which are tag objects that are created in the object store.
These tags contain information that is similar to a commit (there's the
tagger's identity, the commit that it points to, and a log message) — and
they are reliable since you can refer to their SHA1.  In this case, the
symbolic reference for such a tag (its name) will point to the tag object in
the store (it is also possible to move it, but that would also be bad
practice).  Furthermore, tags (of both kinds) can point to any object in the
store — they can point to a tree or even to a specific blob.  This is
sometimes used to store meta-information (eg, web pages) inside the
repository.  (The repository for git itself has a tag that points to a blob
holding the maintainer's GPG key.)</div>
<div class="p">Note that all of this is under a more high level of managing information
between branches and repositories, with push/pull being the main operations
at that level.  A high-level overview (more below):
<ul><li>a branch is a line of development, represented as a pointer to the commit
at its tip;</li>
<li>branches can be organized into hierarchies using <span class="path">/</span> as a separator;</li>
<li>some branches are local, and some are remote — remote ones are named
<span class="path">remotes/origin/<i>branch</i></span>;</li>
<li>local branches are represented as files in
<span class="path">.git/refs/heads/<i>branch</i></span> and remote ones are in
<span class="path">.git/refs/remotes/origin/<i>branch</i></span>;</li>
<li><span class="code">origin</span> is just the conventional name for the original repository you
cloned — later on you can add new remote repositories so you can push and
pull to/from them conveniently;</li>
<li>some local branches are set to track remote ones, usually (but not
necessarily) the two will have the same name;</li>
<li>you can also have local branches to track other local branches (with
pushing and pulling happening inside your repository);</li>
<li><span class="code">git fetch</span> is used to update your remote branches — ie, connect to
the remote repository, get new commits (and the required parents and
trees), and update your remote branch with the new tips;</li>
<li><span class="code">git merge</span> and <span class="code">git rebase</span> are used to update one branch with
commits on another;</li>
<li><span class="code">git pull</span> is, roughly speaking, a convenient way to do a fetch
followed by a merge (or a rebase, when used with <span class="code">--rebase</span>).</li></ul></div>
<div class="p">There are several git tools that are relevant here.  These are <em>not</em>
commands that you need to know for everyday use — so you can ignore this
part.  It's only relevant if you want to see more of the low level structure
(or maybe if you want to write code that interfaces with a repository at this
level).</div>
<dl><dt><span class="code">git show <i>SHA1</i></span></dt>
<dd>Show the object, in some appropriate way based on the type of the object.
(For blobs it shows the contents, for trees you get a listing of its
contents, and for commits it shows the log and the patch.)</dd>
<dt><span class="code">git cat-file {-t | -s | <i>type</i> | -p} <i>SHA1</i></span></dt>
<dd>A more low-level command that tells you the type/size of an object (<span class="code">-t</span>
and <span class="code">-s</span>), or shows the contents of an object as-is when given a type.
<span class="code">-p</span> will “pretty-print” the object, eg, showing the contents of a tree
object instead of dumping its binary encoding.</dd>
<dt><span class="code">git gc</span></dt>
<dd>Starts from a rootset holding all known references (branches, tags, etc),
and collects dangling objects.  Such objects are generated due to various
reasons — for example, rebasing means that new commits are generated, and
the old ones are kept around.  Actually, this will not remove recently
referenced objects — there is a protection mechanism that keeps them around
for a while, so if you somehow mess things up there is still a way to
recover.</dd>
<dt><span class="code">git fsck</span></dt>
<dd>Does a “file system check” on the repository.</dd>
<dt><span class="code">git rev-parse <i>symbolic-name</i></span></dt>
<dd>Prints out the full SHA1 of a symbolic name (eg, a branch name or a tag
name).  Will also print out the SHA1 given a possibly short prefix of one.
(Actually, this command can also show other information about a repository,
which makes it an important entry point for programs that deal with a
repository.)</dd></dl>

<h2><a name="clone_the_plt_repository" style="page-break-before: always;">Clone the PLT repository</a></h2>
<div class="p">As you probably know by now, in git you don't checkout a repository — you
clone it, getting a copy of the complete repository you cloned.  This
includes the object store and the various references (branches and tags).
There are several ways to get the PLT repository, but the one that is
relevant to work on it is to do so through ssh — since this allows pushing
changes back to the server.  (It is also possible to clone from one place and
push to another, but if you start with cloning through ssh your clone will be
already set up to push changes back.)  The information that gitolite gives
you (with <span class="code">ssh pltgit info</span>, assuming the above ssh setup) includes two
repositories that you have write access to: <span class="code">plt</span> is the main repository,
and <span class="code">play</span> is setup similarly (intended to try things out, see the
“Fooling around” section below).  To get the main repository, run
<pre>git clone pltgit:plt</pre>
which will create a <span class="path">plt</span> directory with your new clone.  You can now
start working in this directory.</div>
<div class="p">The repository is also available from other sources, some can be used for
read-only cloning:
<ul><li><span class="code">git clone git://git.racket-lang.org/plt.git</span><br />
cloning the repository using git's own network protocol</li>
<li><span class="code">git clone http://git.racket-lang.org/plt.git</span><br />
clone the repository over http</li>
<li><span class="code">git clone http://github.com/plt/racket.git</span><br />
this uses the repository mirror on github, which is automatically kept in
sync (you can also use <span class="code">https://...</span>)</li></ul>
and some present a web interface for additional information:
<ul><li><span class="code"><a href="http://git.racket-lang.org/plt">http://git.racket-lang.org/plt</a></span><br />
a web interface to inspect the repository</li>
<li><span class="code"><a href="https://github.com/plt/racket">https://github.com/plt/racket</a></span><br />
github's fancier web interface</li></ul></div>

<h2><a name="start_working_git_commits_vs_subversion_commits" style="page-break-before: always;">Start working: git commits vs subversion commits</a></h2>
<div class="p">As seen in the previous section, you start with
<pre>git clone pltgit:plt; cd plt</pre>
And now you get to actually do some work.</div>
<div class="p">For the normal cycle of operations, working with git is not all that
different from working with subversion — you would change some files, and
then:
<pre>git commit some/paths</pre>
or
<pre>git commit some/paths -m &quot;add some feature&quot; -m &quot;requires another&quot;</pre>
only now the commit lives only in <strong>your clone only</strong>, not in the server
(which is why committing is blindingly fast, not requiring a network
connection).  To push your commits to the server, run <span class="code">git push</span>, and to
pull updates from the server run <span class="code">git pull</span>.  This is obviously very much
oversimplifying the process: mainly neglecting to talk about updates on the
server when you already have local changes.  (See below for a more detailed
explanation.)  Note that in these examples I'm explicitly specifying the
paths to commit, either the files that you want to commit or a directory
where you want to commit all changes.  See the section below on the “staging
area” for more details.</div>
<div class="p">One major difference to keep in mind is that git commits are <strong>not</strong>
like subversion commits.  (This is confusing since many places that discuss
the difference between the two and/or try to teach git to subversion users
almost always work under the assumption that commits in the two systems are
the same.)  The thing is that git commits are done at a finer level than
subversion commits — since a commit is done locally and not on the server.
To really imitate how subversion works, you would push all commits right
after you create them — essentially equating commits with pushes, which is
how you work with a subversion repository.  But by just <em>not</em> doing this,
you will immediately get some of the benefits that git gives you.  So a
better way to think about it is: in git you commit at points that make sense
for the respective changes, usually at a finer level than subversion commits.
Then, you push back a bunch of commits to the server — whether one or a
hundred.  The point where you push your changes to the server is effectively
the point where you decide that you're in a good enough state to make your
work public.</div>
<div class="p">Incidentally, following this intuition, drdr is running a build for every
push to the server — not for every commit.  When you push to the server, it
will tell you which push number this is — these numbers are going to be used
by drdr, and they (very!) roughly correspond to subversion commits.
(Currently, every push gets a number, but in the future this might be used
only for pushes to the master branch.)  There's no plan at the moment to use
these numbers for anything else.</div>

<h2><a name="fooling_around_with_git" style="page-break-before: always;">Fooling around with git</a></h2>
<div class="p">Experimenting with git is easy to do, and the server is set up to make it
even easier.  You can use one of the following ways to experiment safely with
the main repository:
<ul><li>There is a <span class="code">play</span> repository on the server.  This repository is very
similar to the <span class="code">plt</span> repository, and it is set up in the same way that
<span class="code">plt</span> is.  Feel free to destroy it in any way you want, even if it
becomes unusable, it's easy to just recreate it.</li>
<li>You can create (and later delete) your own repositories — including making
your own copy of the main repository, an operation that is known as
“fork”.  Your fork will be created efficiently (ie, creating a fork of the
<span class="code">plt</span> repository is cheap), but any changes made to it will not affect
the main repository.  A fork is created with a gitolite command, and once
it's there you can clone it and eventually delete it.  Here are the
relevant commands — use your actual username in place of <span class="code">$user</span> (or
have <span class="code">$user</span> set to your username):
<ol><li><span class="code">ssh pltgit fork plt $user/myplt</span></li>
<li><span class="code">git clone pltgit:$user/myplt</span></li>
<li>...play with this clone, push, pull, etc...</li>
<li><span class="code">ssh pltgit delete $user/myplt</span></li></ol>
More on user repositories below.</li></ul></div>

<h2><a name="the_staging_area" style="page-break-before: always;">The staging area</a></h2>
<div class="p">Something that tends to confuse people is git's “staging area”.  This is a
concept that is unique to git — roughly speaking, you can have three versions
of a tree:
<ul><li>the files that you actually see (and edit) — the working directory,</li>
<li>another is the staging area which you add stuff to from the working tree
using <span class="code">git add</span>,</li>
<li>and then there is the tree that is in the HEAD with all prior versions.</li></ul></div>
<div class="p">The thing that can confuse here is that when you <span class="code">git add some/file</span> for
a file that you edited (or created) and then edit it further, then the
version will get committed by a plain <span class="code">git commit</span> will be the one that
was added.  Note that <span class="code">git status</span> will tell you which modifications are
in the staging area waiting to be committed, and which modifications are in
your working directory — in the given example, it will tell you that
<span class="path">some/file</span> is in both.</div>
<div class="p">The staging area can be useful at times, but most likely at the beginning
stages you will want to just avoid it.  The good news is that it is easy to
do so.</div>
<dl><dt><strong>Avoid the <span class="code">-a</span> flag</strong>.</dt>
<dd><div class="p">Before we see how to ignore it, note that there are many web pages that
will tell you to use <span class="code">-a</span> with the commit command.  This will make git
commit all changes to tracked files — <strong>including tracked files that
are outside of your current directory</strong>, and this can make you commit
changes that you didn't intend to commit.</div></dd>
<dt><strong>Always specify a path to <span class="code">git commit</span></strong>.</dt>
<dd><div class="p">The easiest way to avoid the staging area is to specify the path(s) to
what you want to commit, possibly <span class="path">.</span> for all changes in the current
directory (and below).  Specifying a path this way will make
<span class="code">git commit</span> behave very similarly to subversion: tracked files that
were modified will get committed, and added files (with <span class="code">git add</span>)
that are listed in the paths-to-be-committed are also committed.  Tracked
and added files that are not listed (and not in a specified subdirectory)
are left as-is.  So, if you had a habit of doing this with subversion
(<span class="code">svn commit .</span>), then git will essentially do the same.  You will
still need to use <span class="code">git add</span> for newly created files, but this is
essentially the same as with subversion.</div>
<div class="p">It is also possible to “make up new git commands” for yourself.  See the
following section on the subject: it adds a new <span class="code">git ci</span> command that
passes <span class="path">.</span> to <span class="code">git commit</span>, similarly to what <span class="code">svn ci</span> does
by default.</div></dd>
<dt>It is a good idea to <strong>avoid using the <span class="code">-m</span> flag</strong>, until you're
more comfortable with git.</dt>
<dd><div class="p">Let git pop up an editor to write the commit log: the file that you will
edit will list the changes that you are about to commit as well as changes
that you are not going to commit.  Glancing through it, you will see
changes that you missed, furthermore, the paths are relative which makes
it easy to quickly distinguish paths in the current directory and outside
of it (the latter will begin with <span class="path">../</span>).  If you see any problems,
just make sure that you have no commit message in the editor and when you
quit it git will abort the commit (same as subversion).</div></dd>
<dt><strong>Don't push out all commits to the server immediately</strong>.</dt>
<dd><div class="p">Even if you did commit something by mistake, it is possible to undo the
commit — run <span class="code">git reset HEAD^</span>, which will undo the last commit (it
moves the branch to the parent commit), and the changes that are no longer
committed will be left in your working directory, so you get to try the
commit again.  Note that this is possible <strong>only if you didn't push
out the commit</strong> that you're undoing — if you did, then the server will
later not allow you to push changes that are not strict extensions of what
it has (since this is likely to confuse other people who already got your
commit).</div>
<div class="p">So in general, remember that you can commit often, and commit when it
makes sense to do so, and push commits out only when you're done with
whatever you were working on.  Consider your local git history as
something that you have full control over: you can undo commits and redo
them (in fact, <span class="code">git commit --amend</span> does just that: undo the last
commit, and combine it with new changes — it's a solution for “oops
commits”), you can rebase them, and you can just throw away everything and
start from scratch.  But when you do push your history out, the party is
over, and any mistakes will need to be rectified in further commits (eg,
you can no longer use that <span class="code">--amend</span> flag, you have to do an “oops
commit”).</div>
<div class="p">(BTW, strictly speaking, it is only the policy on our server that forbids
such rewritten history — since this is likely to be a mistake for now, and
if it happens most people will be confused about what needs to be done.)</div>
<div class="p">Also, as said above, pushing all commits immediately means that you're
essentially restricting yourself to the same mode of operation as
subversion.  Same mode, but more complicated — and you won't enjoy any of
the benefits, which will guarantee that you will suffer.</div></dd></dl>

<h2><a name="configuring_and_extending_git" style="page-break-before: always;">Configuring and extending git</a></h2>
<div class="p">As mentioned above, git uses several configuration files that customize
various aspects.  The two important ones are your global file
(<span class="path">~/.gitconfig</span>) and a per-repository file in <span class="path">.git/config</span> at the
repository root — whenever a value is needed, git will first consult the
repository configuration, and if the option is not set there it will try your
global version.  (It will also look at a system-wide configuration, but this
is irrelevant here.)  Configuration options names are separated by a
<span class="path">.</span>, and configuration files have a simple syntax, with <span class="code">foo.bar</span>
option listed as a <span class="code">bar = some value</span> line in a <span class="code">[foo]</span> section.
Note that you can set <em>any</em> configuration you want to, no restrictions.
This can be useful for customizing various extensions, including scripts that
you may want to write (for example, the git server has a script that checks
the <span class="code">hooks.counter</span> option to know if it should keep track of pushes).
This is facilitated by several options to <span class="code">git config</span> which makes it
easy to query configurations from scripts etc.</div>
<div class="p">To edit your configuration options you can either use the <span class="code">git config</span>
command, or you can edit the file directly.  When <span class="code">git config</span> changes
the file it rewrites only part of the file and leaves the rest untouched,
which conveniently leaves your own format and any comments you might want to
include.  To set a value through the command and then get it:
<pre>git config foo.bar some-value
git config foo.bar</pre>
and you can add a <span class="code">--global</span> flag to either form to use only your global
configuration file.  There are many other options — for dealing with keys
that must be booleans or integers, for keys with multiple values, etc.  The
<a href="http://www.kernel.org/pub/software/scm/git/docs/git-config.html"><span class="man">git-config</span></a> man page will tell you much more on this.</div>
<div class="p">The man page also lists the configuration options that customize various
functionalities.  Here are some important ones that you should consider
setting (each listed as a command that sets it globally):
<ul><li><pre style="margin-left: 0;">git config --global user.name &quot;My Name&quot;
git config --global user.email &quot;foo@git.racket-lang.org&quot;</pre>
<div class="p">As said in the beginning of this text, you will likely want to set a
default username and email for yourself.  But note that if you do set
this globally, it will be your default identity for all repositories.
This makes sense only if you commit to PLT-related repositories, but it
can be confusing if you're also committing to some other non-PLT-related
repositories and want to commit under a different email (or name) — for
example, you may want to commit to a public project with a gmail
address, and to a departmental repository with your
<span class="code">foo@cs.bar.edu</span> email.</div>
<div class="p">You could set the racket-lang.org identity locally in your PLT clone or
you could set your other identity in the other repository, but in any
case you should be aware of this and avoid letting git guess your name
and email.  (Some confusion is likely to happen anyway, and git has a
way to “map” some name/email to another when mistakes happen.)</div></li>
<li><pre style="margin-left: 0;">git config --global push.default simple</pre>
<div class="p">By default, when you run <span class="code">git push</span>, git will push all branches that
correspond to branches in the remote repository.  This can be surprising
if you're working on several branches since it will push them all out.
Setting this option to <span class="code">upstream</span> will make git push the current
branch to the branch it is tracking, and on newer git versions setting
it to <span class="code">simple</span> is similar except that it will refuse to create a
remote branch.  (And on really old systems, you should use a value of
<span class="code">tracking</span>, which is the old and now-deprecated synonym for
<span class="code">upstream</span>.)</div>
<div class="p">Another option for this is <span class="code">current</span>, which makes <span class="code">git push</span>
always push the current branch to the remote it was cloned from.  This
is convenient in that you never need to set up how local branches track
remote ones — it's as if all local branches <em>always</em> track all remote
branches under the same name.  For example, after you clone an empty
repository (see the user repositories section below), a <span class="code">git push</span>
will push a master branch remotely — whereas with <span class="code">tracking</span> you
need to have the first push explicitly specify the branch to push,
usually <span class="code">git push origin master</span> (this sets things up so later you
can just run <span class="code">git push</span>).  However, using <span class="code">current</span> you can no
longer push from one local branch to another local branch it is set to
track.</div>
<div class="p">So a possible conclusion here is that you should use <span class="code">tracking</span>,
unless you plan on branches to always track remote branches by the same
name.  <span class="code">tracking</span> is often preferred over <span class="code">current</span>.</div></li>
<li><pre style="margin-left: 0;">git config --global core.excludesfile &quot;~/.gitignore&quot;</pre>
<div class="p">You'll probably want to always ignore a number of common patterns, like
backup files or OSX <span class="path">.DS_Store</span> files.  To do this, you first set a
default file as shown here (note that <span class="path">~</span> is quoted, and git will
expand it to whatever your home directory is).  If you have this
setting, you can then create a file at this path with patterns for files
that you always want to ignore.  This file has shell-patterns (and
possibly <span class="code">#</span>-comments) — for example:
<pre># backups
*~
# autosaves (note the #-quoting)
\#*
# OSX junk
.DS_Store</pre>
(See the <a href="http://www.kernel.org/pub/software/scm/git/docs/gitignore.html"><span class="man">gitignore</span></a> man page for a few more details.)</div>
<div class="p">In addition to this, git repositories can have their own
<span class="path">.gitignore</span> files (unlike <span class="path">.git/config</span> files), which are
combined hierarchically together with this global option.  In fact, you
don't really need to set the above ignores for the PLT repository since
they're already included in its toplevel <span class="path">.gitignore</span> file — but
doing so is still a good idea since you're likely to work on other
repositories too.</div></li>
<li><pre style="margin-left: 0;">git config --global core.editor emacs
git config --global core.pager less</pre>
<div class="p">These two settings are used to tell git which command to use for editing
log messages, and which command is used to paginate output.  (The former
might already be set in your environment as the value of the
<span class="code">EDITOR</span> variable.)  If you set the latter to <span class="code">cat</span>, git will
just spill all output directly.  In addition to these, you can also
control which individual commands use a pager, for example, to disable
the pager for <span class="code">git log</span>, you can do this:
<pre>git config --global pager.log false</pre></div></li>
<li><pre style="margin-left: 0;">git config --global color.ui auto
<i>...</i>
git config --global color.branch.current yellow red bold
git config --global color.branch.local   yellow
git config --global color.branch.remote  green
<i>...</i></pre>
<div class="p">These settings control how git uses colors: whether it shows them, and
which colors it will use for various outputs.  There are many of these
settings, which you can find in the <a href="http://www.kernel.org/pub/software/scm/git/docs/git-config.html"><span class="man">git-config</span></a> man page.</div></li>
<li><div class="p"><span class="code">remote.origin.*</span>, <span class="code">branch.master.*</span></div>
<div class="p">Git keeps track of what the <span class="code">origin</span> repository and how branches
track other branches in the configuration file too.  (You will have such
entries for all known remote repositories and branches.)  Usually you
set these values (often implicitly) via various git commands — but you
might want to look in your configuration file if you want to tweak
things yourself.  Note that for configuration names with more than two
parts, the section name will something like <span class="code">[remote &quot;origin&quot;]</span>.</div></li>
<li><div class="p"><span class="code">sendemail.identity</span>, <span class="code">sendemail.from</span>,
<span class="code">sendemail.bcc</span>, <span class="code">sendemail.suppresscc</span>, ...</div>
<div class="p">These settings configure <span class="code">git send-email</span>, which is used to send
patches from your repository elsewhere.  You will probably want to
customize them if/when you get to use this facility often.  (See
below.)</div></li></ul></div>
<div class="p">In addition to these settings, you can extend git with your own aliases and
commands.  Aliases are stored in your git configuration — so you can use
<span class="code">git config</span> to create an alias, for example, <pre>git config --global
alias.up &quot;pull --stat --all&quot;</pre> creates a global <span class="code">git up</span> command which is
actually a short alias for running <span class="code">git pull --stat --all</span>.</div>
<div class="p"><strong>Notes about aliases:</strong>
<ul><li>To edit aliases, it is more convenient to edit your configuration file
directly.</li>
<li>Since aliases are stored in git configuration files, they can be made
local to each repository.</li>
<li>When command-line arguments are given to the alias, they will be appended
to the alias text.</li>
<li>Aliases <em>cannot</em> override git commands; this is intentional, to avoid
scripts breaking due to modified commands.</li>
<li>An alias that starts with a <span class="code">!</span> character will be run as a shell
command.  For example, you can use
<pre>k = &quot;!gitk -d&quot;</pre>
to make <span class="code">git k</span> run the gitk program with the <span class="code">-d</span> flag.</li>
<li>Some aliases that I find useful are:
<pre># satisfy the &quot;up instinct&quot;
up = pull --ff-only --stat --all
# quick status, similar to what subversion shows
st = status -s
# we will be dealing more with branches
br = branch</pre></li></ul></div>
<div class="p">In addition to aliases, you can create new git commands using a script that
is called <span class="code">git-<i>something</i></span> somewhere in your path.  (Note that these
cannot override known git commands either.)  Such commands will be available
as <span class="code">git <i>something</i></span>.  One use for this is using our facility for
managing file properties — the <span class="path">collects/meta/props</span> program.  To do
this put this in a file called <span class="code">git-prop</span> somewhere in your PATH, for
example, <span class="path">~/bin/git-prop</span>:
<pre>#!/bin/sh
top=&quot;$(git rev-parse --show-toplevel)&quot; || exit 1
exec &quot;$top/collects/meta/props&quot; &quot;$@&quot;</pre>
then run <span class="code">chmod +x ~/bin/git-prop</span>, and you can now use it as a git
command (try <span class="code">git prop -h</span>).  Note the use of the <span class="code">rev-parse</span>
command: it will display the repository root, which means that you will get
to run the props script of the repository you're <em>currently</em> using.
(There are many git commands that are useful for such scripts.)</div>
<div class="p">Another useful script is <span class="code">git-ci</span> which mimics the behavior of
<span class="code">svn commit</span> (avoiding confusion with the staging area).  As said above,
a good way to achieve this is to specify the current directory (<span class="path">.</span>) if
you don't specify any other path.  If you save this as <span class="path">git-ci</span>, you
will get a <span class="code">git ci</span> that does just that:
<pre>#!/bin/sh
add_dot=yes; for p; do if [ -e &quot;$p&quot; ]; then add_dot=no; fi; done
if [ -e &quot;$(git rev-parse --git-dir)/MERGE_HEAD&quot; ]; then add_dot=no; fi
if [ -d &quot;$(git rev-parse --git-dir)/rebase-apply&quot; ]; then add_dot=no; fi
if [ $add_dot = yes ]; then git commit . &quot;$@&quot;; else git commit &quot;$@&quot;; fi</pre>
This small script will basically check all arguments and see if one is an
existing path (or if you're resolving a merge).  If none are, it adds
<span class="path">.</span> as a first argument (this avoids confusing it as a value for some
flag).  Note that this is not completely foolproof: for example, if you'll
use the <span class="code">-m .</span> hack, it will assume that you did specify a path.  (But
you should really avoid such log messages.)</div>

<h2><a name="user_repositories" style="page-break-before: always;">User repositories</a></h2>
<div class="p">As mentioned above, the PLT server allows you to create your own
repositories.  Repositories on the server can be organized in a nested
directory structure, and you “own” all repositories that are in a directory
with your username.  The gitolite <span class="code">info</span> command that was mentioned above
shows you this with a <span class="code">C CREATER/.*</span> line: this means that you can create
any repository if it is in a subdirectory with your username.  (In this
discussion, “the server” is actually the gitolite script that runs on the
server.)</div>
<div class="p">Any git operation that you do on a repository that you own which does not
exist will make the server create it for you — for example, if you clone such
a repository.  To run these examples use your git username instead of
<span class="code">$user</span>, or simply set the <span class="code">user</span> variable in your shell (as this
example shows) — this is only to make copy-pasting easy, of course.
<pre>user=eli # your own username here
git clone pltgit:$user/foo</pre>
(You are encouraged to run these commands — at the end of this section you'll
see how you can clean things up.)</div>
<div class="p">What will happen now is (a) git will initialize a <span class="path">foo</span> repository for
you, (b) it will connect to the server to clone its contents, (c) the server
will notice that it doesn't exist so it will create it, (d) your git process
will clone the empty result.  Because the remote repository is empty, git
will complain that “You appear to have cloned an empty repository” — this is
expected, so you shouldn't worry about it.  Once you have your (empty) clone,
you can populate it as usual, then push the new content back to the server's
copy:
<pre>cd foo
<i>...create some files...</i>
git add .
git commit -m &quot;initial content&quot;
git push origin master</pre>
Note that the last command explicitly names the branch to push over — once
this push is done, git will remember this relation and further pushes can be
done with just <span class="code">git push</span>.  If you happen to forget this and use
<span class="code">git push</span>, then git will not push anything, and it will tell you about
it and suggest specifying a branch.  On the other hand, if you set the
<span class="code">push.default</span> configuration option to <span class="code">current</span> (as described in the
customization section above), then even in this first push you can just run
<span class="code">git push</span> since git assumes that you always want local branches to
correspond to remote branches by the same name.</div>
<div class="p">Instead of cloning a repository to create a new one, you could also start
with an existing repository and simply push it to a yet-to-exist repository
on the server.  Again, the server will see that it doesn't exist and will
create it for you (provided that it is in your directory).  To continue the
above example, I could now create a new repository from <span class="code">foo</span>:
<pre># (still in the foo directory)
git push pltgit:$user/bar</pre></div>
<div class="p">There is, however, an issue of efficiency here: with this last command I just
created a second copy of it all.  This could be problematic if you have a
large repository (eg, a copy of the <span class="code">plt</span> repository).  (Note that with
subversion this is the only way to do things, but there you would create
copies inside the tree, which subversion optimizes.)  One nice feature of git
is that creating a clone of a repository on the same filesystem will use
hard-links for the clone, which makes the clone use very little additional
space.  But the problem is that you have no access to the PLT server.  The
solution here is in the form of a gitolite <span class="code">fork</span> command (this is
actually our own extension) — this command will create a clone on the server,
starting from a specified repository.  I could therefore create my <span class="path">bar</span>
repository as a copy of <span class="path">foo</span> with the following:
<pre>ssh pltgit fork $user/foo $user/bar</pre>
(Note that if you follow these examples and you already have <span class="path">bar</span>, the
server will tell you about it.)  The result is a <span class="path">$user/bar</span> repository
that was cloned from <span class="path">$user/foo</span>, and the two share their store using
hard links.  If the two repositories are updated with identical content, the
new content will not be shared, but for a large repository like the <span class="code">plt</span>
repository you still get the benefit of having the bulk of the data shared
(the complete store, at the time of forking).  To get a feeling for how fast
this is, you can now clone the <span class="code">plt</span> repository to your own private copy:
<pre>ssh pltgit fork plt $user/myplt</pre>
This would seem suspiciously fast for such a large repository — but this
repository has most of the data packed (objects in the store are put in large
“pack files”), so there are not too many files, and the server-side cloning
basically created hard links to these files.  The result is fast, efficient
(even in speed: when you interact with your clone, files are likely to be
paged in memory), and cheap.</div>
<div class="p">As we've seen above, the gitolite <span class="code">info</span> command lists the permissions
that you have, but it doesn't show you the actual repositories.  For this,
there is an <span class="code">expand</span> command.  (Yes, this is not a great name; it's
related to how gitolite was intended to be used.  Remember that there is also
a <span class="code">help</span> command that describes the available gitolite commands.)  When
you run the expand command — <span class="code">ssh pltgit expand</span> — you get a listing of
all of the repositories that you can access, each with an indication of read
permissions (<span class="code">R</span>) or write permission (<span class="code">W</span>).  A <span class="code">@</span> indicator
means that you have the respective permissions because it is allowed for all
users.  Each repository is also listed with its owner, or <span class="code">&lt;gitolite&gt;</span> in
case it is a globally configured repository.</div>
<div class="p">Some of the gitolite commands are used to configure your repositories — you
can only use these with repositories that you own.
<ul><li><span class="code">getperms</span> and <span class="code">setperms</span> — these are used to get or set
permissions for your repositories.  The first will print the current
permissions (which will be initially empty), and the second will read the
permissions on its input and set them.  The format of the permissions is
simple: each line begins with an <span class="code">R</span> or <span class="code">RW</span>, and then the
usernames that this permission applies to.  You can use the magic username
<span class="code">@all</span> to grant access to everyone in the system.  For example, to
grant read permissions to everyone, and write permissions to user1, create
a file with:
<pre>R @all
RW user1 user2</pre>
and then run the setperms commands with this as its input:
<pre>ssh pltgit setperms $user/foo &lt; the-file</pre>
You can also just run the <span class="code">setperms</span> command and type in the
permissions directly.  Note that these permissions are not cumulative:
every use of <span class="code">setperms</span> specifies all permissions.  (We might have a
more convenient interface for all of this in the future.)</li>
<li><span class="code">config</span> — this command can be used to set known configuration options
in your repositories.  It works with sub-verbs:
<dl><dt><span class="code">ssh pltgit config list</span></dt>
<dd>Displays the known configuration options</dd>
<dt><span class="code">ssh pltgit config get <i>repo</i> <i>config</i></span></dt>
<dd>Displays the configuration value of a specific repository</dd>
<dt><span class="code">ssh pltgit config set <i>repo</i> <i>config</i> <i>value</i></span></dt>
<dd>Sets the configuration value of a specific repository</dd></dl>
These configuration options can customize aspects of the scripts that run
after every push — currently, you can use this to set an email address to
send notification emails to.  Other configurations may be added in the
future.  (Note that this does not let you set any configuration, since
some of these can execute arbitrary commands.)</li>
<li><span class="code">delete</span> — finally, this command can be used to delete repositories.
For example, to clean up the above, you can now run:
<pre>ssh pltgit delete $user/foo
ssh pltgit delete $user/bar</pre>
The repositories are moved to a temporary holding directory, and will
eventually be removed.  The bottom line here is that if you lost anything
by mistake recently, chances are there's a backup of your repository.</li></ul></div>

<h2><a name="working_with_git" style="page-break-before: always;">Working with git</a></h2>

<h3><a name="working_with_git_basics">Working with git: Basics</a></h3>
<div class="p">The above description is much simplified in that it doesn't deal with
development that happens outside of your own work — and such development
obviously changes the story.  Overall, this is not too different from working
with subversion: if there were any changes on the server you need to update
your working copy first, and this implies dealing with conflicts if there are
any.  But the way to deal with such things in git is significantly different
than dealing with them in subversion, and this difference is at the technical
level (different commands) and at the workflow level (you will likely branch
much more, and you're likely to push less frequently than you commit with
subversion).</div>
<div class="p">To start working, you first need to get a repository clone.  Usually you will
clone the PLT repository (or a private copy that you do your work in), but
remember that to experiment with git you have the <span class="code">play</span> repository or
you could make a fork of the PLT repository to play with and remove it when
you're done.  Either way, be sure to try these things out — it will make your
life much easier in the future.</div>
<div class="p">In the following examples I will use an empty repository to demonstrate
things and I will list the exact commands that I'm using (this means that I
will use unix commands to create and edit files, and use <span class="code">-m</span> when
committing).  Lines that I enter are displayed with a <span class="code">$</span> prompt, most
output lines are omitted, comments start with <span class="code">#</span>, and <span class="code">$user</span> is set
to my username.  Note that if you try this yourself, the SHA1s of commits
will be different (the reason for that is that a commit object includes the
author name and email and the date).  Note also that in some places I will
“jump to an earlier continuation”: start from an earlier state and do
something different — so if you want to try these things out it will be
convenient to put the commands in a shell script so you can re-run it to get
to the earlier state.</div>
<div class="p">First, I create a private empty repository, populate it, and update the
remote repository:
<pre>$ user=eli                    # your own username here
$ mkdir /tmp/sandbox; cd /tmp/sandbox
$ ssh pltgit delete $user/foo # delete previous repository, if any
$ git clone pltgit:$user/foo
$ cd foo
$ echo &quot;foo&quot; &gt; foo; echo &quot;bar&quot; &gt; bar
$ git add .
$ git st                      # uses the `st' alias as shown above
A  bar
A  foo
$ git commit -m &quot;initial content&quot; .
[master (root-commit) 87f1f02] initial content
<i>...</i>
# git tells us the branch we committed to, the new commit SHA1 and
# that this is the first commit, and the log message; we can verify
# this now with `git log'
$ git log
commit 87f1f02c23b32e7f9b...  # this is the commit object I created
<i>...</i>
$ git push                    # (or `git push origin master' if needed)
To pltgit:eli/foo             # where we pushed to, and the branch
 * [new branch]      master -&gt; master</pre></div>
<div class="p"><small>[A quick note on commit messages: several git command consider the
first paragraph of your commit message as a short description for it.  This
is all of the text up to the first blank line if you write a commit message
in an editor, or the first <span class="code">-m</span> message if you use it with
<span class="code">git commit</span> (it accepts multiple <span class="code">-m</span> arguments, for multiple
paragraphs).  Keep this in mind when composing such messages.]</small></div>
<div class="p">To see what happens when multiple people commit to the repository, we create
a second clone of our repository now in a <span class="path">foo2</span> directory:
<pre>$ cd ..
$ git clone pltgit:$user/foo foo2
$ cd foo                      # go back to foo now</pre></div>
<div class="p">Lets make two new commits now:
<pre>$ echo &quot;more foo&quot; &gt;&gt; foo; echo &quot;more bar&quot; &gt;&gt; bar
$ git ci -m &quot;more stuff&quot;      # uses the `git-ci' script from above
[master b7d3c41] more stuff
$ echo &quot;even more foo&quot; &gt;&gt; foo
$ git ci -m &quot;even more stuff&quot;
[master 18bc0e6] even more stuff</pre></div>
<div class="p">At this point, instead of blindly pushing these commits, lets look around
first.  One useful tool for inspecting the history is <span class="code">gitk</span> — if you run
it now, you will see the simple 3-commit graph, and two of them are marked as
branches — clearly showing that your local master branch is 2 commits ahead
of the remote one.  This could be different at this point: someone else might
have pushed more commits to the remote — remember that your remote master
branch (<span class="code">remotes/origin/master</span>) is not really what's on the remote, but
rather what you know about it last time you pulled from it.</div>
<div class="p">Another useful command to examine the history is <span class="code">git log</span>, which can
show commit history in many ways.  As things stand in the current repository,
if you just run <span class="code">git log</span>, you will see a listing of the same three
commits that gitk shows.  To get a more condensed format with
one-line-per-commit, use <span class="code">--oneline</span>.  Another thing that you can do is
show a specific range of commits — you can do this by specifying two
revisions separated with <span class="code">..</span>, where the revisions can be written
explicitly using the (short prefix) SHA1 form, or more conveniently using a
symbolic name (eg, branch, tag, HEAD):
<pre>$ git log origin/master..master</pre></div>
<div class="p">Since we <em>are</em> currently on the master branch, we could use <span class="code">HEAD</span> for
the second one (<span class="code">origin/master..HEAD</span>), but this is also the default, so
an even shorter form is <span class="code">origin/master..</span>.  In addition to <span class="code">git log</span>,
you can also use <span class="code">git diff</span> in a similar way, but instead of a commit
listing, you get the diff between the two specified points, so
<pre>$ git diff origin/master..</pre>
will show you the changes that you did not yet push.  Note that there are a
number of places where git will guess the full name of branches, for example,
<span class="code">origin/master</span> is actually a short name for <span class="code">remotes/origin/master</span>.
In a similar way, just <span class="code">origin</span> will make git guess that you're talking
about <span class="code">origin/master</span>.</div>
<div class="p">In these cases, the revision specification for <span class="code">log</span> and <span class="code">diff</span> are
the same, but this is a little misleading: <span class="code">git diff</span> usually works by
comparing two specific end points in your history, but <span class="code">git log</span> actually
works on a <em>set of commits</em> rather than on a range.  The <span class="code">R1..R2</span>
notation is actually shorthand for <span class="code">^R1 R2</span> — specifying a commit means
“the commit and all of its parents”, and a <span class="code">^</span> prefix negates a set, so
<span class="code">^R1 R2</span> means “include the set of commits leading to R2 (inclusive), but
exclude the ones leading to R1 (inclusive)”.</div>
<div class="p">In addition to this range/set specification, there is a lot to specifying a
revision set.  As mentioned, you can use a SHA1 (or a shorter unique prefix),
or you can use a symbolic name.  You can also use <span class="code">R^</span> for the parent of
<span class="code">R</span> (the first parent in the case of merge commits, which have more than
one parent), <span class="code">R^^</span> would be the grand parent, <span class="code">R~3</span> is the
3rd-generation parent commit.  There is also <span class="code">R@{yesterday}</span>,
<span class="code">R@{1 month 2 weeks go}</span> etc for a symbolic name R — which refers to
the branch/HEAD at that point in time (this refers to <em>your own</em> version
of it at that time; there are <span class="code">--since</span> and <span class="code">--until</span> flags to filter
commits by the time they were made at).  You can also use a -N flag (where N
is an integer) to show only N commits.  Finally, you can use a branch name R
with <span class="code">R@{upstream}</span> (short: <span class="code">R@{u}</span>) to refer to the “upstream”
version of the branch — the branch that R is set to follow.  This is
particularly convenient for things like <pre>$ git log --oneline @{u}..</pre>
which will always show the commits that you have over the branch your current
one follows.  (For example, you could set up an alias to use this.)</div>
<div class="p">We now continue by pushing our two commits to the remote server.  Since we
already did a push, a plain <span class="code">git push</span> works fine.
<pre>$ git push                    # no need to specify a branch now
To pltgit:eli/foo
   87f1f02..18bc0e6  master -&gt; master</pre></div>
<div class="p">As you can see in the last line, git tells us that we pushed from our local
<span class="code">master</span> branch to the remote <span class="code">master</span> branch, and that this made it
advance from the first commit we pushed (87f1f02) to the last one we created
now (18bc0e6).</div>
<div class="p">Since we've made some progress in one place, we can go to the <span class="path">foo2</span>
clone to see what happens when we update a repository that did not have these
changes:
<pre>$ cd ../foo2
$ git pull
<i>...</i>
From pltgit:eli/foo
   87f1f02..18bc0e6  master     -&gt; origin/master
Updating 87f1f02..18bc0e6
Fast-forward
 bar |    1 +
 foo |    2 ++
 2 files changed, 3 insertions(+), 0 deletions(-)</pre></div>
<div class="p">This looks expected — git shows the new commits that we received, and they're
the same as what we pushed earlier.  Using <span class="code">git pull</span> is actually doing
two things: it's running <span class="code">git fetch</span> first to update your remote branch
from the server, and then it uses <span class="code">git merge</span> to merge it into your
master branch.  The point where <span class="code">get merge</span> starts is the “Updating” line
— and there's an important thing to note here: the next line says
“Fast-forward”, which is a special kind of a merge.  When you merge some
branch into your branch, and this branch is a proper superset of your branch
(it has commits that your branch doesn't, and all commits in your branch are
included in it), git will simply “move your branch forward” to the other: it
will update your branch to the tip of the merged one, and then your working
directory will be update accordingly.</div>
<div class="p">It is often better to do the fetch first, so you can see the changes that
happened remotely before you merge them.  To do this we're going to use
<span class="code">git fetch</span>, avoiding the merge step that <span class="code">git pull</span> does.  In fact,
since creating a merge commit is something that you might want to always do,
<span class="code">git pull --ff-only</span> will only do the merge if it will be a fast-forward
merge.</div>
<div class="p">Assuming we start again from the <span class="path">foo2</span> repository before the above
pull, we get the same output up to the point where the merge started:
<pre>$ git fetch
@i{...}
From pltgit:eli/foo
   87f1f02..18bc0e6  master     -&gt; origin/master
$ git log --oneline @{u}..
# nothing
$ git log --oneline ..@{u}
# the same two commits</pre>
The first log doesn't show anything, since we have no commits over the ones
in the remote (the “upstream” of our current branch).  To see this, consider
that after expanding empty names to <span class="code">HEAD</span>, and the <span class="code">@{u}</span> to the
remote branch name we get <span class="code">remotes/origin/master..master</span>, and this is
short for <span class="code">^remotes/origin/master master</span> — the set of commits made of
our master branch and all parents, minus the set of commits from the remote
branch and up — since it's ahead of that, we get an empty set.  The second
log command reverses the two, giving us the set of commits that the remote
has and the local branch doesn't.  In addition to <span class="code">git log</span>, you can use
<span class="code">gitk</span> to inspect the repository: use the <span class="code">--all</span> flag to make it
show all branches.  Either way you'll be able to see that a fast-forward
merge is possible.</div>

<h3><a name="working_with_git_concurrent_development" style="page-break-before: always;">Working with git: Concurrent development</a></h3>
<div class="p">Again, we'll assume starting with the <span class="path">foo2</span> repository before the pull.
We will now create a new commit before we get changes.  This makes it similar
to commits pushed to the server while you do your work — so let's see how
this common story goes and try to push this change:
<pre>$ echo &quot;blah blah&quot; &gt; blah
$ git add blah
$ git ci -m &quot;blah&quot;
$ git push
To pltgit:eli/foo
 ! [rejected]        master -&gt; master (non-fast-forward)
error: failed to push some refs to 'pltgit:eli/foo'
To prevent you from losing history, non-fast-forward updates were rejected
Merge the remote changes before pushing again.  See the 'Note about
fast-forwards' section of 'git push --help' for details.</pre></div>
<div class="p">As expected, git refuses to push our change.  The terminology in the error
message is a little confusing — what it basically says is that the commit(s)
that we are trying to push are not an extension of the tip of the master
branch on the server.  A “non-fast-forward update” in this case would mean
that we'd set the master branch on the remote to be the same as our branch —
but this means that whatever commit that were pushed to the server (the two
commits we pushed out from the <span class="path">foo</span> clone in this case) will be lost.</div>
<div class="p">To merge in the remote changes, we need to pull them in.  We'll now look at
three different ways to do this.</div>
<h3>1. Playing it safe</h3>
<div class="p">First, as we've seen above, doing a separate <span class="code">git fetch</span> step would allow
you to see where things stand before you do anything.  Alternatively, we can
use the <span class="code">--ff-only</span> variant of <span class="code">git pull</span>, which will do a merge only
if it's a fast-forward one, covering the trivial cases.  If a fast-forward
merge cannot be done, it will tell you about it and then stop:
<pre>$ git pull --ff-only
<i>...</i>
From pltgit:eli/foo
   87f1f02..18bc0e6  master     -&gt; origin/master
fatal: Not possible to fast-forward, aborting.</pre></div>
<div class="p">We can now use the usual tools to see where things stand.  The following are
all useful here:
<ul><li><span class="code">gitk --all</span><br />
This visualizes the commit graph.  If you do this, you will see the four
commits that we have so far: the initial commit at the root, the commit
that we did in this clone, and the two commit that we retrieved and are
waiting on <span class="code">remotes/origin/master</span>.</li>
<li>(a) <span class="code">git log @{u}..</span><br />
(b) <span class="code">git log ..@{u}</span><br />
(c) <span class="code">git diff @{u}..</span><br />
(c) <span class="code">git diff ..@{u}</span><br />
Inspect the commit that the local branch has over the remote (a), and the
two that the remote has over the local one (b); look at the difference
between the local branch and the remote either way (c).</li>
<li>(a) <span class="code">git log --left-right --oneline @{u}...</span><br />
(b) <span class="code">git log --left-right --oneline ...@{u}</span><br />
(c) <span class="code">git log --graph --oneline --all</span><br />
An alternative notation for specifying commit sets for <span class="code">git log</span> is
<span class="code">R1...R2</span> (with <em>three</em> dots) — this stands for all commits from
both R1 and R2 and their parents, but excluding commits from their “merge
base” — the parent commit that both descend from.  As demonstrated in (a),
this is especially useful with the <span class="code">--left-right</span> flag: you'll see the
commits that are new on the remote branch and the ones that are new on the
local one, with <span class="code">&lt;</span> or <span class="code">&gt;</span> indicating which side each commit is
coming from.  Yet another way that <span class="code">git log</span> can be used is (c) with a
<span class="code">--graph</span> flag, which makes it render the commit graph in ASCII-art.</li>
<li><span class="code">git show-branch -a</span><br />
This is another potentially useful commands that shows how commits are
distributed over branches in your repository.  In this case you will see a
matrix with the four commits in separate rows, and each will have a
<span class="code">+</span> or <span class="code">*</span> indicating whether it is included in a branch.</li>
<li>(a) <span class="code">git diff @{u}...</span><br />
(b) <span class="code">git diff ...@{u}</span><br />
The three-dots notation is also used by <span class="code">git diff</span>, with a slightly
different semantics than in <span class="code">git log</span> (remember that <span class="code">git log</span>
talks about commit sets, and <span class="code">git diff</span> compares two specific points).
In the <span class="code">diff</span> case, these compare a specific branch tip to the merge
base of this branch and another, which means that you see a diff with the
work done on one branch that is not included in the other (this is unlike
the two-dot syntax where you get the diff between the two branch tips).
In the first (a) example you will see all changes that you did locally,
and in (b) the changes that were done remotely.</li></ul></div>
<h3>2. Merging (not the fast-forward variant)</h3>
<div class="p">Now that we did a <span class="code">git fetch</span> or a <span class="code">git pull --ff-only</span> to update the
remote branch, we can proceed with merging it into our branch — which we can
do in one of two ways:
<pre>$ git merge origin            # merge origin/master into master
Merge made by recursive.
<i>...</i>
# -or-
$ git pull                    # will do a merge as usual</pre></div>
<div class="p">Using <span class="code">merge</span> is better for the usual reason: <span class="code">git pull</span> can bring in
more updates that were pushed by others since you fetched, and include them
in the merge.  Note that if instead of running a separate fetch or pulling
with <span class="code">--ff-only</span> you were using <span class="code">git pull</span>, then you'd essentially
get to the same point we are now at.</div>
<div class="p">Either way, the merge tells us “Merge made by recursive” — which is important
here: if we see “Fast-forward” it means that no new commits were made, but
“Merge made ...” means that a merge commit was created (“by recursive” refers
to the merge strategy, git has several of them).  If we look at the commit
graph now with gitk or with <span class="code">git log</span>, we'll see the new commit that was
created:
<pre>$ git log --oneline --graph --date-order
*   12bf7ee Merge remote branch 'origin'
|\
* | a40a45f blah
| * 18bc0e6 even more stuff
| * b7d3c41 more stuff
|/
* 87f1f02 initial content</pre>
The merge was successful without manual intervention (you didn't need to
resolve any conflicts), so it proceeded immediately to create the commit
that connects the two lines of development, and used some standard
template for the commit log.  This is the safe thing to do as the
default for git, but in this case it makes the history complicated with
no good reason — it just happened that while we were working on <span class="code">blah</span>
someone else pushed an unrelated change.  (It could be related: perhaps
one of the remote commits was referring to the file that I've added, but
especially in the PLT case this would be very rare.)  If you use gitk to
look at the recent history of the repository, you'll see many such
commits, and they can make it harder to figure out how the development
went on.</div>
<h3>3. Rebasing</h3>
<div class="p">To get a simple/readable history, the goal is to have a more linear history:
just have the two remote commits and move our commit to follow them (which
would be the history that you get with subversion under similar conditions).
But our commit object already points to its parent, so it <em>cannot</em> move:
in the above graph, <span class="code">a40a45f</span> is a hash that was computed based on
<span class="code">87f1f02</span> being its parent, and changing a parent means getting a new
hash and therefore a new commit object.</div>
<div class="p">This is where <span class="code">git rebase</span> gets into the picture.  Assuming that we
didn't merge as described above, we would just use <span class="code">rebase</span> instead:
<pre>$ git log --graph --all --oneline
* a40a45f blah                # \
| * 18bc0e6 even more stuff   #  \
| * b7d3c41 more stuff        #   &gt; same tree as before the merge
|/                            #  /
* 87f1f02 initial content     # /
$ git rebase origin
First, rewinding head to replay your work on top of it...
Applying: blah                # git tells us that it re-applies this
$ git log --graph --all --oneline
* 6ebd1fb blah                # \
* 18bc0e6 even more stuff     #  \ the resulting history
* b7d3c41 more stuff          #  / is linear
* 87f1f02 initial content     # /</pre></div>
<div class="p">Here's what git did in this rebase: it (1) moved the HEAD to the merge base
between your local branch and the remote one — the <span class="code">87f1f02</span> commit; (2)
did a fast-forward merge, which just moves your local branch to the tip of
the remote one; (3) it now <em>replays the same changes</em> that you had in your
commits (only <span class="code">a40a45f</span> in this case) on top of the new tip, leading to
<em>new</em> commit objects (<span class="code">6ebd1fb</span> in here).  So we end up with a fresh
commit object, and the old one (<span class="code">a40a45f</span>) is gone.  (It's not really
gone — it's kept in your repository store for a while, to protect you from
losing work.)  If you look at the complete details of the new commit using
gitk or <span class="code">git log</span>, you will see that this commit has different dates for
the author and the committer date:
<pre>$ git log --format=fuller -1 6ebd1fb # all details, show only one commit
<i>...</i>
AuthorDate: 2010-05-02 10:26:00 -0500
<i>...</i>
CommitDate: 2010-05-02 10:30:00 -0500</pre>
This is because rebasing just created a new commit — but the author time is
still considered the same.  In any case, you now have linear history that is
a proper descendant of the remote branch, and you can now push your changes
out.</div>
<div class="p">Practically every place where you read about rebasing in git will warn you
about not doing it for public history.  The problem is that if someone had a
copy of your previous branch (<span class="code">a40a45f</span>), then next time they will
update, if their copy of the branch is updated, then things will change in a
nasty way: even more so if they've committed more changes on that branch.
(This “someone” can also be yourself, of course.)  This also explains why
<span class="code">git pull</span> does not rebase by default.</div>
<div class="p">As far as the PLT repository goes, server will never allow pushes that are
not strict extensions of what's on it (in other words, it only allows
fast-forward pushes) — so you won't be able to mess things up for others.
But as long as your change is something that you work on privately, there is
absolutely no problem in doing this.  Note that this is the same thing as
with re-doing commits because of mistakes: as long as a commit did not go
out, you can fix it in multiple ways; when it does get pushed to the server,
the only practical way to fix it is by pushing another commit.  (In some
extreme cases we may do such a thing: for example, if you commit a passwords
file, then there is no other way to remove it completely from the repository
— but these are very rare, and such fixes affect everyone.)</div>
<div class="p">It is therefore best to get one of two habits when you do a <span class="code">git pull</span>:
either use <span class="code">--ff-only</span> or <span class="code">--rebase</span>.  The latter is a little more
convenient but you might not feel comfortable about doing a rebase
automatically — it <em>might</em> just be that someone worked on the same set of
files, and you really prefer a plain merge.  For this, you might prefer using
<span class="code">--ff-only</span> which will automatically work in the trivial cases, and
otherwise leave you in a state where you can look at things and decide how to
proceed yourself.</div>

<h3><a name="working_with_git_additional_forms_of_history_tweaking" style="page-break-before: always;">Working with git: Additional forms of history tweaking</a></h3>
<div class="p">As described in the previous section, rebasing is not some kind of a magical
operation: it is really just an expected by-product of the way git works — of
the fact that commits can be created as descendants of any commit (not just
tip commits).  You could perform a rebase manually by starting from some
commit, then inspect each of the changesets that the rebased history
contains, and play them back on the new commit.  (Lumping this tediousness
lead to a script, which lead to the rebase command.)  This means that you
don't really have to limit yourself to replaying these commits exactly as
they were — for example, you could write new commit log messages, combine two
commits into one, drop some commits, or reorder their order.</div>
<div class="p">The rebase command has a flag that makes doing all of these things easy:
<span class="code">--interactive</span>.  Continuing the above example, we now have four commits
in our history — and say that we want to tweak the last two.  If we now run
<pre>$ git rebase HEAD~2</pre>
we ask git to rebase our current head off of its grandparent commit (remember
that <span class="code">HEAD^</span> is the parent, <span class="code">HEAD^^</span> is the grandparent, and
<span class="code">HEAD~2</span> is an alternative syntax for <span class="code">HEAD^^</span>).  Since it <em>is</em>
already based there, <span class="code">git rebase</span> does nothing, and tells us that the
branch is up to date.  But if we add <span class="code">--interactive</span>, we get something
different: git pops up an editor with this text:
<pre>pick 18bc0e6 even more stuff
pick 6ebd1fb blah
# Rebase b7d3c41..6ebd1fb onto b7d3c41
# <i>...</i></pre>
This is a listing of the last two commits with their one-line log messages.
As the text that is below these lines say, you can replace the <span class="code">pick</span>
before a commit with a different command: you can use <span class="code">reword</span> to get to
write a different log message (you will get another editor window to do the
editing), <span class="code">squash</span> to combine a commit with the previous one (it will let
you edit the log message for the combination), <span class="code">fixup</span> which does the
same but discards the log message, and finally <span class="code">edit</span> will make the
rebasing process stop at the relevant commit and let you tweak it before it
continues.  In addition, removing a commit line means that the commit will be
skipped, and reordering lines will replay the commits in a different order.
If any of these lead to conflicts, the rebasing will stop for a manual
resolution, and you'll need to <span class="code">git rebase --continue</span> when resolved, or
<span class="code">git rebase --abort</span> to get back to the original state.</div>
<div class="p">Note that since our <span class="path">foo2</span> clone tracks a public <span class="path">foo</span> repository,
this particular rebase is bad: we intend to edit the last two commits, but
only one is local to <span class="path">foo2</span> — the other is a commit that we got from
<span class="path">foo</span>, and changing it means that we will get a rebased commit based on
its parent, and the server will forbid pushing it later.  If you see that you
went too far when you see the rebase editor, all you need to do is keep those
lines untouched: in the trivial case of leaving an initial set of commits in
unmodified, they will be “rebased” by leaving them in as is.  (If you inspect
the history later, you will see that they have the same SHA1s.)</div>
<div class="p">A useful case of using <span class="code">squash</span> (or <span class="code">fixup</span>) with interactive
rebasing is doing <span class="code">checkpoint</span> commits frequently, and eventually
combining them to a single commit.  This demonstrates one a popular git
principle: keep commits as logical units that correspond with the changes
done, since there is no central server that dictates a
public-commit-or-nothing.  Doing these will make it easier in the future to
deal with the history: inspect the changeset as a whole, undo it, and it also
works well with finding bugs in the history — you can have checkpoints for
intermediate states of the code even if it doesn't work, since this state
will eventually be hidden.</div>
<div class="p">A particularly common case for editing history is “oops commits”: you just
made some change, committed it, and then realized that something is wrong —
you forgot to change some related reference, to remove some debugging
printout, or to describe some new aspect of the commit.  You could use
<span class="code">git rebase HEAD^</span> in these cases to rebase just the last commit while
editing it, but there is a much more convenient way to do this: <span class="code">git
commit --amend</span>.  Usually, <span class="code">git commit</span> creates a new commit based on the
current branch tip and a given commit log message, but with <span class="code">--amend</span> it
does something different: it takes a snapshot of the tree as usual, but it
makes the commit be a descendant of the tip's parent commit.  For example,
assuming we didn't really change anything with the rebase above, our history
and recent change is now:
<pre>$ git log --oneline
6ebd1fb blah
18bc0e6 even more stuff
b7d3c41 more stuff
87f1f02 initial content
$ git log --oneline -p -1     # -p =&gt; show patch, -1 =&gt; only one
6ebd1fb blah
diff --git a/blah b/blah
@i{...}
--- /dev/null
+++ b/blah
@@ -0,0 +1 @@
+blah blah                    # this is the recent change</pre>
This is obviously wrong — we need to have three “blah”s there.  With
subversion we would now need to perform an “oops, forgot a blah” commit, and
in fact, we would need to do the same with git if we push these change out
now.  But as long as we didn't, we can fix it without an additional commit
using <span class="code">--amend</span>:
<pre>$ echo &quot;blah blah blah&quot; &gt; blah
$ git add blah
$ git ci --amend -m &quot;blah^3&quot;
[master 5cf863d] blah^3       # the re-made commit
$ git log --oneline
5cf863d blah^3
18bc0e6 even more stuff
b7d3c41 more stuff
87f1f02 initial content</pre>
As you can see, the last commit is gone (remember that it is still backed up,
in case of problems), and there is a completely new commit instead.  Usually,
<span class="code">--amend</span> is used without <span class="code">-m</span> — the log message editor will be
initiated with the previous log message, so you can edit it instead of
rewriting it from scratch.  If there were no modifications to be committed, a
<span class="code">git commit --amend</span> is a convenient way to edit the last commit message
only.  If you leave the message untouched, a new commit will still be made —
one with a new commit time; and if you delete the text completely, the
re-commit will be aborted, and you will be left with the old one intact.</div>

<h3><a name="working_with_git_resetting_the_tree" style="page-break-before: always;">Working with git: Resetting the tree</a></h3>
<div class="p">Both the <span class="code">commit --amend</span> feature and rebasing build on the ability to
“move” the current branch tip to some earlier commit in its history.  To do
this directly, git provides a <span class="code">git reset</span> command, which can move the
current branch tip to a specified commit, and adjust the working directory
and/or the staging area accordingly.  For example, for the <span class="code">--amend</span>
functionality, you will use <span class="code">HEAD^</span> to move the branch tip to its parent
commit.  You can of course specify any other commit to move to, and since git
branches are effectively short bookmarks, you can create branches to be able
to move to them later on (or as targets for rebasing, merging, etc).  In
addition, you can use <span class="code">HEAD</span> (or just omit the target, since <span class="code">HEAD</span>
is the default) to only change the working directory (or staging area).</div>
<div class="p">The reset command has three major modes for its work, specified with a flag.
(See the <a href="http://www.kernel.org/pub/software/scm/git/docs/git-reset.html"><span class="man">git-reset</span></a> man page for a more thorough explanation, with lots
of usage examples, some have evolved into their own functionality — like the
<span class="code">--amend</span> feature.)  Using <span class="code">HEAD^</span> as the target commit, here are
some summaries of how it can be used:
<ul><li><span class="code">git reset --hard HEAD^</span><br />
This will move the branch tip to the previous commit, and will change the
working tree and the staging area to match.  Translation: completely
forget the last commit and any work in the working directory.</li>
<li><span class="code">git reset --soft HEAD^</span><br />
Moves the branch tip, but does not change the working directory or the
staging area.  Translation: undo the last commit, and leave your working
directory in a state where <span class="code">git commit</span> will get the same change in.
(Note: not the <span class="code">git ci</span> script — this will add changes in the working
directory, if any.)</li>
<li><span class="code">git reset --mixed HEAD^</span><br />
Moves the branch tip and the staging area to the parent commit, and any
modifications done by the commit that are going to be lost are put in your
working directory.  Translation: similar to the <span class="code">--soft</span> version,
except that the staging area is cleared, so to recommit the changes you
will need to add files again (or use <span class="code">git ci</span> as usual).
<br />
(Note: This is the default mode.)</li></ul></div>
<div class="p">When using <span class="code">HEAD</span> (which is the also default when nothing is mentioned),
the branch tip is not moved, and we get:
<ul><li><span class="code">git reset --hard</span><br />
Get rid of all changes to the working directory and the staging area.
Translation: lose all work that was not committed, getting back to the
content on the branch (a convenient way to do something similar to an
<span class="code">svn revert -R .</span> in the root of a subversion working directory).</li>
<li><span class="code">git reset --mixed</span><br />
Get rid of all changes to the staging area, leaving your working directory
intact.  Translation: lose everything that was added to the staging area.
If you're avoiding it (for example, if you only use the <span class="code">git ci</span>
script), then this would be a no-op other than new files that were
<span class="code">git add</span>ed.</li>
<li>(<span class="code">git reset --soft</span> is a no-op.)</li></ul></div>
<div class="p">When <span class="code">git reset</span> changes the HEAD, it creates another toplevel reference
name called <span class="code">ORIG_HEAD</span> that points to the previous commit that
<span class="code">HEAD</span> pointed at, so if you happen to <span class="code">git reset --hard HEAD^</span> by
mistake, you can immediately get back to it with
<span class="code">git reset --hard ORIG_HEAD</span> (but changes in the working tree would still
be lost).  (<span class="code">git merge</span> is another command that changes the <span class="code">HEAD</span>,
and it also saves the previous value in <span class="code">ORIG_HEAD</span>.)  Finally, note that
<span class="code">git reset</span> can be restricted to make it work only on a specific set of
paths, not on the whole repository.</div>

<h3><a name="working_with_git_other_forms_of_reverting" style="page-break-before: always;">Working with git: Other forms of reverting</a></h3>
<div class="p">While we're on the topic of reverting files, there are three more things
worth mentioning:
<ul><li><span class="code">git checkout -- <i>path ...</i></span><br />
<div class="p">When <span class="code">git checkout</span> is given some paths, it will only check out the
relevant files from their state in the staging area.  This is a more
popular way to revert changes to a specific file.  If you avoid using
the staging area, then this is roughly the same as using reset with the
<span class="code">--hard</span> flag on the paths, since your staging area will usually be
the same as your <span class="code">HEAD</span>.  (Note that the <span class="code">--</span> is optional, and
needed only when a path name can be confused with a branch name.)</div>
<div class="p">As with <span class="code">reset</span>, you can also specify a branch to check the path(s)
from — which is useful to try some files from a different branch
selectively.  However, note that unlike subversion, git does not
remember the association of the branch and the paths that were checked
out of it (the branch is not “sticky”) — the files will simply be
considered as modified (and they will not be updated when the branch is,
unless you do the same checkout).</div></li>
<li><span class="code">git show HEAD:<i>path</i></span><br />
<div class="p">This shows the file as it exists in the <span class="code">HEAD</span>, making it useful to
inspect the file before you made some additional modifications (similar
to <span class="code">svn cat <i>path</i></span>).  You can also omit the <span class="code">HEAD</span> — using
<span class="code">:<i>path</i></span> will show the file in the staging area, which will
usually be the same as the <span class="code">HEAD</span>.  One caveat to note here is that
the path should be the full path relative to the repository root.
(Note: I have a wrapper <span class="code">git cat</span> script that emulates
<span class="code">svn cat</span>, I'll add it if anyone wants.)</div></li>
<li><span class="code">git revert <i>commit</i></span><br />
<div class="p">The <span class="code">git revert</span> command is used to revert the changes introduced by
the given commit.  It will basically apply the change in that commit
in reverse, then ask you for a log message for a new commit where the
message is initially populated with text indicating the commit that
was applied in reverse.</div>
<div class="p">Note that this is very different from <span class="code">svn revert</span> — it is more like
<pre>svn merge -c-123; svn commit &quot;Revert revision 123&quot;</pre>
Since this is a frequent source of confusion, the <a href="http://www.kernel.org/pub/software/scm/git/docs/git-revert.html"><span class="man">git-revert</span></a> man
page mentions it at the top, and it refers readers to <span class="code">git reset</span>
and <span class="code">git checkout</span> as the way to do the equivalent of <span class="code">svn
revert</span> (which are described above.)</div></li></ul></div>

<h3><a name="working_with_git_dealing_with_conflicts" style="page-break-before: always;">Working with git: Dealing with conflicts</a></h3>
<div class="p">We'll now see how to deal with merge conflicts.  First, we'll set up the
repository for a conflict.  Continuing with the <span class="path">foo2</span> clone, we'll
first create a file (which I'll do here using shell commands, to make it easy
to play with), commit, and push the new history (which includes the blah
work) back to the server.  Note the use of <span class="code">git branch -v</span> which shows
the local <span class="code">master</span> branch and the fact that there's two commits that we
haven't pushed out yet.
<pre>$ echo &quot;#lang racket&quot;    &gt; foo
$ echo &quot;(define (foo x)&quot; &gt;&gt; foo
$ echo &quot;  (* x x))&quot;      &gt;&gt; foo
$ git ci -m &quot;turn foo into a library&quot;
[master fd856ef] turn foo into a library
$ git branch -v
* master fd856ef [ahead 2] turn foo into a library
$ git push
To pltgit:eli/foo
   18bc0e6..fd856ef  master -&gt; master</pre></div>
<div class="p">Now hop over to the <span class="path">foo</span> clone, get the changes (the relevant bits of
the output are shown), edit the file (using sed, to make it a command line),
inspect the change, commit it, and push.
<pre>$ cd ../foo
$ git pull
From pltgit:eli/foo
   18bc0e6..fd856ef  master     -&gt; origin/master
Updating 18bc0e6..fd856ef
Fast-forward
 blah |    1 +
 foo  |    6 +++---
 2 files changed, 4 insertions(+), 3 deletions(-)
 create mode 100644 blah
$ sed -i '2s/x/[x 0]/' foo
$ git diff
diff --git a/foo b/foo
index 78d9889..b81de80 100644
--- a/foo
+++ b/foo
@@ -1,3 +1,3 @@
 #lang racket
-(define (foo x)
+(define (foo [x 0])
   (* x x))
$ git ci -m 'add a default value'
[master 5035c9a] add a default value
$ git push
To pltgit:eli/foo
   fd856ef..5035c9a  master -&gt; master</pre></div>
<div class="p">And now get back to <span class="path">foo2</span>, and before we pull, modify the same line by
adding a comment and commit, then do a <span class="code">--ff-only</span> pull and watch it
refuse to merge as expected, then look at the history so far.
<pre>$ cd ../foo2
$ sed -i '2s/$/ ; int-&gt;int/' foo
$ git ci -m 'document the type of foo'
[master 21a78df] document the type of foo
$ git pull --ff-only
From pltgit:eli/foo
   fd856ef..5035c9a  master     -&gt; origin/master
fatal: Not possible to fast-forward, aborting.
$ git log --graph --all --oneline -4
* 21a78df document the type of foo # ← our change
| * 5035c9a add a default value    # ← the conflicting change we pulled
|/
* fd856ef turn foo into a library
* 5cf863d blah^3</pre></div>
<div class="p">Rebasing is the common thing to do, but let's see what happens with a plain
<span class="code">merge</span> first:
<pre>$ git merge origin
Auto-merging foo
CONFLICT (content): Merge conflict in foo
Automatic merge failed; fix conflicts and then commit the result.</pre></div>
<div class="p">We now have a conflict that needs to be resolved before we can finish the
merge.  Using <span class="code">git st</span> (the alias listed above for the svn-like status
that <span class="code">git status -s</span> produces) shows a new <span class="code">UU</span> status for <span class="path">foo</span>
— this indicates an “unmerged” (conflicted) file.  To investigate further, we
use a plain <span class="code">git status</span>, which tells us that our history diverged from
the remote (we already know that since <span class="code">pull --ff-only</span> failed) and count
the diverging commits, and it also tells us that <span class="path">foo</span> is unmerged and
hints at using <span class="code">git add</span> to resolve it:
<pre>$ git st
UU foo
$ git status
# On branch master
# Your branch and 'origin/master' have diverged,
# and have 1 and 1 different commit(s) each, respectively.
# Unmerged paths:
#   (use &quot;git add/rm &lt;file&gt;...&quot; as appropriate to mark resolution)
#       both modified:      foo</pre>
You can also see that git knows about the conflict and refuses to do a
commit:
<pre>$ git commit
fatal: 'commit' is not possible because you have unmerged files.
Please, fix them up in the work tree, and then use 'git add/rm &lt;file&gt;' as
appropriate to mark resolution and make a commit, or use 'git commit -a'.</pre></div>
<div class="p">In most cases the way to continue is simple: open the conflicted file in your
editor, look for the conflict markers and fix the code.  Then, as suggested
above, use <span class="code">git add <i>file</i></span> which tells git that the file is resolved,
and finally use <span class="code">git commit</span> to commit the result.  (Note that using
<span class="code">git commit <i>file</i></span> will not work, which is why the <span class="code">git-ci</span> script
avoids adding a <span class="path">.</span> if the tree requires resolving a merge.)  I'll
simulate the editing part with echos, and then mark it resolved:
<pre>$ echo &quot;#lang racket&quot;                   &gt; foo
$ echo &quot;(define (foo [x 0]) ; int-&gt;int&quot; &gt;&gt; foo
$ echo &quot;  (* x x))&quot;                     &gt;&gt; foo
$ git add foo                 # ← tell git that it's resolved</pre>
And now the last step is to run <span class="code">git commit</span>, which will start your
editor to edit the log message — it will be populated by text that indicates
the merge and the file that had conflicts, which you can commit as is, or add
some text regarding the way it was resolved.</div>
<div class="p">At this point (or before we started working on resolving the conflict), we
can get back to the original state using <span class="code">reset</span>:
<pre>$ git reset --hard
HEAD is now at 21a78df document the type of foo</pre></div>
<div class="p">This kind of reset is generally useful if you had some problematic conflict
to resolve and you want to back up completely and re-try.  But now that we've
at the start, we will see what happens when we try to rebase with the
conflict instead:
<pre>$ git rebase origin
First, rewinding head to replay your work on top of it...
Applying: document the type of foo
<i>...</i>
CONFLICT (content): Merge conflict in foo
Failed to merge in the changes.
<i>...</i>
When you have resolved this problem run &quot;git rebase --continue&quot;.
If you would prefer to skip this patch, instead run &quot;git rebase --skip&quot;.
To restore the original branch and stop rebasing run &quot;git rebase --abort&quot;.</pre></div>
<div class="p">Obviously, we get a different message (note that <span class="code">git status</span> will now
tell you that you're not currently on any branch — a result of being in the
middle of a rebase).  The process that follows is very similar to the merge
case: edit the conflict away, then <span class="code">git add</span> the file.  There are two
differences: (1) after you <span class="code">git add</span> the resolved files, you should use
<span class="code">git rebase --continue</span> instead of committing[*]; (2) if you want to
abort the merge, use <span class="code">git rebase --abort</span> instead of using reset.
<small>([*] If you did commit, then it means that you wrote a new log message
for the replayed commit, and you can just as well use the <span class="code">--skip</span> flag
so rebasing continues with the rest, or you can use <span class="code">reset</span> to undo
your commit and let rebase do it for you.)</small></div>
<div class="p">When you're in a conflicted state, there are a few git tools that help you in
the resolution work.  The first useful utility is <span class="code">git diff</span>: when
there's a conflict, all files that were automatically merged are already
going to be in your staging area, and parts of conflicted files that could be
merged merged will be there too.  This leaves only the conflict regions in
your working directory, which means that <span class="code">git diff</span> will show you only
the conflicts (since by default it shows differences between the working
directory and the staging area).  Also, the diff output itself is not a
standard one.  At the current point of conflict during the rebase that we
started, this is what we'll see:
<pre>$ git diff
diff --cc foo
index b81de80,86a4c54..0000000
--- a/foo
+++ b/foo
@@@ -1,3 -1,3 +1,7 @@@
  #lang racket
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 +(define (foo [x 0])
++=======
+ (define (foo x) ; int-&gt;int
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; document the type of foo
    (* x x))</pre></div>
<div class="p">The diff header uses <span class="code">--cc</span> which indicates git's “combined diff format”,
used to represent merge commits (any commit with more than one parent).  The
next line has the two SHA1s of the two files that are merged.  The diff
itself starts with three <span class="code">@</span>s, and instead of a single indicator
character (<span class="code">+</span>, <span class="code">-</span>, or <span class="code"> </span>), there are two — indicating a
three-way diff between the two versions and their common ancestor version.
In the above you can see that the line with the optional argument is coming
from <span class="code">HEAD</span>, and the type-annotated one is coming from its commit.  You
might notice that this look backwards, since we're in the repository where we
committed the type annotation to the HEAD — but we're now rebasing, which
means that we start from the remote branch and merge our local changes into
it, essentially making the rebase perform merges in the other way than plain
merges.  The conflict markers themselves are marked as new in both versions,
and the labels that follow them depend on available information (in a
<span class="code">merge</span>, we would see <span class="code">HEAD</span> and <span class="code">origin</span>).</div>
<div class="p">During a conflict resolution, the staging area actually holds three versions
of each file: the common ancestor, our version, and the merged version.
These things are called “file stages”, and they can be accessed using a
special syntax:
<pre>$ git show :1:foo     # the common ancestor of both versions
$ git show :2:foo     # our version (optional argument)
$ git show :3:foo     # merged version (type-annotated)</pre>
(Again, remember that this is a rebase, so the last two are swapped.)  You
can also checkout one of these versions using <span class="code">git checkout foo</span>, giving
it an <span class="code">--ours</span> or <span class="code">--theirs</span> flag to specify which version you want
to use; and you can use <span class="code">git diff</span> to compare against them.  For example,
we resolve the file (as above) and then try the different diffs (before we
mark it as resolved) — these examples only show the changed lines from each
of the diffs:
<pre>$ echo &quot;#lang racket&quot;                   &gt; foo
$ echo &quot;(define (foo [x 0]) ; int-&gt;int&quot; &gt;&gt; foo
$ echo &quot;  (* x x))&quot;                     &gt;&gt; foo
$ git diff -1 foo               # can also use --base
-(define (foo x)                # original version
+(define (foo [x 0]) ; int-&gt;int # new version
$ git diff -2 foo               # can also use --ours
-(define (foo [x 0])
+(define (foo [x 0]) ; int-&gt;int
$ git diff -3 foo               # can also use --theirs
-(define (foo x) ; int-&gt;int
+(define (foo [x 0]) ; int-&gt;int</pre></div>
<div class="p">Finally, <span class="code">git log</span> and <span class="code">gitk</span> accept a <span class="code">--merge</span> flag which shows
commits relevant to a merge.  With <span class="code">git log</span> the <span class="code">--left-right</span> flag
is useful here, since you'll see which side the relevant commits are on.
(But this works only in <span class="code">git merge</span>, not in rebasing.)</div>
<div class="p">Again, when you're happy with the resolution, you <span class="code">git add</span> the file, and
because we're doing a <span class="code">rebase</span> rather than a <span class="code">merge</span>, use use it to
continue:
<pre>$ git add foo
$ git rebase --continue
Applying: document the type of foo
$ git log --graph --all --oneline -4
<i>...linear history...</i></pre>
Note that <span class="code">git rebase --continue</span> did the commit of the resolved content
for you, and it used the previous commit message you've written.  This is a
good rule-of-thumb for deciding whether you should rebase or merge: if the
commit message are still fine as a description of the modifications, then a
rebase is fine; otherwise you might want to <span class="code">merge</span> instead.</div>

<h3><a name="working_with_git_copying_renaming_files" style="page-break-before: always;">Working with git: Copying/renaming files</a></h3>
<div class="p">Git is, by design, tracking snapshots of the complete repository tree.
Specifically, it does <em>not</em> keep explicit track of file/directory copies
and renames.  Instead, it provides ways to infer such changes in the
repository based on the content.  As a result of this, there are almost no
git commands that deal with file movements:
<ul><li>There is no <span class="code">git copy</span> command: you just copy the file and add the new
one as usual.</li>
<li>There <em>is</em> a <span class="code">git rm</span> command, but its purpose is mostly to remove
a file from the staging area.  You could also just remove the file outside
of git, and then use either <span class="code">git commit <i>removed-file</i></span> or
<span class="code">git commit <i>containing-directory</i></span> to remove it (or using the above
script — <span class="code">git ci</span> in the same directory).  <span class="code">git rm</span> will delete
the file from the staging area so you can do a plain <span class="code">git commit</span>
without naming any paths.</li>
<li>For the same reason, there is a <span class="code">git mv</span> command — it uses
<span class="code">git rm</span> as above to update the staging area, and if you're fine with
ignoring it, then you can just rename the file outside of git, and
<span class="code">git add</span> the new version — but as we will soon see, it's really best
to use <span class="code">git mv</span> to avoid the possible confusion if you want the file's
history to be visible.</li></ul></div>
<div class="p">To try things out, let's properly name the <span class="path">foo</span> library:
<pre>$ mv foo foo.rkt
$ git st
 D foo
?? foo.rkt</pre>
As you can see, we forgot to <span class="code">git add</span> the new file, so if we commit now
we'll only be committing the deletion.  An important thing to note here is
that when git infers file copying and renaming, it does so only when the
operations appear in a <em>single</em> commit.  So if we commit this change and
later commit a new version with the new file will make it lose connection to
its history.  As long as you didn't push the new commits out, you can still
fix it: simply use <span class="code">git rebase --interactive</span>, and squash the file
addition together with the deletion.  But let's start over and do the rename
the easy way:
<pre>$ rm foo.rkt
$ git reset --hard
$ git mv foo foo.rkt
$ git ci -m &quot;properly name the foo library&quot;</pre>
to see this commit, we can use <span class="code">git show</span> (which can show arbitrary
objects, but with no arguments it shows the <span class="code">HEAD</span>).  <span class="code">git diff</span> can
also be used to show only the diff part — using the <span class="code">HEAD^!</span> syntax that
roughly means the range from the previous HEAD to the current one:
<pre>$ git show
<i>...log message...</i>
<i>...addition+deletion...</i>
$ git diff HEAD^!
<i>...addition+deletion...</i>
$ git diff --stat HEAD^!      # shows an overview of the changes
 foo     |    3 ---
 foo.rkt |    3 +++
 2 files changed, 3 insertions(+), 3 deletions(-)
$ git log --oneline foo.rkt
599b3b6 properly name the foo library</pre>
All of these show the two operations as disconnected, and the log doesn't
show any of the prior history.  The thing is that you need to ask git to look
for file operations, and the <span class="code">-M</span> and <span class="code">-C</span> flags do that.  In
addition, <span class="code">git log</span> needs a <span class="code">--follow</span> flag to make it follow history
beyond renames (but note that it can do that only when given a single file
path).  For example:
<pre>$ git diff -M --stat HEAD^!
 foo =&gt; foo.rkt |    0
 1 files changed, 0 insertions(+), 0 deletions(-)
$ git log --oneline --follow foo.rkt
599b3b6 properly name the foo library
0fb8291 document the type of foo
5035c9a add a default value
<i>...</i></pre>
In this case the rename was a trivial one as were no other changes.  This
makes it especially easy to find renames since the SHA1 of the file would be
the same.  But git considers such operations as renames as long as they're
“similar enough” — for example, if you just rename some files and change some
<span class="code">require</span>s as a result, it will be detected as renames.  (The usual claim
is that when the content is not similar enough, you can just as well claim
that the file is new.)  If you think that you might be doing too many changes
to some files, and you want to preserve the connection, you can do only the
rename in one commit, and then the modifications in the next.</div>
<div class="p">An added benefit of this mode of work is that <span class="code">git blame</span> can find lines
in files that were copied from other files, and deal naturally with a file
that is split into two files etc.  Like <span class="code">log</span> and <span class="code">diff</span>, it needs
some flags to do the extra work (see <span class="code">-M</span> and <span class="code">-C</span>).</div>

<h3><a name="working_with_git_managing_branches" style="page-break-before: always;">Working with git: Managing branches</a></h3>
<div class="p">As seen in various places above, a branch in git is basically just a SHA1
pointer to a commit (and therefore to the whole line of commits in its
development line), with a naming hierarchy that follows some conventions
(<span class="path">/</span>-separated, <span class="code">master</span> as the main one, <span class="code">remotes</span> prefix for
remote branches, <span class="code">origin</span> for the default remote server name, etc).  You
can see all of this in the toplevel <span class="path">.git</span> meta directory — there is a
<span class="path">HEAD</span> file which represents the head, its content will be a line that
looks like <span class="code">ref: refs/heads/master</span>, and there will be a
<span class="code">refs/heads/master</span> file with a content that is the actual SHA1.  There
are, of course, various other bits of meta-data, so it's not a good idea to
change such files directly (for example, when there are many names git will
create a “packed” reference file with many references for efficiency) — but
overall this is the basic idea.</div>
<div class="p">Branches come in two main kinds: local branches and remote ones, with remote
branches having a name that begins with <span class="code">remotes/origin/</span>.  (Later we'll
see how to add new remote repositories — remote branches from these will have
names that start with <span class="code">remotes/<i>remote-name</i>/</span> instead.)  The
difference between the two is that a remote branch is a way to mirror a
branch on a remote repository — it is not intended for local work.  For
example, if you try to check out a remote branch, git will check out a
“detached head” (details on this below).  If you do that, you'll see that the
<span class="path">HEAD</span> file will have an explicit SHA1 rather than the usual
<span class="code">ref: <i>branch-name</i></span>.</div>
<div class="p">The <span class="code">git branch</span> command is the main way to manage branches.  With no
flags, it will just print out the list of local branches, marking the current
branch with a <span class="code">*</span>.  You can add flags to show remote branches instead
(<span class="code">-r</span>), both kinds (<span class="code">-a</span>), and also to list more information on the
branches (<span class="code">-v</span>):
<pre>$ git branch
* master
$ git branch -r
  origin/HEAD -&gt; origin/master # (this one is symbolic too)
  origin/master
$ git branch -av
* master                599b3b6 [ahead 2] properly name the foo library
  remotes/origin/HEAD   -&gt; origin/master
  remotes/origin/master 5035c9a add a default value</pre></div>
<div class="p">When given a single name argument, a branch by that name will be created, and
it will point to where the <span class="code">HEAD</span> currently points to; a second argument
can be a name of an existing branch (or any commit) that the new branch will
start at.  In addition to creating branches starting from the current head,
this can be useful in creating branches that start from elsewhere, even from
a “detached head”.  For example, say that in our current repository we want
to try out some work based on the state of things before the last commit
(which renamed the <span class="path">foo</span> file).  We can check out <span class="code">HEAD^</span> (which
will lead to a detached HEAD), and then create a branch for it:
<pre>$ git checkout HEAD^
<i>...</i>
You are in 'detached HEAD' state.
<i>...</i>
HEAD is now at 0fb8291... document the type of foo
$ cat .git/HEAD
0fb8291...                     # doesn't point to a branch
$ git branch
* (no branch)                  # you can see it here too
  master
$ git status
# Not currently on any branch. # and here
$ git branch pre-rename        # create a branch here
$ git branch
* (no branch)                  # we're still detached
  master
  pre-rename
$ git checkout pre-rename
Switched to branch 'pre-rename'</pre>
As you can see, creating a branch doesn't check it out — even when the new
branch is exactly where we already are.  The difference is related to the
nature of <span class="code">HEAD</span>: it is usually an indirect reference to a branch name,
and when a commit is made, the branch that <span class="code">HEAD</span> points to is updated.
But when we are using a detached HEAD, it points directly at a SHA1 —
committing in this state will work, and the HEAD will point at the newly made
commit — but there will be no branch that will be updated, so if you checkout
a different branch (or a different commit) now, the commits you made are
“lost”.</div>
<div class="p">The main reason that such commits will be lost is that git branches don't
live inside the repository store — and dealing with branches is not something
that gets recorded as part of the history.  To make things safer, git
maintains something that is known as the “reflog”, which keeps track of where
your branches have been — those are kept for a while (usually around a
month), which means that you can easily go back to a previous commit if it
seems that you lost one (eg, as a result of committing on a detached HEAD).
(You can see these files in the <span class="path">.git/logs</span> directory.)</div>
<div class="p">Since creating a new branch and checking it out is a common combination, the
<span class="code">checkout</span> command can create a branch before checking it out.  Use the
<span class="code">-b</span> flag for this:
<pre>$ git checkout -b also-pre-rename
Switched to a new branch 'also-pre-rename'
$ git checkout -b post-rename master
Switched to a new branch 'post-rename'
$ ls
bar  blah  foo.rkt
$ echo &quot;one more line&quot; &gt;&gt; foo.rkt
$ git ci -m &quot;one more line&quot;</pre></div>
<div class="p">Finally, you use the <span class="code">-d</span> flag to delete branches.
<pre>$ git branch -d post-rename   # won't allow it
error: Cannot delete the branch 'post-rename' which you are currently on.
$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 2 commits.
$ git branch -d post-rename
error: The branch 'post-rename' is not fully merged.
If you are sure you want to delete it, run 'git branch -D post-rename'.</pre>
As you can see, git refuses to delete a branch that has unmerged work, since
this can lead to losing that unmerged work — so you need to use <span class="code">-D</span> for
that.  In addition, you usually don't delete remote branches, when you do,
you need to use the <span class="code">-r</span> flag too.</div>

<h3><a name="working_with_git_using_branches" style="page-break-before: always;">Working with git: Using branches</a></h3>
<div class="p">Since git branches are so light weight, they fit any kind of parallel work
you need to do on several different topics.  A result of that is that it is
possible to start a new branches for any work you'd want to do — and this is
common enough that there's a name for such branches, they're called “topic
branches”.  Such branches are created from the master branch (usually) and
worked on in parallel.  At any point where you want to work on something new,
you would create a new branch for it and switch to it (committing any work
you might have on your current branch before you do so):
<pre>$ git checkout -b improve-bar master # switch to a fresh topic branch
Switched to a new branch 'improve-bar'
$ echo &quot;even more bar&quot; &gt;&gt; bar        # work there
$ git ci -m &quot;improved bar&quot;           # save that work
$ git checkout post-rename           # go back to where we were</pre></div>
<div class="p">If you need to commit changes before you create the new branch, you shouldn't
have any problems doing so — because you can change where a branch points to,
you can just commit whatever you have and then get back to it:
<pre>$ echo &quot;another line&quot; &gt;&gt; foo.rkt
# at this point you remember that you need to do something else in the
# `improve-bar' line of work.
$ git ci -m &quot;checkpoint&quot;
$ git checkout improve-bar
# ...work...
$ git checkout post-rename
$ git log --oneline -2
e9a4fcd checkpoint            # this is our temporary checkpoint commit
d92fb0a one more line
$ git reset HEAD^             # undo it
Unstaged changes after reset:
M       foo.rkt               # git tells us that this is now uncommitted
$ git st
 M foo.rkt                    # ... as does `status'
$ git log --oneline -2
d92fb0a one more line         # the temporary commit is gone
599b3b6 properly name the foo library</pre></div>
<div class="p">You can even decide on some convention to use in some cases, then create new
git commands as scripts that will do the work for you.  In this case, you
could write a command that will do a “checkpoint” commit if needed, switch to
another branch, and if the first commit there has only <span class="code">checkpoint</span> as
its log message, undo it as above.  There are several git convenience
commands that started out this way — in this case, checkout the <span class="code">git
stash</span> command which allows you to save the current work by pushing it on a
“work in progress” stack, and later pop it back out (possibly on a different
branch).</div>
<div class="p">Earlier we've seen how to merge or rebase your master branch from the remote
master branch, but the full story is that you can merge and rebase <em>any</em>
two branches.  This makes branches very flexible: you can create a branch A
from an existing branch B, eventually merging/rebasing it back into A, or
directly into master and dump A.  At any point you can run <span class="code">gitk --all</span>
to see where things stand — in our current repository, this shows us that
there are redundant <span class="code">pre-rename</span> and <span class="code">also-pre-rename</span> branches, that
out <span class="code">master</span> branch is two commits ahead of the remote one, and that we
have <span class="code">improve-bar</span> and <span class="code">post-rename</span> branches with 1 and 2 commits
over our <span class="code">master</span> branch.  If we're done with these two branches, we can
now merge/rebase them to our <span class="code">master</span>, or merge/rebase one to the other
and the result to <span class="code">master</span>, and then push everything out.</div>
<div class="p">To make working with branches even easier, git has a notion of an “upstream
branch” — this is a per-branch setting that tells git which branch the
current one is based on.  By default, any branch that is created with a
remote branch as its starting point will have that remote branch set as its
upstream.  We've seen how git treats that information in various places so
far: <span class="code">git status</span> and <span class="code">git branch -v</span> both use it, and using a second
<span class="code">-v</span> with the latter shows also the upstream branch:
<pre>$ git reset --hard            # dump the above uncommitted change
$ git checkout master
Switched to branch 'master'
Your branch is ahead of 'origin/master' by 2 commits.
$ git status
# On branch master
# Your branch is ahead of 'origin/master' by 2 commits.
<i>...</i>
$ git branch -v
<i>...</i>
* master    599b3b6 [ahead 2] properly name the foo library
<i>...</i>
$ git branch -vv
* master    599b3b6 [origin/master: ahead 2] properly name the foo library</pre></div>
<div class="p">In addition to that, we've seen the <span class="code">@{upstream}</span> and <span class="code">@{u}</span>
notation that refers to the upstream branch, making it convenient to further
examine pending changes that weren't incorporated upstream:
<pre>$ git log --oneline @{upstream}..
599b3b6 properly name the foo library
0fb8291 document the type of foo</pre></div>
<div class="p">And finally, <span class="code">git pull</span> and <span class="code">git push</span> know where to pull from and
push to based on this setting.  Overall, this is a very useful feature to
have when you have many branches, therefore it is possible to use it between
local branches too.  There are two ways to do this: when a branch is created
with either <span class="code">git branch B</span> or <span class="code">git checkout -b B</span>, you can use the
<span class="code">--track</span> flag to set up tracking to the initial branch it's based on.
<pre>$ git branch -t b1 master
Branch b1 set up to track local branch master.
$ git checkout -tb b2 master
Branch b2 set up to track local branch master.
Switched to a new branch 'b2'</pre>
(Note: if you're using <span class="code">checkout</span>, then the <span class="code">--track</span> flag should
precede the <span class="code">-b</span> flag, as done above.)  If a branch already exists, you
can use <span class="code">git branch --set-upstream</span> to set the upstream information.
<pre>$ git branch --set-upstream post-rename
Branch post-rename set up to track local branch b2.
$ git branch --set-upstream improve-bar master
Branch improve-bar set up to track local branch master.</pre>
As seen here, if it is given just a branch name, the current branch is set as
its upstream.  <span class="code">git branch</span> can also change the upstream branch, for
example, if the above tracking of <span class="code">b2</span> was a mistake:
<pre>$ git branch --set-upstream post-rename master
Branch post-rename set up to track local branch master.</pre>
Either way, we can now see this information in the git commands that do so,
as well as use <span class="code">@{upstream}</span>:
<pre>$ git branch -vv
  b1          599b3b6 [master] properly name the foo library
* b2          599b3b6 [master] properly name the foo library
  improve-bar e60c168 [master: ahead 1] improved bar
  master      599b3b6 [origin/master: ahead 2] properly name the foo @;
                                               library
  post-rename d92fb0a [master: ahead 1] one more line
$ git checkout improve-bar
Switched to branch 'improve-bar'
Your branch is ahead of 'master' by 1 commit.
$ git log --oneline @{upstream}..
e60c168 improved bar</pre></div>
<div class="p">In addition, we can use <span class="code">git pull</span> to get changes on the upstream branch
merged or rebased on the current one:
<pre>$ git pull
From .
 * branch            master     -&gt; FETCH_HEAD
Already up-to-date.</pre>
Nothing actually happened here, because the current branch
(<span class="code">improve-bar</span>) already contains all of the commits on the master branch.
You can see that this is a local pull since git says <span class="code">From .</span>, which
stands for “our own repository”.  You can also do a <span class="code">push</span> now, which
will make the current additional commit (listed with <span class="code">@{upstream}..</span>)
appear on the <span class="code">master</span> branch:
<pre>$ git push
To .
   599b3b6..e60c168  improve-bar -&gt; master</pre></div>
<div class="p">Since the <span class="code">improve-bar</span> line of development is unrelated to the one in
<span class="code">post-rename</span>, it is now one commit behind the <span class="code">master</span> branch, and
cannot be pushed as is:
<pre>$ git checkout post-rename
Switched to branch 'post-rename'
Your branch and 'master' have diverged,
and have 1 and 1 different commit(s) each, respectively.
$ git branch -vv
  improve-bar     e60c168 [master] improved bar
  master          e60c168 [origin/master: ahead 3] improved bar
* post-rename     d92fb0a [master: ahead 1, behind 1] one more line
$ git push
To .
 ! [rejected]        post-rename -&gt; master (non-fast-forward)
error: failed to push some refs to '.'
To prevent you from losing history, non-fast-forward updates were rejected
<i>...</i></pre>
Dealing with this is similar to dealing with updates on the remote server —
for example, we can rebase the branch before pushing it:
<pre>$ git pull --rebase
From .
 * branch            master     -&gt; FETCH_HEAD
First, rewinding head to replay your work on top of it...
Applying: one more line
$ git push
To .
   e60c168..7bdec0c  post-rename -&gt; master</pre></div>
<div class="p">When you use <span class="code">git push</span> to push changes when you have no upstream branch
set, or when you push to a different branch than the one set, you can use
<span class="code">--set-upstream</span> to make git remember the push target as the upstream.
Therefore, an easy way to create a new branch that tracks a possibly new
remote branch by the same name is:
<pre>$ git checkout -b my-branch
Switched to a new branch 'my-branch'
$ git push origin my-branch --set-upstream
To pltgit:eli/foo
 * [new branch]      my-branch -&gt; my-branch
Branch my-branch set up to track remote branch my-branch from origin.</pre>
And when you deal with remote branches this way, you might want to have a
local branch that tracks a remote one with a different name.  To do this, you
use a syntax for the branch to push that specifies the local branch to push
and the remote one to push to:
<pre>$ git push origin my-branch:different-branch --set-upstream
To pltgit:eli/foo
 * [new branch]      my-branch -&gt; different-branch
Branch my-branch set up to track remote branch different-branch from origin.</pre></div>
<div class="p">Finally, note that git stores the upstream information in the
repository-local configuration file.  If we look at it now, we will see the
various upstreams that we have set:
<pre>$ cat .git/config
<i>...</i>
[remote &quot;origin&quot;]
        fetch = +refs/heads/*:refs/remotes/origin/*
        url = pltgit:eli/foo
[branch &quot;master&quot;]
        remote = origin
        merge = refs/heads/master
<i>...</i></pre>
this is the upstream that was made by default when we first checked out our
clone, together with the information of where the <span class="code">origin</span> repository is.
Following that are the ones we've setup later:
<pre><i>...</i>
[branch &quot;b1&quot;]
        remote = .
        merge = refs/heads/master
[branch &quot;b2&quot;]
        remote = .
        merge = refs/heads/master
[branch &quot;post-rename&quot;]
        remote = .
        merge = refs/heads/master
[branch &quot;improve-bar&quot;]
        remote = .
        merge = refs/heads/master
[branch &quot;my-branch&quot;]
        remote = origin
        merge = refs/heads/different-branch</pre></div>
<div class="p">Note that there are branches that track local branches (ones with a
<span class="code">remote = .</span> setting), and ones that track remote ones; and also note
that the <span class="code">my-branch</span> branch tracks a remote branch with a different name.
Since the settings are stored as configurations, it is possible to inspect
and change them using <span class="code">git config</span>, or even edit the config file
directly.
<pre>$ git config branch.my-branch.remote
origin
$ git config branch.my-branch.merge
refs/heads/different-branch</pre></div>

<h3><a name="working_with_git_managing_remotes" style="page-break-before: always;">Working with git: Managing remotes</a></h3>
<div class="p">The distributed nature of git means that you can interact with multiple
remote repositories.  You could have work done with other people done
locally, where people push/pull from each other's clones (possibly by sending
around patches, as described below), and eventually when the changes are
ready push them back to the main repository.  You can even have your
repository track multiple unrelated remote repositories, essentially giving
you branches that have <em>unrelated</em> histories.</div>
<div class="p">By default, when you clone a remote repository git names it <span class="code">origin</span> —
and that name appears in many places, most notably in remote branch names.
As seen in the above config, git remember where the origin repository is via
a configuration:
<pre>$ git config remote.origin.url
pltgit:eli/foo
$ git config remote.origin.fetch
+refs/heads/*:refs/remotes/origin/*</pre>
The first one is the url of the remote repository, and the second one is
which branches we want to get from it.  As with branches, you can use
<span class="code">git config</span> to change this information, or you can edit the file
directly, but there is a command that does this more conveniently, keeping
things consistent:
<pre>$ git remote                  # lists all known remotes
origin
$ git remote -v               # remotes and push/pull specs
origin  pltgit:eli/foo (fetch)
origin  pltgit:eli/foo (push)
$ git remote show origin      # see a detailed description
* remote origin
  Fetch URL: pltgit:eli/foo
  Push  URL: pltgit:eli/foo
  HEAD branch: master
  Remote branches:
    different-branch tracked
    master           tracked
    my-branch        tracked
  Local branches configured for 'git pull':
    master    merges with remote master
    my-branch merges with remote different-branch
  Local refs configured for 'git push':
    master    pushes to master    (fast-forwardable)
    my-branch pushes to my-branch (up to date)</pre></div>
<div class="p">The <span class="code">git remote show</span> variant will actually query the remote repository
for its state (using <span class="code">git ls-remote</span>) by default, and tell you when a
local branch that tracks a remote one is out-of-date.</div>
<div class="p">There are a few more sub-verbs for the <span class="code">git remote</span> command which you can
see on the <a href="http://www.kernel.org/pub/software/scm/git/docs/git-remote.html"><span class="man">git-remote</span></a> man page, the most important one is for adding a
remote: <span class="code">git remote add <i>short-name</i> <i>url</i></span>.  This is especially
convenient if you want to have a fork of the <span class="code">plt</span> repository, with most
interaction happening against it, but occasionally pull/push updates from/to
the main repository.</div>
<div class="p">Of course, remember that you don't need to add remotes to push and pull from
them.  You could do the same by explicitly specifying a url for the
repository you want to interact with.  For example, you could have
repositories in different accounts on different machines, and synchronize
your work between them by pushing and pulling directly from one repository to
another.  (Reminder: if you do this, then you're likely to have “checkpoint
commits” — when you're done with the work, you can do an interactive rebase,
and squash these checkpoint changes back into logical commit.)  But if you do
this often enough, you will likely find it more convenient to add a named
remote.</div>

<h3><a name="working_with_git_using_private_repositories" style="page-break-before: always;">Working with git: Using private repositories</a></h3>
<div class="p">A particularly useful use-case for adding a new remote is when you want to
have private work done in your own fork of the <span class="code">plt</span> repository.  Such a
mode of work is not strictly necessary — you could just do your work in your
repository in a long-lived branch, but there are certain cases where working
with a private repository on the server might be more convenient.  For
example, you might want to collaborate with someone else (that has access)
via the server, or you might use a private fork of the <span class="code">plt</span> repository
as a central point for synchronizing work from clones on different
filesystems as described at the end of the last section (the difference from
that is that you basically use the PLT server as your synchronization point).
Other than having the main repository reside on the PLT server, working with
a private repository is not different than working with any other repository.</div>
<div class="p">There are two facts that are worth reminding when you deal with a private
repository.  First, remember that creating a private fork is cheap: creating
a new git clone of a repository will use hard links to the repository store
object, most of which will be contained in large packed files.  The cost in
terms of space and time for creating a new clone is therefore minimal when
done on the same filesystem — and using the gitolite <span class="code">fork</span> command is
doing just that.  Please use the <span class="code">fork</span> command to create a private clone
— gitolite has a feature where it creates any repository that you refer to
(as long as it has a name that you're allowed to create — starts with your
username); this means that you could clone the main <span class="code">plt</span> repository and
push from it into a private repository that doesn't exist: it will be
created, but such a copy will not share storage with the main repository — it
will require a new copy, and it will be slow to create.</div>
<div class="p">The second thing to remember is that due to the nature of the git store, any
object, including commits, is stored exactly once.  Since commits contain
their parents, having a specific commit means that you have its complete
history — therefore, pulling in any branch from any repository will always
require getting only commits that you don't already have.  As a result,
pulling and pushing to/from any repository will be efficient and move around
only those commits that are missing on the other side.</div>
<div class="p">You can choose one of two basic approaches to working with a private fork:
you can have the public repository cloned but have branches pushed to your
private one, or you can have your private fork cloned and occasionally push
updates to the public one.  A way to use these two approaches are described
and explained now.  These examples use the <span class="code">play</span> repository as an
example (which you are encouraged to experiment with).  Note that you can use
a hybrid approach: you can think about a repository as a container for commit
histories, pushing and pulling from any other repository, including the copy
you're working with, the main <span class="code">plt</span> repository, or a private fork (your
own or another).  Note also that since forks are cheap, you can keep several
of them around, for example, you can have a fork for each long-lived branch —
it's up to you to settle on a layout that is convenient for your work.</div>
<h3>Using a clone of the public repository, pushing branches to your private
one:</h3>
<ol><li>Setting up:
<ul><li>Create a fork:
<pre>ssh pltgit fork play $user/play</pre></li>
<li>Get a local copy of the main repository:
<pre>git clone pltgit:play</pre>
(or continue working in an existing one)</li>
<li>Set up a convenient name for your private repository:
<pre>cd play
git remote add my-fork pltgit:$user/play</pre></li></ul></li>
<li>To start working on a private branch, create one, and push it to your
private repository:
<pre>git checkout -b my-branch</pre>
Then use <span class="code">push</span> to create this branch in your private repository, with
<span class="code">--set-upstream</span> so git will remember this setting:
<pre>git push --set-upstream my-fork my-branch</pre>
You can also have your branch named differently in your fork, for example:
<pre>git push --set-upstream my-fork my-branch:master</pre>
will save your branch as the <span class="code">master</span> branch in your fork.  This might
be convenient if you want to clone your private repository elsewhere and
work only on this branch.</li>
<li>You can now work as usual in your repository, pushing/pulling changes
to/from the master branch will go to the public repository, and doing so
from <span class="code">my-branch</span> will go to your private fork.  You can merge changes on
the <span class="code">master</span> branch to your private one, or rebase your branch onto it.
However, note that the server will not allow pushing a rebased history to
your clone.  (More details at the end of this section.)  You can bypass that
by pushing to a new branch while keeping your local branch name:
<pre>git push --set-upstream my-fork my-branch:my-branch-2</pre></li>
<li>When you're done merge your branch (possibly rebasing it first) to the
master branch, and push as usual.</li>
<li>If you want to delete branches on your fork (either because you pushed a
rebased version under a new name, or because you're done with that line of
work), use
<pre>git push my-fork :my-branch</pre>
Using an empty branch name for the local branch that you push is the way to
delete remote branches.  (As with local branches, this might lead to losing
commits, so be careful.  As always, git has a few safety mechanisms in
place, so even if did this by mistake, it is very likely recoverable.)</li></ol>
<h3>Using a clone of your private repository, pushing changes to the public
one:</h3>
<ol><li>Setting up:
<ul><li>Create a fork:
<pre>ssh pltgit fork play $user/play</pre></li>
<li>Get a local copy:
<pre>git clone pltgit:$user/play</pre></li>
<li>Set up a convenient name for the main repository:
<pre>cd play
git remote add -t master main pltgit:play</pre>
(<span class="code">-t master</span> tells git to have only the <span class="code">master</span> branch
retrieved.)</li></ul></li>
<li>Now you can work in this repository as usual — edit, commit, push, etc.</li>
<li>To push changes to the main repository, first make sure that you're on the
branch with the changes that you want to push, and then:
<ul><li>Get the recent tree from the main repository
<pre>git fetch main</pre></li>
<li>Rebase or merge your changes with this:
<pre>git rebase main/master</pre>
or
<pre>git merge main/master</pre></li>
<li>Push the changes back:
<pre>git push main</pre></li></ul>
Note that rebasing your branch on top of main/master means that it will be
rewritten, which means that you will not be able to push your branch back to
your clone.  This is because rewritten histories are currently forbidden by
the configuration, but this will probably change in the future.  Still, even
if the server would allow pushing a rebased history it (you will need to use
<span class="code">-f</span> to force such a push), you would need to deal with the rebased
branch in other clones you might have.  Because of this, a rebase is fine if
you're done with the work that you're pushing, otherwise, a merge is more
convenient.</li></ol>

<h2><a name="collaborating_with_others" style="page-break-before: always;">Collaborating with others</a></h2>
<div class="p">Git makes it very easy to collaborate with anyone, anywhere.  You should
think about repositories as being parts a network which can be synced in any
topology that is convenient for you.  In the case of the PLT repository, the
main repository on the git server is the central point where the official
repository lives, and people who can push are directly syncing content into
it.  People who cannot push directly do so through someone who can, by
sending out patches or “pull requests”.  The same applies for any repository,
of course, including private repositories, even ones that you maintain
yourself independently of the PLT server.</div>
<div class="p">In the case of a patch-based workflow, the two sides that are involved are
the patch author, and the receiver that integrates it into his/her own clone
(and from there it goes to the main repository as usual).  The work that each
side does is described in the next two subsections.</div>
<div class="p">Following that there is a description for making your repository public,
which you will need if you're working on a private repository, but it is also
useful for your collaborator to do so you can use a pull-request workflow.
In this mode there is no need to email patches; instead, both people make
their repositories readable to each other, and when some work is ready on one
person's repository, the other pulls the commits.  This is described in the
last subsection.</div>

<h3><a name="collaborating_with_others_patch_based_workflow_br_instructions_for_the_patch_sender_side" style="page-break-before: always;">Collaborating with others: Patch-based workflow<br />
— instructions for the patch sender side</a></h3>
<h4>Executive summary:</h4>
<ol><li>Work in a <span class="code">plt</span> repository clone (possibly in your own branch)</li>
<li><pre style="margin-left: 0;">$ git send-email origin/master</pre></li>
<li>You're done — thanks!</li>
<li>When the patch is applied, you will get the changes through
<span class="code">origin/master</span>, so if you worked on your master branch, make sure
to use <span class="code">git pull --rebase</span> which will notice that your changes were
applied; if you worked on a branch, then you can now delete it (the
commit objects will be different from the ones you've made).</li></ol>
<h4>Longer version:</h4>
<ol><li>Work &amp; commit as usual.  In general, it is a good idea to use
<span class="code">Signed-off-by: <i>Your Name</i> &lt;<i>your@email</i>&gt;</span> in commit messages,
which is a conventional way to declare that you agree for your work to be
released as part of the PLT project, under the terms of the LGPL.
<span class="code">git commit</span> will add that for you if you use the <span class="code">-s</span> flag.  You
can also make git do this later, when you send the patches out.</li>
<li>Make sure that you're working with a relatively recent clone, and that
you're on the branch where you did your work.  In most cases, this would be
the master branch, but you can do your work in your own branch too, of
course.</li>
<li><div class="p">Verify that your commits are all in your history.  You can see the commits
that you have over the <span class="code">plt</span> history with
<pre>git log --oneline origin/master..</pre>
these are the commits that you're going to send over now.  (You can use
the usual git toolset to tweak them further, or specify only some commits,
etc.)</div>
<div class="p">A relevant point to consider here is that git takes the first paragraph of
each commit message as a subject line.  When sending out a patch, this is
made concrete by actually using it as the emails's subject — so it is a
good idea to make sure that this log looks fine, since the <span class="code">--oneline</span>
option will make it show those subjects.</div>
<div class="p">Obviously, you should also make sure that the commits have clear
descriptions of your work.  People who in the core group often have some
general context that they are aware of, so some commit messages can be
cryptic or even worse (eg, you might find <span class="code">.</span> as a commit message) —
don't mimic this...  As a more occasional contributor, you should explain
your work in more details.  (There's no policy on commit messages, but you
do need to go through some person on the team.)</div></li>
<li><div class="p">At this point you should decide how to send your patches.  Emailing them
is be the most convenient way to do this — to do this, you would use the
<span class="code">send-email</span> command:
<pre>git send-email origin/master..</pre>
or if you send only some commits, use a different specification.  To make
things even easier, a single commit specification is considered as the
starting point and all of the following commits (up to your branch's tip)
will be included in the emails (in contrast to other git commands like
<span class="code">log</span>, where a single commit name is considered as the set of commits
leading up to it) — so you can do this:
<pre>git send-email origin/master</pre>
This will ask you a bunch of questions — it's easy to answer but you can
also specify them as command-line options.  if you intend to do this
frequently it might be a good idea to make it easier with some settings in
your global .gitconfig file.  For example, I have these settings:
<pre>[sendemail]
  from = Eli Barzilay &lt;eli@barzilay.org&gt;
  bcc = eli@barzilay.org
  suppresscc = self</pre>
and you can see more in the <a href="http://www.kernel.org/pub/software/scm/git/docs/git-config.html"><span class="man">git-config</span></a> and <a href="http://www.kernel.org/pub/software/scm/git/docs/git-send-email.html"><span class="man">git-send-email</span></a> man
pages.  The address to send the patches to is also configurable — you can
use something like
<pre>to = dev@racket-lang.org</pre>
or
<pre>to = someone@racket-lang.org</pre>
depending on who you send your patches to — but this is better done as a
repository-local configuration option (or just use the <span class="code">--to</span> flag).</div>
<div class="p">You can add a <span class="code">-s</span> flag to the command, to make git add
<span class="code">Signed-off-by</span> lines to commit messages.  (See above for what this
means.)</div>
<div class="p">If you want to send the files in some other way (eg, send them all
packaged in an archive as attachment[*]), then just use <span class="code">format-patch</span>
instead of <span class="code">send-email</span> — git will create a number of patch files in
your current directory, which will be named <span class="path">NNNN-text.patch</span> where
the text is made out of the subject lines of the commit messages (the
first line).  You can even run
<pre>git format-patch origin/master --stdout &gt; my-patch</pre>
to concatenate them all and send the resulting file over.</div>
<div class="p"><small>[*] Note that doing this means that it is not as easy to read your
patch, so avoid doing this if you want to make it easier to read and
accept it.  On the other hand, if you're working with someone specific,
they might prefer attachments (for example, it's easier to save the
attached file from gmail).</small></div></li>
<li>Once the commits have been pushed to the main repository, you would get
them when you pull to update.  The commits will now be different objects
than the ones you have — since the information changed (at least the
committer information will be different, the log message might have been
edited, etc).  If you made your commits on your master branch which is set
to track the <span class="code">plt</span> master branch (the usual setup), then make sure that
you run <span class="code">git pull --rebase</span> to update — this will identify the commits
as already included and will not include them in the rebased master.  But if
you made your commits in a private branch, and assuming that you didn't do
any additional work there, then you can now just delete that branch.  (If
you did do more work there, then you should rebase it, to avoid resending
the same patches again.)</li></ol>

<h3><a name="collaborating_with_others_patch_based_workflow_br_instructions_for_the_patch_receiver_side" style="page-break-before: always;">Collaborating with others: Patch-based workflow<br />
— instructions for the patch receiver side</a></h3>
<div class="p">Accepting patches that were sent via email (on any other way), is also
simple.  The command to do this is <span class="code">git am</span>, which expects an argument
that is a mailbox file holding the patch emails, or you could run it and pipe
a patch email into it.</div>
<h4>Executive summary:</h4>
<ol><li><pre style="margin-left: 0;">$ git checkout master</pre></li>
<li>Save (unmodified) patch emails into a mail folder file.</li>
<li><pre style="margin-left: 0;">$ git am -3 <i>the-mail-folder</i></pre></li>
<li>Push the changes up to the server</li></ol>
<h4>Longer version:</h4>
<ol><li>While you will not be author of the commits, you will be their committed, so
you should of course be aware of the changes, and be willing to maintain the
new code and other work that is implied.  So the first step that you should
do is review the patch and make sure that you are willing to accept
responsibility for it.</li>
<li>Save the patch emails to a mail folder (usually a file).  You must take care
to save the emails <em>as is</em>, including the date, author, and subject
headers, and avoiding text that could have been butchered by your email
client.  For example, if you're using gmail, then use the “show original”
option to view the raw email text, and save that to a file (even in this
format gmail will have a first line with a bunch of spaces — it's best to
remove that).  Otherwise, gmail does things like wrap lines, replaces spaces
by non-breaking spaces, or remove spaces.  Alternatively, extract patch
files from an archive if that's what you received, or save a single
attachment file etc.</li>
<li>In your repository clone, make sure that you're on the branch that you want
to integrate the changes into.  You could do this in your master branch, or
in a new topic branch (especially if there is more than one patch).</li>
<li>Run <span class="code">git am -3 mail-folder</span> (<span class="code">am</span> stands for “apply-mail”) with the
mail folder that you've created above.  It will apply the patches and commit
them one by one.  Like <span class="code">git rebase</span>, if there are conflicts the process
will stop so you can resolve it — and then run the <span class="code">am</span> command with
<span class="code">--continue</span>, or <span class="code">--skip</span> this commit and continue with the rest, or
<span class="code">--abort</span> to go back to the start.  The <span class="code">-3</span> flags tells git that if
a conflicting patch comes from the above <span class="code">format-patch</span>, and it
specifies files that we have, then try a 3-way merge — this will make things
generally better (and it can identify more patches that were applied,
instead of showing them as conflicts).
<br />
You can also use an <span class="code">-i</span> flag to the command to get an interactive
version — for each commit it will ask you what to do with it, and let you
edit the log message.</li>
<li>Finally push the commits as usual.</li></ol>

<h3><a name="collaborating_with_others_making_a_private_repository_publicly_available" style="page-break-before: always;">Collaborating with others: Making a private repository publicly available</a></h3>
<div class="p">If you're working with “outside people” (people with no accounts on the PLT
server, and no direct file-system access etc) on a private repository, you
will need to find some way to make your repository available for cloning.  An
easy way to do so is to put it on a filesystem that those people can access —
eg, if you're all in the same department.  Another easy way to make a
repository available is to find a hosting service like github and others —
there are many options here, some are free but limited, and some cost money;
if you prefer this easy solution, keep in mind that you can pay for the
duration of the collaboration and at the end you can simply keep your
repository clone to yourself (eg, if you're working on a paper then there's
no need to pay once all work is done).</div>
<div class="p">But if you want to do it yourself, the quickest and most convenient way to
make a repository public is to put it in a directory that is available on the
web.  Such repositories can be cloned directly from the URL the repository is
available at — there's no need to setup a server in a special way, and no
need to run cgi scripts.</div>
<h4>Executive summary:</h4>
<ol><li><pre style="margin-left: 0;">$ git clone --bare <i>your-repo</i> ~/public_html/<i>repo</i>.git</pre></li>
<li><pre style="margin-left: 0;">$ cd ~/public_html/<i>repo</i>.git/hooks;
mv post-update.sample post-update;
chmod +x post-update</pre></li>
<li><pre style="margin-left: 0;">$ git remote add public ~/public_html/<i>repo</i>.git</pre></li>
<li>Tell people to clone from <span class="code">http://some.where/~you/<i>repo</i>.git</span></li>
<li>Work, apply email patches, and: <span class="code">git push public</span></li></ol>
<h4>Longer version:</h4>
<ol><li>Make a “bare” repository — this is a repository that has no working
directory:
<pre>git clone --bare <i>your-repo</i> <i>repo</i>.git</pre>
This will create a <span class="path"><i>repo</i>.git</span> directory holding the bare
repository.  You should use some path in a directory where you have web
pages published.</li>
<li>The URL where the directory is found at is what other people should use when
cloning.</li>
<li>You can now push to this repository, and other people will see it too.  To
make things easier, you can set a remote name for this repository, so it's
easy for you to push changes to it.
<pre>git remote add public ~/public_html/<i>repo</i>.git</pre>
And now you can use <span class="code">git push public</span>.  (You can also pull from it, but
since you're going to be the only one who pushes into it, that will not be
necessary.)</li>
<li>One thing to be aware of is that while a repository can be published through
HTTP this way, git considers that a “dumb protocol” (because there is no
proper interaction between the two sides).  To still make cloning possible,
you will need to maintain some meta-files that hold entry points to the
objects in your repository — to get this, run:
<pre>git update-server-info</pre>
You need to run this after each update to the repository — and to automate
this you can have a hook do it for you.  In the bare repository you will
find a <span class="path">hooks</span> directory with a file called <span class="path">post-update.sample</span> —
simply rename this file to <span class="path">post-update</span>, and make it executable with
<span class="code">chmod +x post-update</span>.  From now on every push to this repository will
run the hook and keep the meta files updated.</li></ol>

<h3><a name="collaborating_with_others_pull_request_workflow" style="page-break-before: always;">Collaborating with others: Pull-request workflow</a></h3>
<div class="p">A possibly easier way for people to contribute work is to make their
repositories available somehow.  In the case of a private repository, the two
sides can be in a shared file system, with read permissions for each other;
or achieved as described in the previous subsection.  In the case of
contributing to the <span class="code">plt</span> repository, the contributor can maintain a
public fork of the <span class="code">plt</span> repository (eg, by forking the <span class="code">plt</span> github
mirror at <a href="https://github.com/plt/racket">https://github.com/plt/racket</a> directly on github).</div>
<div class="p">In this workflow there is no need to mail patches — instead, the receiver
simply pulls them directly from the sender's repository.  For example,
someone tells you that they have some new commits in a <span class="code">foo</span> branch of
their repository.  Since this is a repository that you can access, and since
it shares history with yours, you can just pull that branch in, for example:
<pre>git checkout -b someones-work
git pull <i>someones-repository-url</i></pre>
Note that the <span class="code">pull</span> will merge the changes, creating a merge
commit if your <span class="code">master</span> branch cannot be fast-forwarded.  To avoid
this, you can use <span class="code">fetch</span> instead:
<pre>git checkout -b someones-work
git fetch <i>someones-repository-url</i></pre>
Either way, this fetches the remote repository's HEAD.  You can create the
branch in a single fetch command by specifying the remote branch name, and
the local branch to fetch into, for example:
<pre>git fetch <i>someones-repository-url</i> master:someone</pre></div>
<div class="p">If you expect to do this often (eg, you're going to suggest fixes for the
work and get new work in), then you can add a <span class="code">someone</span> remote to be used
more conveniently:
<pre>git remote add someone <i>someones-repository-url</i>
git fetch someone
git checkout -b some-branch someone/some-branch</pre>
possibly using -t to make the branch track the remote one:
<pre>git checkout -tb some-branch someone/some-branch</pre>
Note that there is no need to create a branch before the <span class="code">fetch</span>, since
it will be fetched to a <span class="code">remotes/someone/master</span> branch.</div>
<div class="p">Once you pulled in the branch, you can inspect the changes, merge them,
rebase them, etc.  The important point here is that you have a copy of the
contributed line of work, which you can use with the usual git toolset.</div>
<div class="p">When/if you're happy with the changes, you can simply integrate them to your
master branch, and if this is in a clone of the <span class="code">plt</span> repository, then at
this point you can simply push these commits to the main server.  Once that
happens, the contributor can update their own clone, and continue working as
usual.</div>
<div class="p">Git has a tool that makes this mode of work a little more organized and
robust for the contributor: <span class="code">git request-pull</span>.  This simple command
(surprisingly, it has no flags) expects a commit that marks the start of the
new work (actually, the last one before it, eg, <span class="code">origin/master</span>), and the
url of the repository.  For example:
<pre>git request-pull origin git://github.com/someone/somefork.git</pre></div>
<div class="p">Of course, the contributor doesn't have to work directly in the available
repository — in the case of github or with an over-the-web setup like the one
described in the previous subsection the public repository is a bare one, and
no work can be done directly on it.  So what actually happens is: the
contributor works on his/her own repository, pushes changes to the public
one, and then requests a pull.</div>
<div class="p">The <span class="code">request-pull</span> command will therefore check that the new commits are
indeed available at that location, and find out the branch that they're on
(in case it's different than the branch that someone is working on).  It then
prints out a “pull request” text with a description of the changes, the url
that was specified, the branch name with the new work, and a summary of the
files that were changed.  In short, all the relevant information is there,
and it even verified that the commits are indeed available — merging them in
is now easy.</div>
<div class="p">(As a sidenote, you can use <span class="code">.</span> as the url:
<span class="code">git request-pull origin .</span>, and get a condensed summary of your
changes.)</div>

<h3><a name="collaborating_with_others_pull_request_workflow_br_recipe_for_the_sender_side" style="page-break-before: always;">Collaborating with others: Pull-request workflow<br />
— recipe for the sender side</a></h3>
<ol><li>Clone the <span class="code">plt</span> repository and work with it as usual, commit your
work</li>
<li>Make your repository publicly available</li>
<li><pre style="margin-left: 0;">$ git request-pull origin <i>your-repository-url</i></pre></li>
<li>Send the resulting text to <span class="code">dev@racket-lang.org</span></li>
<li>You're done — thanks!</li></ol>
<p>Alternatively, you can fork the <span class="code">plt</span> repository on github:
<span class="code">https://github.com/plt/racket</span>, commit, then do a pull request.  Note:
it is better to send a note about your pull request to <span class="code">dev@racket-lang.org</span>,
or you can do the pull request directly with git as listed above (using
github to have a public repository).</p>

<h3><a name="collaborating_with_others_pull_request_workflow_br_recipe_for_the_receiver_side" style="page-break-before: always;">Collaborating with others: Pull-request workflow<br />
— recipe for the receiver side</a></h3>
<p>This recipe is for getting some remote work in as a one-time job.  If you
need to cooperate more closely with someone, you will want to add the remote
repository with <span class="code">git remote</span> as shown above.</p>
<ol><li>Get a <span class="code">plt</span> clone, or use your own (it's safe to do the latter, no need
for a new clone unless you're paranoid):
<pre>git clone pltgit:plt
cd plt</pre></li>
<li>Get the foreign repository's master branch (or any other branch) into a
local branch:
<pre>git fetch <i>remote-repository-url</i> master:foo</pre>
This pulls the <span class="code">master</span> branch of the remote repository into a local
<span class="code">foo</span> branch (you can use other names, of course).</li>
<li>Inspect the changes as usual
<pre>git log master..foo    # new commits
git diff master...foo  # changes
git log -p master..foo # both</pre>
(See above for more details on these.)</li>
<li>If you're happy with the change and want to get it as-is, you can simply
<span class="code">merge</span> the branch:
<pre>git merge foo</pre>
But unless the remote work was done from the point your <span class="code">master</span> points
at (i.e., there were no new commits), this will generate a merge commit that
might not be desired.  To avoid it, you can rebase the branch against your
<span class="code">master</span> and then do the <span class="code">merge</span> (which will now be a fast-forward)
merge:
<pre>git checkout foo
git rebase master
git checkout master
git merge foo</pre></li>
<li>You no longer need the <span class="code">foo</span> branch, so delete it with:
<pre>git branch -d foo</pre></li>
<li>Push things back as usual</li></ol>

<h3><a name="collaborating_with_others_merging_github_pull_requests" style="page-break-before: always;">Collaborating with others: Merging github pull-requests</a></h3>
<div class="p">Github is popular enough that some people prefer to work with a github fork
of the PLT repository, and then send a pull request.  Merging these pull
requests can be done as with any other repository, as explained in the
previous section.  However, with github there is an easy way to deal with
it.</div>
<div class="p">A pull request has a URL like <span class="code">https://github.com/plt/racket/pull/123</span>
which you can use in your browser to inspect the changes.  To apply the
changes locally, a convenient feature is that you can add a <span class="code">.patch</span>
suffix to every pull request URL which will have a text version of the patch.
This means that applying the patch is particularly easy on the command line,
for example:
<pre>curl https://github.com/plt/racket/pull/123.patch | git am</pre>
will fetch the patch text and apply it (and you can now push as usual, or
locally inspect the ptach and possibly edit it in the usual ways).</div>

<h2><a name="additional_resources" style="page-break-before: always;">Additional Resources</a></h2>
<dl><dt><strong>Quick and short:</strong></dt>
<dd><dl><dt><a href="http://eagain.net/articles/git-for-computer-scientists/">http://eagain.net/articles/git-for-computer-scientists/</a></dt>
<dd>Basic description of what makes a git repository</dd>
<dt>Cheat sheets:</dt>
<dd><dl><dt><a href="http://gitref.org/">http://gitref.org/</a></dt>
<dd>Quick reference thing, with links to the git man pages and the progit
book</dd>
<dt><a href="http://jonas.nitro.dk/git/quick-reference.html">http://jonas.nitro.dk/git/quick-reference.html</a></dt>
<dd>Really short</dd>
<dt><a href="http://cheat.errtheblog.com/s/git">http://cheat.errtheblog.com/s/git</a></dt>
<dd>Explains some more</dd>
<dt><a href="http://ktown.kde.org/~zrusin/git/git-cheat-sheet.svg">http://ktown.kde.org/~zrusin/git/git-cheat-sheet.svg</a></dt>
<dd>Short, intended for printing</dd>
<dt><a href="http://help.github.com/git-cheat-sheets/">http://help.github.com/git-cheat-sheets/</a></dt>
<dd>Similar</dd></dl></dd>
<dt><a href="http://git.or.cz/course/svn.html">http://git.or.cz/course/svn.html</a></dt>
<dd>subversion-&gt;git crash course</dd>
<dt><a href="http://www.kernel.org/pub/software/scm/git/docs/everyday.html">http://www.kernel.org/pub/software/scm/git/docs/everyday.html</a></dt>
<dd>Nice summary of a few things, but too verbose or too advanced in some
places, and also a little outdated.</dd></dl></dd>
<dt><strong>Books:</strong></dt>
<dd><dl><dt><a href="http://book.git-scm.com/">http://book.git-scm.com/</a></dt>
<dd>The git community book.  Also, there are a bunch of videos
linked, and some tutorial links in the “Welcome” part.</dd>
<dt><a href="http://progit.org/book/">http://progit.org/book/</a></dt>
<dd>A frequently recommended book.  (Also some good blog entries.)</dd>
<dt><a href="http://www-cs-students.stanford.edu/~blynn/gitmagic/">http://www-cs-students.stanford.edu/~blynn/gitmagic/</a></dt>
<dd>Another good book (a bit more verbose than the previous one)</dd></dl></dd>
<dt><strong>Misc:</strong></dt>
<dd><dl><dt><a href="http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html">http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html</a></dt>
<dd>The git tutorial, also available as the <a href="http://www.kernel.org/pub/software/scm/git/docs/gittutorial.html"><span class="man">gittutorial</span></a> man page.</dd>
<dt><a href="http://help.github.com/">http://help.github.com/</a></dt>
<dd>Some github guides, well-organized by levels.</dd>
<dt><a href="http://www.gitready.com/">http://www.gitready.com/</a></dt>
<dd>A kind of a collection of small tips; didn't change in a while though.</dd>
<dt><a href="http://marklodato.github.com/visual-git-guide/">http://marklodato.github.com/visual-git-guide/</a></dt>
<dd>This is a short visual document about git.  But it goes a little fast, so
it would be useful after you're comfortable with the basics.</dd></dl></dd></dl>
</div></div></div></div>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script>
//<![CDATA[
window.jQuery || document.write('<script src=https://racket-lang.org/jquery-1.9.1.min.js><\/script>')
//]]>
</script>
<script src="https://racket-lang.org/gumby.min.js"></script>
<script src="https://racket-lang.org/plugins.js"></script>
<script src="https://racket-lang.org/main.js"></script>
</body></html>
